<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[模板] 板子汇总]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%A8%A1%E6%9D%BF-%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[汇总一些比赛中常用的模板，权当复习及参考用。 快读快输1234567891011121314151617181920212223inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; // 这两个局部变量千万别开 static 还不重新赋值，否则会 GG while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x == 0) &#123; putchar('0'); return; &#125; static int stk[100], top = 0; // 这个开 static 问题不大 if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125; Dijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x7f7f7f7f#define N 500010struct edgeNode &#123; int vertexTo; int weight; int edgeNext;&#125; edges[N &lt;&lt; 1];int heads[N], numEdges, n, m, x, y, z, s, e;inline void initGraph() &#123; memset(heads, -1, sizeof(heads)); numEdges = 0;&#125;inline void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].weight = weight; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;struct heapNode &#123; int u, d; bool operator&lt;(const heapNode&amp; b) const &#123; return b.d &lt; d; &#125;&#125;;priority_queue&lt;heapNode&gt; Q;int dist[N];inline void Dijkstra(int x) &#123; while (!Q.empty()) Q.pop(); for (int i = 1; i &lt;= n; ++i) dist[i] = INF; dist[x] = 0; Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int d = f.d; if (d != dist[u]) continue; for (int i = heads[u]; i != -1; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; int w = edges[i].weight; if (dist[y] &gt; dist[u] + w) &#123; dist[y] = dist[u] + w; Q.push((heapNode)&#123; y, dist[y] &#125;); &#125; &#125; &#125;&#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; initGraph(); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; addEdge(x, y, z); &#125; Dijkstra(s); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; dist[i] &lt;&lt; " "; return 0;&#125; 倍增 LCA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// lca.cpp// get the lca(Lowest Common Ancestor)#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500010#define M 500010inline void read(int &amp;x) &#123; x = 0; char ch = 0; bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125;struct edgeNode &#123; int vertexTo; int edgeNext;&#125; edges[M &lt;&lt; 1];int heads[N], numEdges = 0;int n, m, s, x, y, a, b, t;int dep[N], f[N][20];queue&lt;int&gt; Q;void BFS() &#123; memset(dep, 0, sizeof(dep)); Q.push(s); dep[s] = 1; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = heads[x]; i != -1; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; if (dep[y]) continue; dep[y] = dep[x] + 1; f[y][0] = x; for (int j = 1; j &lt;= t; ++j) f[y][j] = f[f[y][j - 1]][j - 1]; Q.push(y); &#125; &#125;&#125;int LCA(int x, int y) &#123; if (dep[x] &gt; dep[y]) swap(x, y); // let dep[x] &lt; dep[y] for (int i = t; i &gt;= 0; --i) if (dep[f[y][i]] &gt;= dep[x]) y = f[y][i]; if (x == y) return x; for (int i = t; i &gt;= 0; --i) if (f[x][i] != f[y][i]) &#123; x = f[x][i]; y = f[y][i]; &#125; return f[x][0];&#125;inline void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;inline void addDuplexEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1);&#125;int main() &#123; read(n); read(m); read(s); memset(heads, -1, sizeof(heads)); for (int i = 1; i &lt;= n - 1; ++i) &#123; read(x); read(y); addDuplexEdge(x, y); &#125; // initialize the tree t = (int)(log(n) / log(2)) + 1; BFS(); // prepare the LCA while (m--) &#123; read(a); read(b); write(LCA(a, b)); puts(""); &#125; return 0;&#125; Tarjan 缩点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1010// 似乎开大了会 Segmentation Fault (core dumped)struct edgeNode &#123; int vertexTo; int edgeNext; &#125;;struct graph &#123; edgeNode edges[N]; int heads[N], numEdges; int stk[N], top; bool instk[N]; int dfn[N], low[N], clr[N], num, cnt; vector&lt;int&gt; scc[N]; inline void init() &#123; numEdges = 0; top = 0; num = 0; cnt = 0; memset(heads, -1, sizeof(heads)); memset(stk, 0, sizeof(stk)); memset(instk, false, sizeof(instk)); memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); memset(clr, 0, sizeof(clr)); &#125; inline void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges; &#125; inline void addUndirectedEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1); &#125; inline void Tarjan(int x) &#123; dfn[x] = low[x] = ++num; stk[++top] = x; instk[x] = true; for (int i = heads[x]; i != -1; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; if (!dfn[y]) &#123; Tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (instk[y]) &#123; low[x] = min(low[x], dfn[y]); &#125; &#125; if (dfn[x] == low[x]) &#123; cnt++; int y; do &#123; y = stk[top--]; instk[y] = false; clr[y] = cnt; scc[cnt].push_back(y); &#125; while (x != y); &#125; &#125;&#125;;int n, m, u, v;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; graph g0, g1; g0.init(); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; g0.addEdge(u, v); &#125; for (int i = 1; i &lt;= n; ++i) if (!g0.dfn[i]) g0.Tarjan(i); g1.init(); for (int x = 1; x &lt;= n; ++x) &#123; for (int i = g0.heads[x]; i != -1; i = g0.edges[i].edgeNext) &#123; int y = g0.edges[i].vertexTo; if (g0.clr[x] == g0.clr[y]) continue; g1.addEdge(g0.clr[x], g0.clr[y]); &#125; &#125; cout &lt;&lt; g1.numEdges; return 0;&#125; 线段树区间最大值（单点修改）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// the segment tree to get thr max number in a array;#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10010 // leave node numberstruct segmentTree &#123; int l, r, dat; &#125;;segmentTree t[N * 4];int n, m, a[N], opt, x, y;inline void build(int p, int l, int r) &#123; t[p].l = l; t[p].r = r; if (l == r) &#123; t[p].dat = a[l]; return; &#125; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); // store thr max number&#125;inline void change(int p, int x, int v) &#123; if (t[p].l == t[p].r) &#123; t[p].dat = v; return; &#125; int mid = (t[p].l + t[p].r) / 2; if (x &lt;= mid) change(p * 2, x, v); else change(p * 2 + 1, x, v); t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat);&#125;inline int query(int p, int l, int r) &#123; if (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].dat; int mid = (t[p].l + t[p].r) / 2; int val = -(1 &lt;&lt; 30); if (l &lt;= mid) val = max(val, query(p * 2, l, r)); if (r &gt; mid) val = max(val, query(p * 2 + 1, l, r)); return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; switch(opt) &#123; case 1: &#123; change(1, x, y); break; &#125; case 2: &#123; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; 区间和（单点修改）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010struct segmentTreeNode &#123; int l, r, dat; &#125;;segmentTreeNode t[maxn * 4];int a[maxn], n, m, opt, x, y;inline void build(int p, int l, int r) &#123; t[p].l = l; t[p].r = r; if (l == r) &#123; t[p].dat = a[l]; return; &#125; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); t[p].dat = t[p * 2].dat + t[p * 2 + 1].dat;&#125;inline void change(int p, int x, int v) &#123; if (t[p].l == t[p].r) &#123; t[p].dat = v; return; &#125; int mid = (t[p].l + t[p].r) / 2; if (x &lt;= mid) change(p * 2, x, v); else change(p * 2 + 1, x, v); t[p].dat = t[p * 2].dat + t[p * 2 + 1].dat;&#125;inline int query(int p, int l, int r) &#123; if (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].dat; int mid = (t[p].l + t[p].r) / 2; int val = 0; if (l &lt;= mid) val += query(p * 2, l, r); if (r &gt; mid) val += query(p * 2 + 1, l, r); return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; switch (opt) &#123; case 1: &#123; change(1, x, y); break; &#125; case 2: &#123; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; 区间和（区间修改）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// segmentTree2.cpp// modify in a interval// 1 x y k: add `k` to all the value in [x, y]// 2 x y: ask the sum in [x, y]#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 500010typedef long long int64;struct segmentTreeNode &#123; int l, r; int64 sum, add; &#125;;segmentTreeNode t[maxn * 4];int a[maxn], n, m, op, x, y, k;#define l(x) t[x].l#define r(x) t[x].r#define sum(x) t[x].sum#define add(x) t[x].add inline void build(int p, int l, int r) &#123; l(p) = l; r(p) = r; add(p) = 0; if (l == r) &#123; sum(p) = a[l]; return; &#125; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); &#125;inline void spread(int p) &#123; if (add(p)) &#123; sum(p * 2) += add(p) * (r(p * 2) - l(p * 2) + 1); sum(p * 2 + 1) += add(p) * (r(p * 2 + 1) - l(p * 2 + 1) + 1); add(p * 2) += add(p); add(p * 2 + 1) += add(p); add(p) = 0; &#125;&#125;inline void change(int p, int l, int r, int d) &#123; if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) &#123; sum(p) += (int64)d * (r(p) - l(p) + 1); add(p) += d; return; &#125; spread(p); int mid = (l(p) + r(p)) / 2; if (l &lt;= mid) change(p * 2, l, r, d); if (r &gt; mid) change(p * 2 + 1, l, r, d); sum(p) = sum(p * 2) + sum(p * 2 + 1);&#125;inline int64 ask(int p, int l, int r) &#123; if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) return sum(p); spread(p); int mid = (l(p) + r(p)) / 2; int64 val = 0; if (l &lt;= mid) val += ask(p * 2, l, r); if (r &gt; mid) val += ask(p * 2 + 1, l, r); return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; cin &gt;&gt; op; switch (op) &#123; case 1: &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; change(1, x, y, k); break; &#125; case 2: &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; ask(1, x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; zkw 单点修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 500010int tree[maxn * 4], a[maxn], M, N, opM, op, x, y;inline void maintain(int p) &#123; tree[p] = tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1];&#125;inline void build() &#123; for (M = 1; M &lt; N; M &lt;&lt;= 1); for (int i = M + 1; i &lt;= M + N; ++i) tree[i] = a[i - M]; for (int i = M - 1; i; --i) maintain(i);&#125;inline void update(int p, int v) &#123; p += M; tree[p] = v; for (p &gt;&gt;= 1; p; p &gt;&gt;= 1) maintain(p);&#125;inline int query(int l, int r) &#123; int val = 0; for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) val += tree[l ^ 1]; if (r &amp; 1) val += tree[r ^ 1]; &#125; return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; N &gt;&gt; opM; for (int i = 1; i &lt;= N; ++i) cin &gt;&gt; a[i]; build(); while (opM--) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; switch (op) &#123; case 1: &#123; update(x, a[x] += y); break; &#125; // add y to a[x] case 2: &#123; cout &lt;&lt; query(x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; zkw 区间修改123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 500010typedef long long int64;struct segmentTreeNode &#123; int l, r; int64 tag, sum; &#125;;segmentTreeNode tree[maxn * 4];int a[maxn], N, M;int opM, op, x, y, v;#define lson(x) (x &lt;&lt; 1)#define rson(x) (x &lt;&lt; 1 | 1)#define l(x) tree[x].l#define r(x) tree[x].r#define sum(x) tree[x].sum#define tag(x) tree[x].taginline void pushDown(int p) &#123; if (tag(p) &amp;&amp; p &lt; M) &#123; tag(lson(p)) += tag(p); tag(rson(p)) += tag(p); sum(lson(p)) += (r(lson(p)) - l(lson(p)) + 1) * tag(p); sum(rson(p)) += (r(rson(p)) - l(rson(p)) + 1) * tag(p); tag(p) = 0; &#125;&#125;inline void maintain(int p) &#123; sum(p) = sum(lson(p)) + sum(rson(p)); &#125;inline void build() &#123; for (M = 1; M &lt; N; M &lt;&lt;= 1); for (int i = M + 1; i &lt;= M + N; ++i) &#123; sum(i) = a[i - M]; l(i) = r(i) = i - M; &#125; for (int i = M - 1; i; --i) &#123; maintain(i); l(i) = l(lson(i)); r(i) = r(rson(i)); // question &#125;&#125;inline void applyTag(int p) &#123; static int stk[maxn * 4], top = 0; while (p) &#123; stk[++top] = p; p &gt;&gt;= 1; &#125; while (top) pushDown(stk[top--]);&#125;inline void update(int l, int r, int v) &#123; bool vl, vr; vl = vr = false; int p, sl, sr; for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) &#123; p = l ^ 1; if (!vl) &#123; sl = p; applyTag(p); vl = true; &#125; tag(p) += v; sum(p) += (r(p) - l(p) + 1) * v; &#125; if (r &amp; 1) &#123; p = r ^ 1; if (!vr) &#123; sr = p; applyTag(p); vr = true; &#125; tag(p) += v; sum(p) += (r(p) - l(p) + 1) * v; &#125; &#125; for (sl &gt;&gt;= 1; sl; sl &gt;&gt;= 1) maintain(sl); for (sr &gt;&gt;= 1; sr; sr &gt;&gt;= 1) maintain(sr);&#125;inline int64 query(int l, int r) &#123; bool vl, vr; vl = vr = false; int64 val = 0; for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) &#123; if (!vl) applyTag(l ^ 1); val += sum(l ^ 1); &#125; if (r &amp; 1) &#123; if (!vr) applyTag(r ^ 1); val += sum(r ^ 1); &#125; &#125; return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; N &gt;&gt; opM; for (int i = 1; i &lt;= N; ++i) cin &gt;&gt; a[i]; build(); while (opM--) &#123; cin &gt;&gt; op; switch (op) &#123; case 1: &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; update(x, y, v); break; &#125; case 2: &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; 树状数组单点修改123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;#define lowbit(x) (x &amp; -x)#define maxn 500010int n, m, c[maxn], a[maxn], op, x, y;int ask(int x) &#123; int ans = 0; for (; x; x -= lowbit(x)) ans += c[x]; return ans;&#125;int ask(int l, int r) &#123; return ask(r) - ask(l - 1);&#125;void add(int x, int y) &#123; for (; x &lt;= n; x += lowbit(x)) c[x] += y;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) add(i, a[i]); while (m--) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; switch (op) &#123; case 1: &#123; add(x, y); break; &#125; case 2: &#123; cout &lt;&lt; ask(x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; 区间修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 500010#define lowbit(x) (x &amp; -x)inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int a[maxn], b[maxn], n, m, op, x, y, k;inline int ask(int x) &#123; int ans = 0; for (; x; x -= lowbit(x)) ans += b[x]; return ans;&#125;inline void add(int x, int y) &#123; for (; x &lt;= n; x += lowbit(x)) b[x] += y;&#125;int main() &#123; read(n); read(m); memset(b, 0, sizeof(b)); for (int i = 1; i &lt;= n; ++i) read(a[i]); while (m--) &#123; read(op); switch(op) &#123; case 1: &#123; read(x), read(y); read(k); add(x, k); add(y + 1, -k); break; &#125; case 2: &#123; read(x); write(a[x] + ask(x)); puts(""); break; &#125; &#125; &#125; return 0;&#125; 树状数组求逆序对1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define lowbit(x) (x &amp; -x)int a[maxn], n;int c[maxn], num = 0;inline void add(int x, int y) &#123; for (; x &lt;= n; x += lowbit(x)) c[x] += y;&#125;inline int ask(int x) &#123; int ans = 0; for (; x; x -= lowbit(x)) ans += c[x]; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = n; i; --i) &#123; num += ask(a[i] - 1); add(a[i], 1); &#125; cout &lt;&lt; num; return 0;&#125; Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define INF 0x7fffffffstruct treapNode &#123; int lChild, rChild; // 左右子节点下标 int value, weight; // 节点关键码及权值 int count, size; // 副本数及子树大小&#125; treap[maxn];int numNodes, root, n;int newNode(int val) &#123; numNodes++; treap[numNodes].value = val; treap[numNodes].weight = rand(); // 随机权值 treap[numNodes].count = treap[numNodes].size = 1; return numNodes;&#125; // 建立一个新的节点void update(int p) &#123; treap[p].size = treap[treap[p].lChild].size + treap[treap[p].rChild].size + treap[p].count;&#125; // 更新某一个点的 size 方便获取排名void build() &#123; newNode(-INF); // 保证 BST 性质的两个点 newNode(INF); root = 1; treap[root].rChild = 2; update(root);&#125; // 初始化int getRankByVal(int p, int val) &#123; if (p == 0) return 0; if (val == treap[p].value) return treap[treap[p].lChild].size + 1; if (val &lt; treap[p].value) return getRankByVal(treap[p].lChild, val); return getRankByVal(treap[p].rChild, val) + treap[treap[p].lChild].size + treap[p].count;&#125;// 上下两个函数很好理解，不作赘述// 一切从 BST 性质出发int getValByRank(int p, int rnk) &#123; if (p == 0) return INF; if (treap[treap[p].lChild].size &gt;= rnk) return getValByRank(treap[p].lChild, rnk); if (treap[treap[p].lChild].size + treap[p].count &gt;= rnk) return treap[p].value; return getValByRank(treap[p].rChild, rnk - treap[treap[p].lChild].size - treap[p].count);&#125;void zig(int &amp;p) &#123; int q = treap[p].lChild; treap[p].lChild = treap[q].rChild; treap[q].rChild = p; p = q; update(treap[p].rChild); update(p); // 别忘记更新&#125;void zag(int &amp;p) &#123; int q = treap[p].rChild; treap[p].rChild = treap[q].lChild; treap[q].lChild = p; p = q; update(treap[p].lChild); update(p);&#125;void insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == treap[p].value) &#123; treap[p].count++; update(p); return; &#125; if (val &lt; treap[p].value) &#123; insert(treap[p].lChild, val); if (treap[p].weight &lt; treap[treap[p].lChild].weight) zig(p); &#125; else &#123; insert(treap[p].rChild, val); if (treap[p].weight &lt; treap[treap[p].rChild].weight) zag(p); &#125; // zig 和 zag 操作，保证满足大根堆性质 update(p);&#125; // 插入一个点int getPre(int val) &#123; int ans = 1; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].lChild &gt; 0) &#123; p = treap[p].lChild; // 左子树上不断向右走，获取最大的前驱 while (treap[p].rChild &gt; 0) p = treap[p].rChild; ans = p; &#125; break; &#125; if (treap[p].value &lt; val &amp;&amp; treap[p].value &gt; treap[ans].value) ans = p; // 尝试更新答案 p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125; // 获取前驱int getNext(int val) &#123; int ans = 2; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].rChild &gt; 0) &#123; p = treap[p].rChild; // 右子树上不断向左走，获取最小的后继 while (treap[p].lChild &gt; 0) p = treap[p].lChild; ans = p; &#125; break; &#125; if (treap[p].value &gt; val &amp;&amp; treap[p].value &lt; treap[ans].value) ans = p; // 尝试更新答案 p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125;void remove(int &amp;p, int val) &#123; if (p == 0) return; if (val == treap[p].value) &#123; if (treap[p].count &gt; 1) &#123; treap[p].count--; update(p); &#125; else if (treap[p].lChild != 0 || treap[p].rChild != 0) &#123; if (treap[p].rChild == 0 || treap[treap[p].lChild].weight &gt; treap[treap[p].rChild].weight) &#123; zig(p); remove(treap[p].rChild, val); &#125; else &#123; zag(p); remove(treap[p].lChild, val); &#125; // 通过旋转来删除节点 update(p); &#125; else p = 0; return; &#125; if (val &lt; treap[p].value) remove(treap[p].lChild, val); else remove(treap[p].rChild, val); update(p);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); numNodes = 0; build(); cin &gt;&gt; n; int opt, x; while (n--) &#123; cin &gt;&gt; opt &gt;&gt; x; switch (opt) &#123; case 1: &#123; insert(root, x); break; &#125; case 2: &#123; remove(root, x); break; &#125; case 3: &#123; cout &lt;&lt; getRankByVal(root, x) - 1 &lt;&lt; endl; break; &#125; // 减一 case 4: &#123; cout &lt;&lt; getValByRank(root, x + 1) &lt;&lt; endl; break; &#125; // 加一 case 5: &#123; cout &lt;&lt; getPre(x) &lt;&lt; endl; break; &#125; case 6: &#123; cout &lt;&lt; getNext(x) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; 封装成类的 Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;template &lt;typename T&gt;struct treapNode &#123; T value; size_t lChild, rChild, count, size; int weight; treapNode(T val) : value(val), lChild(0), rChild(0), count(1), size(1) &#123; weight = rand(); &#125;&#125;;template &lt;typename T&gt;class treap &#123; public: treap(size_t N, T maximum, T minimum) : numNodes_(0), maximum_(maximum), minimum_(minimum) &#123; dat_ = (treapNode&lt;T&gt;*)malloc(N * sizeof(treapNode&lt;T&gt;)); &#125; ~treap() &#123; delete[] dat_; &#125; inline size_t root() &#123; return root_; &#125; inline size_t newNode(T val); inline void update(size_t p); inline void build(); size_t rankByVal(size_t p, T val); T valByRank(size_t p, size_t rnk); inline T pre(T val); inline T nxt(T val); inline void zig(size_t &amp;p); inline void zag(size_t &amp;p); void remove(size_t &amp;p, T val); void insert(size_t &amp;p, T val); inline size_t rankByVal(T val) &#123; return rankByVal(root_, val); &#125; inline T valByRank(size_t rnk) &#123; return valByRank(root_, rnk); &#125; inline void remove(T val) &#123; remove(root_, val); &#125; inline void insert(T val) &#123; insert(root_, val); &#125; private: treapNode&lt;T&gt; *dat_; size_t root_, numNodes_; T maximum_, minimum_;&#125;;template &lt;typename T&gt;inline size_t treap&lt;T&gt;::newNode(T val) &#123; numNodes_++; dat_[numNodes_] = treapNode&lt;T&gt;(val); return numNodes_;&#125;template &lt;typename T&gt;inline void treap&lt;T&gt;::update(size_t p) &#123; dat_[p].size = dat_[dat_[p].lChild].size + dat_[dat_[p].rChild].size + dat_[p].count;&#125;template &lt;typename T&gt;inline void treap&lt;T&gt;::build() &#123; root_ = newNode(minimum_); // root_ = 1 dat_[root_].rChild = newNode(maximum_); // dat_[2].value = maximum_ update(root_);&#125;template &lt;typename T&gt;size_t treap&lt;T&gt;::rankByVal(size_t p, T val) &#123; if (p == 0) return 0; if (dat_[p].value == val) return dat_[dat_[p].lChild].size + 1; if (val &lt; dat_[p].value) return rankByVal(dat_[p].lChild, val); return rankByVal(dat_[p].rChild, val) + dat_[dat_[p].lChild].size + dat_[p].count;&#125;template &lt;typename T&gt;T treap&lt;T&gt;::valByRank(size_t p, size_t rnk) &#123; if (p == 0) return maximum_; if (dat_[dat_[p].lChild].size &gt;= rnk) return valByRank(dat_[p].lChild, rnk); if (dat_[dat_[p].lChild].size + dat_[p].count &gt;= rnk) return dat_[p].value; return valByRank( dat_[p].rChild, rnk - dat_[dat_[p].lChild].size - dat_[p].count);&#125;template &lt;typename T&gt;inline T treap&lt;T&gt;::pre(T val) &#123; size_t ans = 1; size_t p = root_; while (p != 0) &#123; if (val == dat_[p].value) &#123; if (dat_[p].lChild &gt; 0) &#123; p = dat_[p].lChild; while (dat_[p].rChild &gt; 0) p = dat_[p].rChild; ans = p; &#125; break; &#125; if (dat_[p].value &lt; val &amp;&amp; dat_[p].value &gt; dat_[ans].value) ans = p; p = val &lt; dat_[p].value ? dat_[p].lChild : dat_[p].rChild; &#125; return dat_[ans].value;&#125;template &lt;typename T&gt;inline T treap&lt;T&gt;::nxt(T val) &#123; size_t ans = 2; size_t p = root_; while (p != 0) &#123; if (val == dat_[p].value) &#123; if (dat_[p].rChild &gt; 0) &#123; p = dat_[p].rChild; while (dat_[p].lChild &gt; 0) p = dat_[p].lChild; ans = p; &#125; break; &#125; if (dat_[p].value &gt; val &amp;&amp; dat_[p].value &lt; dat_[ans].value) ans = p; p = val &lt; dat_[p].value ? dat_[p].lChild : dat_[p].rChild; &#125; return dat_[ans].value;&#125;template &lt;typename T&gt;inline void treap&lt;T&gt;::zig(size_t &amp;p) &#123; int q = dat_[p].lChild; dat_[p].lChild = dat_[q].rChild; dat_[q].rChild = p; p = q; update(dat_[p].rChild); update(p);&#125;template &lt;typename T&gt;inline void treap&lt;T&gt;::zag(size_t &amp;p) &#123; int q = dat_[p].rChild; dat_[p].rChild = dat_[q].lChild; dat_[q].lChild = p; p = q; update(dat_[p].lChild); update(p);&#125;template &lt;typename T&gt;void treap&lt;T&gt;::insert(size_t &amp;p, T val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == dat_[p].value) &#123; dat_[p].count++; update(p); return; &#125; if (val &lt; dat_[p].value) &#123; insert(dat_[p].lChild, val); if (dat_[p].weight &lt; dat_[dat_[p].lChild].weight) zig(p); &#125; else &#123; insert(dat_[p].rChild, val); if (dat_[p].weight &lt; dat_[dat_[p].rChild].weight) zag(p); &#125; update(p);&#125;template &lt;typename T&gt;void treap&lt;T&gt;::remove(size_t &amp;p, T val) &#123; if (p == 0) return; if (val == dat_[p].value) &#123; if (dat_[p].count &gt; 1) &#123; dat_[p].count--; update(p); &#125; else if (dat_[p].lChild != 0 || dat_[p].rChild != 0) &#123; if (dat_[p].rChild == 0 || dat_[dat_[p].lChild].weight &gt; dat_[dat_[p].rChild].weight) &#123; zig(p); remove(dat_[p].rChild, val); &#125; else &#123; zag(p); remove(dat_[p].lChild, val); &#125; update(p); &#125; else p = 0; &#125; if (val &lt; dat_[p].value) remove(dat_[p].lChild, val); else remove(dat_[p].rChild, val); update(p);&#125;const int INF = 0x7f7f7f7f;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); size_t n; cin &gt;&gt; n; treap&lt;int&gt; t(n &lt;&lt; 1, INF, -INF); t.build(); int opt, x; while (n--) &#123; cin &gt;&gt; opt &gt;&gt; x; switch (opt) &#123; case 1: &#123; t.insert(x); break; &#125; case 2: &#123; t.remove(x); break; &#125; case 3: &#123; cout &lt;&lt; t.rankByVal(x) - 1 &lt;&lt; endl; break; &#125; case 4: &#123; cout &lt;&lt; t.valByRank(x + 1) &lt;&lt; endl; break; &#125; case 5: &#123; cout &lt;&lt; t.pre(x) &lt;&lt; endl; break; &#125; case 6: &#123; cout &lt;&lt; t.nxt(x) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; Manacher 算法1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public: string longestPalindrome(string s) &#123; int len = s.size(); if (len &lt;= 1) return s; string str = preProcess(s); int n = str.size(), pos = 0, MaxRight = 0; vector&lt;int&gt; RL(n, 0); for (int i = 1; i &lt; n - 1; ++i) &#123; RL[i] = MaxRight &gt; i ? min(RL[2 * pos - i], MaxRight - i) : 1; while (str[i + RL[i]] == str[i - RL[i]]) ++RL[i]; if (i + RL[i] &gt; MaxRight) &#123; MaxRight = i + RL[i]; pos = i; &#125; &#125; int maxLen = 0, index = 0; for(int i = 1; i &lt; n - 1; ++i) &#123; if(RL[i] &gt; maxLen) &#123; maxLen = RL[i]; index = i; &#125; &#125; // 这里可以和上面并在一起 return s.substr((index - maxLen) / 2, maxLen - 1); &#125; //预处理字符串，abc预处理后变成$#a#b#c#^ string preProcess(const string &amp;s) &#123; int n = s.size(); string res; res.push_back('$'); res.push_back('#'); for(int i = 0; i &lt; n; i++) &#123; res.push_back(s[i]); res.push_back('#'); &#125; res.push_back('^'); return res; &#125; // 注：此处字符串预处理在头上加入 '$' 是为了方便处理 // 如果是空间瘤患者，直接在有关的地方减一就行了&#125;; 线性筛12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1000010int fac[maxn], prime[maxn];void LinearSieve(int n) &#123; memset(fac, 0, sizeof(fac)); int m = 0; for (int i = 2; i &lt;= n; ++i) &#123; if (fac[i] == 0) &#123; fac[i] = i; prime[++m] = i; &#125; for (int j = 1; j &lt;= m; ++j) &#123; // 跳出循环的条件 if (prime[j] &gt; fac[i] || prime[j] &gt; n / i) break; fac[i * prime[j]] = prime[j]; &#125; &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; prime[i] &lt;&lt; " ";&#125;int main() &#123; int n; LinearSieve(100000); return 0;&#125; Miller-Rabin 素数测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;inline int64 rand64() &#123; return abs((int64)rand() &lt;&lt; 32 | rand()); &#125;inline int64 random(int64 x, int64 y) &#123; return x + rand64() % (y - x + 1); &#125;// 随机数生成函数int64 montgomery(int64 a, int64 b, int64 c) &#123; int64 result = 1; int64 temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;bool witness(int64 a, int64 p) &#123; int k = 0; int64 q = p - 1; while ((q &amp; 1) == 0) &#123; k++; q &gt;&gt;=1; &#125; int64 v = montgomery(a, q, p); // 判断一 if (v == 1 || v == p - 1) return false; while (k--) &#123; v = v * v % p; if (v == p - 1) return false; // 判断二 &#125; return true;&#125;bool MillerRabin(int64 p) &#123; if (p == 1) return false; if (p == 2) return true; if (p % 2 == 0) return false; // 这里其实可以加更多的特判来节约时间 for (int i = 1; i &lt;= 50; ++i) if (witness(random(1, p - 1), p)) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) if (MillerRabin(i)) cout &lt;&lt; i &lt;&lt; " "; // 输出 1 ~ n 之间的所有素数 return 0;&#125; 质因数分解12345678910111213int p[maxn], c[maxn];void divide(int n) &#123; int m = 0; for (int i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; p[++m] = i; c[m] = 0; while (n % i == 0) &#123; n /= i; c[m]++; &#125; &#125; &#125; if (n &gt; 1) &#123; p[++m] = n; c[m] = 1 &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; p[i] &lt;&lt; '^' &lt;&lt; c[i] &lt;&lt; endl;&#125; 快速幂（蒙哥马利算法）12345678910int64 Montgomery(int64 a, int64 b, int64 c) &#123; if (b == 0) return 1 % c; int64 res = 1, tmp = a; while (b &gt; 0) &#123; if (b &amp; 1) res = (res * tmp) % c; tmp = (tmp * tmp) % c; b &gt;&gt;= 1; &#125; return res;&#125; gcd &amp; lcm12int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;int lcm(int a, int b) &#123; return a * b / gcd(a, b); &#125; exgcd纯 exgcd12345678int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d;&#125; exgcd 求方程 $ax + by = c$ 中 $x$ 的最小正整数解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d;&#125;int cal(int a, int b, int c, int &amp;x, int &amp;y) &#123; int k, t; int gcd = exgcd(a, b, x, y); if (c % gcd != 0) return -1; // 方程没有整数解 x = x * c / gcd; // 从 a' * x + b' * y = gcd(a', b') // 转化为 a * x + b * y = c k = b / gcd; // 约去 gcd(a', b') if (k &lt; 0) k = -k; // 将 b 转化为正数 x = (x % k + k) % k; //if (x &lt; 0) x = x + k; // 最小非负整数解 if (x &lt;= 0) x = x + k // 最小正整数解 y = (c - a * x) / b; // 求出 y 的值 while (y &lt; 0) &#123; x = x + k; y = (c - a * x) / b; &#125; // 对 y 求非负整数解 return x;&#125;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int x, y; int tmp = cal(a, b, c, x, y); if (tmp == -1) &#123; puts("-1"); return 0; &#125; cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y; return 0;&#125; 逆元exgcd 求逆元效率贼高，时间复杂度为 $\mathcal{O}(\log n)$ 1234567891011121314int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; return a; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d;&#125;int getInverse(int n, int p) &#123; int x, y; exgcd(n, p, x, y); return (x + p) % p;&#125; 线性推逆元求 $1\sim n$ 的逆元，总时间复杂度为 $\mathcal{O}(n)$ 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;int64 inv[N];inline void getInverse(int64 n, int64 p) &#123; inv[1] = 1; for (int i = 2; i &lt;= n; ++i) inv[i] = (p - p / i) * inv[p % i] % p; &#125; 组合数杨辉三角递推求全部组合数1234567891011121314151617181920#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long int64;int64 C[1000][1000];int64 c(int n, int m) &#123; m = min(m, n - m); for (int i = 0; i &lt;= n; ++i) C[i][0] = 1; // 全赋为 1 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; return C[n][m];&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; c(n, m); return 0;&#125; 求一个组合数（滚动数组）12345678910111213141516171819#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long int64;int64 C[100010];int64 c(int n, int m) &#123; m = min(m, n - m); C[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 1; --j) C[j] = C[j] + C[j - 1]; return C[m];&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; c(n, m); return 0;&#125; 乘法逆元直接求123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;int64 exgcd(int64 a, int64 b, int64 &amp;x, int64 &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int64 d = exgcd(b, a % b, x, y); int64 t = x; x = y; y = t - a / b * y; return d;&#125;int64 getInverse(int64 n, int64 p) &#123; int64 x, y; exgcd(n, p, x, y); return (x + p) % p;&#125;int64 c(int64 n, int64 m, int64 p) &#123; int64 x = 1, y = 1; for (int64 i = n; i &gt;= n - m + 1; --i) x *= i; for (int64 i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; int64 n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; 卢卡斯定理1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;int64 exgcd(int64 a, int64 b, int64 &amp;x, int64 &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int64 d = exgcd(b, a % b, x, y); int64 t = x; x = y; y = t - a / b * y; return d;&#125;int64 getInverse(int64 n, int64 p) &#123; int64 x, y; exgcd(n, p, x, y); return (x + p) % p;&#125;int64 c(int64 n, int64 m, int64 p) &#123; if (m == 0) return 1 % p; if (n == 0) return 0; if (n &gt;= p || m &gt;= p) return c(n / p, m / p, p) * c(n % p, m % p, p) % p; int64 x = 1, y = 1; for (int64 i = n; i &gt;= n - m + 1; --i) x = x * i % p; for (int64 i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; int64 n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; 对拍程序123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; for (int T = 1; T &lt;= 10; ++T) &#123; system("random.exe"); // 数据生成程序 double st = clock(); system("sol.exe"); // 解题的程序 double ed = clock(); system("bf.exe"); // 暴力程序 if (system("diff data.out data.ans")) &#123; // diff 不能用就用 fc printf("[ Wrong Answer ]"); &#125; else &#123; printf("[ Accepted ] Testcase #%d: Time %.0lfms\n", T, ed - st); &#125; &#125; return 0;&#125; (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[浅浅浅谈] 数位 DP]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%B5%85%E6%B5%85%E6%B5%85%E8%B0%88-%E6%95%B0%E4%BD%8D-DP%2F</url>
    <content type="text"><![CDATA[“出题人是死的。”总有些出题人会闲的蛋疼来出一些像下面这样的题目：求区间 $[l,r]$ 之间满足规则 $g$ 的数有多少个。 一般解法代码如下： 1for (int i = l; i &lt;= r; ++i) if (judge(i)) cnt++; 如果每一次 judge() 的复杂度为 $\mathcal{O}(\operatorname{length}(i))$，则它的复杂度为 $\mathcal{O}\left(n\times\operatorname{length}(i)\right)$，如果再算上一堆常数（比如开个数组什么的），那 TLE 简直是轻轻松松的🤣🤣。 用数位 DP我们可以从数字的每一位来枚举，从高位向低位枚举，我们可以用 $\operatorname{dp}[i][j]$ 来表示枚举到 $i$ 位时，数字为 $j$ 时的方案数（答案数）。但是我们需要考虑一些限制我们决策的条件，假设我们要求小于等于 $243$ 的数字中符合条件的有几个： 当我们第一项为 $1$ 时，我们后面一位可以枚举 $0\sim 9$ 当我们第一项为 $2$ 时，我们后面一项就只能枚举 $0\sim 4$ 可见我们需要通过判断前一项来决定后一项最高可以取值的大小。同时我们也需要考虑一些数字前面一直是 $0$，并且会影响答案的情况（例如统计各个数字出现的次数）。以下是模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20int dp[N][N], a[N], n, m;// 数位 dp 是需要深搜的，`dp` 数组只是做记忆化搜索用int dfs(int pos, int pre, bool limit, bool frontzero) &#123; // `frontzero`: 前导 0 的判断 // `pre`: `pos` 前一位的数字 if (pos == 0) return 1; // 枚举完毕，退出 if (!frontzero &amp;&amp; !limit &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; // 返回 `dp[pos][pre]` 的条件：前导非零 且 无上限限制 且 `dp` 数组的这一位有值 // 注意这里必须把 `!frontzero` 和 `!limit` 写在前面 来防止 `dp` 数组越界 // 因为后面需要在前导零的时候做一点操作 int p, ret = 0; int up = limit ? a[pos] : 9; for (int i = 0; i &lt;= up; ++i) &#123; if () continue; // 当枚举到的这一位不符合条件时就忽略，继续枚举 p = i; if (frontzero &amp;&amp; i == 0) p = -INF; // 这里 `-INF` 只是一个前导 0 的标记，数值并没有太大意义。 ret += dfs(pos - 1, p, limit &amp; (i == up), (p == -INF)); // 这里 `p = -INF` 时也是会传进函数作为 `pre` 参数的， // 所以前面要把 `frontzero` 写前面 &#125; if (!frontzero &amp;&amp; !limit) f[pos][pre] = ret; return ret;&#125;int solve(int x) &#123; // `solve(x)`: 处理不大于 `x` 的数的答案 int idx = 0; while (x) &#123; a[++idx] = x % 10; x /= 10; &#125; // 预处理 `x` 的每一位 memset(dp, -1, sizeof(dp)); return dfs(idx, -INF, 1, 1); // 注意初始化&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; (solve(m) - solve(n - 1)); return 0;&#125; 例题HDU 2089 不要 62解决代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20int a[N], dp[N][2];// `dp[pos][0 / 1]` 表示不含 4 和 6 的情况下，剩余长度为 `pos` (也就是当前的位数)，// 首位是(1)否(0)为 6 的 时候的方案数。int dfs(int pos, int pre, int status, bool limit) &#123; if (pos == -1) return 1; if (!limit &amp;&amp; dp[pos][status] != -1) return dp[pos][status]; int up = limit ? a[pos] : 9; int ret = 0; for (int i = 0; i &lt;= up; ++i) &#123; if (pre == 6 &amp;&amp; i == 2) continue; if (i == 4) continue; // 仔细读题，这里有两个条件 ret += dfs(pos - 1, i, i == 6, limit &amp; (i == a[pos])); &#125; if (!limit) dp[pos][status] = ret; return ret;&#125;int solve(int x) &#123; int pos = 0; while (x) &#123; a[pos++] = x % 10; x /= 10; &#125; return dfs(pos - 1, -1, 0, true);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int l, r; cin &gt;&gt; l &gt;&gt; r; while ((l != 0) || (r != 0)) &#123; memset(dp, -1, sizeof(dp)); int ans = solve(r) - solve(l - 1); cout &lt;&lt; ans &lt;&lt; endl; cin &gt;&gt; l &gt;&gt; r; &#125; return 0;&#125; Windy 数​123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20#define INF 0x7f7f7f7fint a[N], dp[N][N], n, m;int dfs(int pos, int pre, bool limit, bool frontzero) &#123; if (pos == 0) return 1; if (!frontzero &amp;&amp; !limit &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; int p, ret = 0; int up = limit ? a[pos] : 9; for (int i = 0; i &lt;= up; ++i) &#123; if (abs(i - pre) &lt; 2) continue; // 判定当前枚举的位能否满足题目中的条件 p = i; if (frontzero &amp;&amp; i == 0) p = -INF; ret += dfs(pos - 1, p, limit &amp;&amp; (i == up), (p == -INF)); &#125; if (!frontzero &amp;&amp; !limit) dp[pos][pre] = ret; return ret;&#125;int solve(int x) &#123; int len = 0; while (x) &#123; a[++len] = x % 10; x /= 10; &#125; return dfs(len, -INF, 1, 1);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; memset(dp, -1, sizeof(dp)); // 初始化 cout &lt;&lt; (solve(m) - solve(n - 1)); return 0;&#125; (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂谈] 考后余生......]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%9D%82%E8%B0%88-%E8%80%83%E5%90%8E%E4%BD%99%E7%94%9F%2F</url>
    <content type="text"><![CDATA[今天初赛考完了，我感觉我已经退役了……这里来说一下这几个月来高中生活的感受。 NOIP 初赛感受一些重男轻女的家庭，生孩子的模式是，只要是女孩就一直生，生到男孩为止。然而这么做并不会让人口性别失衡，让人口性别失衡的是选择性的打胎。 以上内容和某道选择题相关。答案是 1:1。 全国青少年计算机程序设计大赛究竟何时创办？Catalan 数到底表示什么？是什么让一台只有红蓝两色球的抽奖机如此火爆？关机的手机究竟能否带进考场？负权回路与 Dijkstra 算法有什么不为人知的关系？图灵奖到底是哪方设立？四人郊游为何只有两人如约？是什么让 ＋＋cnt 陷入无意义的循环？双向链表究竟是何方神圣？小猪又为何在两家商店间因巨额消费徘徊不定？欢迎来到第二十四届 NOIp！ 以上摘自知乎 可能是因为我比较菜，考试的时候忘记了很多东西，比如康托展开 TAT。但是总体来说这次还好，没有太恶心的题，不是题目的问题，是我的问题。不管这次能不能进入复赛，初赛都让我知道了我的基础知识和很多知识的掌握是很不好的，我仍然需要去加油，去继续努力（哪怕以后并不再走信息学奥赛这条道路）。最后祝各位大佬 score++。 高中的生活感受 暑假其实就已经是我的高中的开始了，主要是因为暑期的夏令营，夏令营结束后便是我的第一次的信息奥赛集训经历的开始。以前我都是自己一个人在那边瞎学，偶尔看点 Github 上的代码来提升一下自己的“修养”。集训的开始多少是有点不适应的，就如同刚刚开始学习走路的婴儿跌跌撞撞，我也就是这个感觉。有时十几天连续着下来会让我感觉非常的不适应，以至于我会变得那么渴望出去走走。 暑假很快就过去了，补作业的时间也是转瞬即逝，一下子就开学了，开学的第一个星期，每天的作业都来得及，除了对数学老师的讲课方式以及不讲道理的为人无语外，没有什么事情是能够让我感到不开心的。我初中是当过纪律委员的，所以班级里某些班干部的行为我其实看着不是很顺眼，我努力克制自己不要妄加评论，这不关我的事，我也确实做到了，但为了发泄我的情绪，我也不得不把那些情绪泼洒到我的日记本中。有一天，妈妈给我看了初中班主任有关“反对学校过度行政化”的一条朋友圈，说的挺好，恰好那天中午又有一堆人去参加什么“学生会面试”，回到教室的人个个脸上洋溢着“自豪”的“微笑”，嘴上却是一阵吹，我不是很明白为什么他们知道那么肯定自己而否定别人。也许这种东西是我这个不想参与学校所谓行政事务的“不积极”的学生所不能理解的吧。 虚伪的真诚比魔鬼更可怕。而我在班里的很多人身上看到了魔鬼，某些人身上看到了虚伪的真诚，少数人身上看到了天使。所谓魔鬼，便是一种拜金主义，有钱人家的学生喜欢自己聚在一起同时拉拢一堆人，而排斥那些与他们所相斥的人，我不喜欢这种人，甚至厌恶，围着他们的人中不乏有嘴上一会说着“我不喜欢钱”，一会有说着“你们家有钱，真香”的人，虚伪的真诚比魔鬼更可怕，这些不是他们的原话，但是毫无疑问是他们话中的意思。天使，也就是真诚，太稀有了，有些真诚的人甚至会被错当成智障，我一开始总是看低一位同学，认为他一天到晚都在说学习的东西，生活一点趣味也没有，现在我明白他是真正的喜欢学习，我也比较喜欢和这种人待在一起。而不是和某些在课上削尖脑袋大言不惭地扯淡，在私下又看低周围的所有人，认为自己不可一世的人，恕我直言，后者就是一根啥都没有的葱。 这几个星期考试很多，既要准备 NOIP 初赛，又要对付学校文化课的考试，真的是忙，在努力协调这个关系的同时，我开始努力地尝试早上跑步，虽然这会让我有点发困，但是还是让我精神了很多，运动是真的能让一个人的面貌发生改变的。 先写这么多吧，有空以后接着写，总的来说，这一个月下来还是比较适应的，对某些不讲道理的老师我觉得还是能忍则忍比较好，不要当着她（他）的面来让所有的人体会到她（他）的无知。 (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三扇门你到底换不换？——蒙特霍尔问题！]]></title>
    <url>%2F2018%2F10%2F11%2F%E4%B8%89%E6%89%87%E9%97%A8%E4%BD%A0%E5%88%B0%E5%BA%95%E6%8D%A2%E4%B8%8D%E6%8D%A2%EF%BC%9F%E2%80%94%E2%80%94%E8%92%99%E7%89%B9%E9%9C%8D%E5%B0%94%E9%97%AE%E9%A2%98%EF%BC%81%2F</url>
    <content type="text"><![CDATA[三门问题（也称为蒙特霍尔问题），是一个经典的问题，简单概括一下就是三个门里有一个的后面由你想要的东西，你选一个门，然后打开另外两扇门中的一扇，发现那个门后面是别的，那么这时候你换不换门？ 贴一个知乎上的视频 顺便放个代码12345678910111213141516171819202122from random import uniformdef defCar(): i = int(uniform(1, 4)) return idef cpt_posb(): N = 1000000 change = 0 dischange = 0 for i in range(N): car = defCar() doors = [1, 2, 3] choice = int(uniform(1, 4)) if choice == car: dischange += 1 else: change += 1 print(change / N * 100, "%") print(dischange / N * 100, "%")if __name__ == "__main__": cpt_posb() (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 初赛] 计算机常识总结]]></title>
    <url>%2F2018%2F10%2F09%2FNOIP-%E5%88%9D%E8%B5%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[继续总结初赛内容，这次是计算机常识的总结篇。 计算机的发展史计算机发展的代别划分 代别 年代 逻辑（电子元件） 第一代 1946——1958 电子管 第二代 1959——1964 晶体管 第三代 1965——1970 集成电路 第四代 1971——Today 大规模、超大规模集成电路 第一台电子计算机1946 年 2 月，在美国宾夕法尼亚大学诞生了世界上第一台电子计算机 ENIAC (Electronic Numberical Integrator and Computer)，这台计算机占地 170 平方米，质量 30 吨，用了 18000 多个电子管，每秒能进行 5000 次加法运算（其实我并不知道这些数字有什么用） 计算机系统结构中央处理器 CPU (Central Processing Unit) 由运算器，控制器和一些寄存器组成； 运算器进行各种算术运算和逻辑运算； 控制器是计算机的指挥系统； CPU 的主要指标是主频和字长。 字长指一台计算机所能处理的二进制代码的位数，也就是 ALU (Arithmetic and Logic Unit 算术逻辑运算单元) 的宽度。字长越大，能表示的数值范围就越大，计算出的数值的有效位数就越多，字长越长，能表示的信息就越多，机器的功能也就越强。 运算速度指计算机每秒钟所能够执行的指令条数，一般用 MIPS (Million of Instructions Per Second 每秒百万条指令) 为单位。由于不同类型的指令执行时间长短不同，因此运算速度的计算方法也不相同 主频指 CPU 的时钟频率，MHz 或 GHz 为单位 各种总线 总线名称 意义 数据总线 决定了 CPU 和外界的数据传输速度 地址总线 决定了 CPU 能访问的最大内存空间的大小 控制总线 决定了对外部器件的控制能力 相关题目 (NOIP-2009-T11) 关于 CPU 下面哪些说法是正确的 ( AB )：A. CPU 全称为中央处理器（或中央处理单元）。B. CPU 能直接运行机器语言。C. CPU 最早是由 Intel 公司发明的。D. 同样主频下，32 位的 CPU 比 16 位的 CPU 运行速度快一倍。 Intel 发明的是微处理器 CPU 的位数只能说明处理的位数，由于指令不同，很难判断哪个快 (NOIP-2016-T9) 某计算机的 CPU 和内存之间的地址总线的宽度是 32 位 ( bit )，这台计算机最多可以使用 ( B ) 的内存。A. 2 GB &nbsp;&nbsp;&nbsp; B. 4 GB &nbsp;&nbsp;&nbsp; C. 8 GB &nbsp;&nbsp;&nbsp; D. 16GB 这道题中主要是要先获取地址总线的宽度（一般与 ALU 的宽度相等），地址总线寻址是按照字节（$\operatorname{Byte}$）的，所以答案就是 $2^{32} \operatorname{Byte}$，也就是 $4 \operatorname{GB}$，不用管题中给出的单位。 存储器主存储器主存储器（也称为内存储器），属于主机的一部分。 RAM 随机存储器：随机指随时读出和写入 ROM 只读存储器：例如 BIOS (Basic Input Output System) 就是固定在主板 ROM 上的一个软件 Cache：在 CPU 和内存之间设置的一级或两级的告诉小容量存储器，称为高速缓存存储器。 辅助存储器辅助存储器（也称为外存储器），属于外部设备。 软盘存储器 硬盘存储器 闪存：存储速度介于软盘和硬盘之间的一种外部存储器 光盘：分为只读光盘，一次写入型光盘和可擦写光盘 寄存器CPU 的内部存储单位，存取速度最快。 速度存储器访问速度：寄存器 &gt; Cache &gt; 内存 &gt; 外存 相关题目 (NOIP-2010-T8) 主存储器的存取速度比中央处理器(CPU)的工作速度慢的多，从而使得后者的效率受到影响。而根据局部性原理，CPU所访问的存储单元通常都趋于一个较小的连续区域中。于是，为了提高系统整体的执行效率，在CPU中引入了( B )。A．寄存器 &nbsp;&nbsp;&nbsp; B．高速缓存 &nbsp;&nbsp;&nbsp; C．闪存 &nbsp;&nbsp;&nbsp; D．外存 (NOIP-2011-T4) 4．寄存器是（ D ）的重要组成部分。A. 硬盘 &nbsp;&nbsp;&nbsp; B. 高速缓存 &nbsp;&nbsp;&nbsp; C. 内存 &nbsp;&nbsp;&nbsp; D. 中央处理器（CPU） 有关人物冯 · 诺依曼1944 年，美籍匈牙利数学家冯 · 诺伊曼提出了计算机的基本结构和工作方式的设想，为计算机的发展和诞生提供了理论基础。当今世界的计算机大部分仍属于冯 · 诺伊曼结构。他的理论要点如下： 计算机硬件设备由存储器、运算器、控制器、输入设备和输出设备 5 部分组成。 存储程序思想——把计算过程描述为由许多命令按一定顺序组成的程序，然后把程序和数据一起输入计算机，计算机对已存入的程序和数据处理后，输出结果。 冯 · 诺依曼还设计出第一台具有存储程序功能的计算机 EDVAC (Electronic Discrete Variable Automatic Computer 离散变量自动电子计算机) 图灵（1912.6.23 —— 1954.6.7）艾伦 · 图灵：1913 年，图灵进入剑桥大学国王学院，毕业后到美国普林斯顿大学攻读博士学位，二战爆发后回到剑桥，后曾协助军方破解德国著名密码系统 Enigma，帮助盟军取得了二战胜利。图灵提出的图灵机模型为现代计算机的逻辑工作方式奠定了基础。图灵也是计算机科学理论基础第一人。 Ada Lovelace这个人考试中最多考一下她是世界上第一个给计算机写程序的人，曾对现代计算机技术之父查尔斯 · 巴贝奇的笔记手稿进行了整理和修正。同时在 1980 年 12 月 10 日，美国国防部制作了一个新的计算器编程语言 Ada。如果想要更深入地了解这个人点这里。 克劳德 · 香农（1916.4.30 —— 2001.2.26）克劳德 · 艾尔伍德 · 香农（Claude Elwood Shannon），美国数学家、电子工程师和密码学家，被誉为信息论的创始人。是密歇根大学学士，麻省理工学院博士。1948 年，他将热力学中的熵的概念引入信息通信领域，标志着信息论研究的开端。 (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 初赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 初赛] 总结 (POJ1664)]]></title>
    <url>%2F2018%2F10%2F08%2FNOIP-%E5%88%9D%E8%B5%9B-%E6%80%BB%E7%BB%93-%E8%8B%B9%E6%9E%9C%E6%94%BE%E7%9B%98%E5%AD%90%E9%97%AE%E9%A2%98-POJ1664%2F</url>
    <content type="text"><![CDATA[初赛模拟测试错了一道简单题，似乎还是一道陈年老题，网上去查了一下，似乎还和 POJ 1663 这道水题一模一样，这里总结一下 题目大意：有 $m$ 个一模一样的苹果放入 $n$ 个一模一样的盘子中，求放法的数量 $k$。注意：对于 $m=7,n=3$ 这组数据：$5,1,1$ 和 $1,5,1$ 是一样的。 思路我们来分类讨论，令 $\operatorname{f}(m,n)$ 表示放法的数量 $k$， $m&lt; n$，此时我们把多余的盘子拿掉，$\operatorname{f}(m,n)=\operatorname{f}(m,m)$ $m\geqslant n$，此时我们再分两类来讨论：有盘子空着和没有盘子空着。有盘子空着时，$\operatorname{f}(m,n)=\operatorname{f}(m,n-1)$；没有盘子空着时，$\operatorname{f}(m,n)=\operatorname{f}(m-n,n)$于是我们得出 $\operatorname{f}(m, n)$ 的表达式： $$\operatorname{f}(m,n)=\begin{cases}1 &amp; \text{when $m=0$ or $n=1$} \\\operatorname{f}(m,m) &amp; \text{when $m&lt; n$} \\\operatorname{f}(m,n-1)+\operatorname{f}(m-n,n) &amp; \text{otherwise}\end{cases}$$ 所以我们就可以写出 POJ 1664 的代码了123456789101112131415161718#include &lt;iostream&gt;using namespace std;int f(int m, int n) &#123; if (m == 0 || n == 1) return 1; if (m &lt; n) return f(m, m); else return f(m, n - 1) + f(m - n, n);&#125;int main() &#123; int m, n, t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; m &gt;&gt; n; cout &lt;&lt; f(m, n); &#125; return 0;&#125; 至于初赛中的那道题嘛，手动打表就可以了，应该还挺快的（似乎还可以直接暴力枚举……）。 (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 初赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 记录一道玄学的题目]]></title>
    <url>%2F2018%2F10%2F05%2FNOIP-%E6%A8%A1%E6%8B%9F-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E7%8E%84%E5%AD%A6%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[今天的第二道题实在是坑，考场上暴力都不能一次打对，最后订正的时候还 WA 了 20 多次，简直太坑了啊！！😭😭😭😭 题目大意给出一个长度为 $n$ 数列，和 $m$ 次询问，每次求出一个区间 $[l,r]$ 的和然后将该区间的所有数变为原来的平方然后模上 $c=2305843008676823040$ 题解这道题给我的第一个感觉就是：这个模数太灵魂了，这么长而且还不是个质数（$c = 2^{29}\times 3\times 5\times 17\times 257\times 65537$）。于是打了个表，发现一个数平方了几十次之后就是一个定值了，所以可以考虑优化暴力以及优化区间查询和修改，所以就自然而然的想到了线段树（当然了，似乎纯暴力修改或者分块什么的……） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 70000#define modn 2305843008676823040typedef unsigned long long uint64;// 数据太大了，开个 unsigned long long 防止爆（似乎 long long 就可以了）struct segmentTreeNode &#123; int l, r; uint64 sum; bool flag; &#125;;// 裸线段树segmentTreeNode t[maxn * 4];int n, m, x, y;uint64 a[maxn];#define l(x) t[x].l#define r(x) t[x].r#define sum(x) t[x].sum#define flag(x) t[x].flaginline uint64 mul(uint64 a, uint64 b) &#123; uint64 ans = 0; while (b &gt; 0) &#123; if (b &amp; 1) ans = (ans + a) % modn; a = (a + a) % modn; b &gt;&gt;= 1; &#125; return ans;&#125; // 快速乘，防爆装备inline void build(int p, int l, int r) &#123; l(p) = l; r(p) = r; flag(p) = false; if (l == r) &#123; sum(p) = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); sum(p) %= modn; // 别忘记模！！！ flag(p) = flag(p * 2) &amp;&amp; flag(p * 2 + 1); // 玄学更新&#125;inline uint64 query(int p, int l, int r) &#123; if (l &lt;= l(p) &amp;&amp; r(p) &lt;= r) return sum(p); int mid = (l(p) + r(p)) &gt;&gt; 1; uint64 val = 0; if (l &lt;= mid) (val += query(p * 2, l, r)) %= modn; if (r &gt; mid) (val += query(p * 2 + 1, l, r)) %= modn; return val;&#125;inline void update(int p, int l, int r) &#123; if (flag(p)) return; if (l(p) == r(p)) &#123; uint64 tmp = mul(sum(p), sum(p)); if (tmp == sum(p)) flag(p) = true; sum(p) = tmp; return; &#125; int mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) update(p * 2, l, r); if (r &gt; mid) update(p * 2 + 1, l, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); sum(p) %= modn; // 别忘记模！！！ flag(p) = flag(p * 2) &amp;&amp; flag(p * 2 + 1);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; update(1, x, y); &#125; return 0;&#125; 嗯，接下来证明一下为什么会变成一个定值。因为：$$c = 2305843008676823040 = 2^{29}\times 3\times 5\times 17\times 257\times 65537$$所以我们可以知道：$$\varphi(c)=2^{28}\times 2\times 4\times 256\times 65536=2^{59}$$然后我们来分类讨论对于一个数 $x$，如果 $\gcd(x, c)=1$，那么根据费马-欧拉定理：$$x^{\varphi(c)}\equiv 1\pmod c$$所以 $x^{59}$ 之后它就是 $1$ 了。如果 $\gcd(x, c)\neq 1$： 如果 $x=c$，那么显然，$x$ 会变成一个定值 如果 $x\neq c$，那么我们一定可以从 $c$ 中分离出一个 $c’$ 使得 $\gcd(x,c’)=1$，而 $\varphi(c’)&lt;59$，所以 $x$ 在 $59$ 次方前就可以变成一个定值。 证毕，太妙了！ (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
        <tag>线段树</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心态调崩：一道暴力 AC 的题]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%BF%83%E6%80%81%E8%B0%83%E5%B4%A9%EF%BC%9A%E4%B8%80%E9%81%93%E6%9A%B4%E5%8A%9B-AC-%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天有是令人愉悦的国庆七连测，第一道题整整卡了我两个小时！！都没时间去思考第三道题😭😭。然而做出来了之后却发现是如此的弱智。。。 题目大意你有一个图，你从最左下角的点开始，可以向上或向下走 不大于 $h$ 的单位到另一个 #，或者在同一层相连的 #，求能走到终点 $(x,y)$ 的 $h$ 的最小值。 输入/输出[样例输入] 5 8 ####____ ___#_### ###__#__ ______#_ ######## 2 4 [样例输出] 2 题解嗯……这道题可以直接 BFS 模拟然后每次找 $h$ 的时候二分答案就可以过了。考试的时候我是用最小生成树做的，因为最小生成树有一个性质：最短的边一定会被包含在 MST 中，这也是 Kruskal 算法的原理。所以我们在做 Kruskal 的时候就可以用并查集来判断一下最左下角的点和目标点是否已经连通，如果连通就可以跳出了也就是这个地方让我思考了一年，一开始还在想怎么在做完 Kruskal 之后搜索路径…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1010struct edgeNode &#123; int vertexTo; int vertexFrom; int edgeNext; int weight;&#125;;// 这个地方其实不需要前向星，一开始想错了才打成这个char ch;edgeNode edges[maxn * maxn * 2];int heads[maxn * maxn* 2], numEdges = 0, fa[maxn * maxn], ans = 0;bool dat[maxn][maxn];int n, m, x, y;inline void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].vertexFrom = vertex1; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;inline void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125;inline bool operator&lt;(edgeNode&amp; a, edgeNode&amp; b) &#123; return a.weight &lt; b.weight;&#125;inline int get(int x) &#123; return fa[x] == x ? x : (fa[x] = get(fa[x]));&#125;inline int change(int x, int y) &#123; return (x - 1) * m + y;&#125; // 点的有序数对转序号inline void kruskal() &#123; for (int i = 1; i &lt;= numEdges; ++i) &#123; int u = get(edges[i].vertexFrom); int v = get(edges[i].vertexTo); if (u == v) continue; fa[u] = v; ans = max(ans, edges[i].weight); if (get(change(x, y)) == get(change(n, 1))) break; // 弹出 &#125;&#125;int main() &#123; ifstream in("mario.in"); ofstream out("mario.out"); // 懒得打快读 QAQ in &gt;&gt; n &gt;&gt; m; memset(dat, false, sizeof(dat)); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; in &gt;&gt; ch; dat[i][j] |= (ch == '#'); &#125; &#125; in &gt;&gt; x &gt;&gt; y; //////////////////////////////////////////// memset(heads, -1, sizeof(heads)); for (int i = 1; i &lt;= m; ++i) &#123; int k = 1; while (!dat[k][i]) k++; for (int j = k + 1; j &lt;= n; ++j) &#123; if (dat[j][i]) &#123; addDuplexEdge(change(k, i), change(j, i), j - k); k = j; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (!dat[i][j]) continue; else if (!dat[i][j + 1]) continue; else addDuplexEdge(change(i, j), change(i, j + 1), 0); &#125; &#125; //////////////////////////////////////////// /////////////////// 加边 /////////////////// //////////////////////////////////////////// for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; fa[change(i, j)] = change(i, j); &#125; &#125; sort(edges + 1, edges + numEdges + 1); kruskal(); out &lt;&lt; ans; return 0;&#125; (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猴排！？一道高考题！？出题人的无下限猴子专场!]]></title>
    <url>%2F2018%2F10%2F03%2F%E7%8C%B4%E6%8E%92%EF%BC%81%EF%BC%9F%E4%B8%80%E9%81%93%E9%AB%98%E8%80%83%E9%A2%98%EF%BC%81%EF%BC%9F%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E6%97%A0%E4%B8%8B%E9%99%90%E7%8C%B4%E5%AD%90%E4%B8%93%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[今天模拟测的第一道题实在是妙，本以为是简单排序，但是发现某些数据下过不了，后来想打暴力，但是怕直接被 T 掉，于是使用了全世界最好的猴子排序，骗了个 35 分。。。。。。 题目描述Coder Jun 当年没有经历高考就直接保送进了名牌大学，如今孩子都上初中了，想想保送政策已经取消，孩子过几年铁定要参加高考，心里非常着急，于是决定抽空做些高考题，好给孩子传授传授经验。于是他遇到了这样一道高考题。题目给你了 $N$ 个二元组，其中第i个二元组表示为 $(A_i,B_i)$。使用这个二元组，我们可以构造出另一个序列 $T$，构造方法如下： 当 $i=1$ 时，$T_i=A_i+B_i$ 当 $i\neq 1$ 时，$T_i=B_i+\max\lbrace T_{i-1},\sum_{j=1}^i A_j\rbrace$ 由于计算T时需要用到 max 函数令 Coder Jun 感到非常不爽，所以 Coder Jun 想让你帮他来最小化 $T_N$ 的值，即你需要对这 $N$ 个二元组进行重排，使得 $T_N$ 的值最小。 题解骗分算法嗯，反正题目中说的就是重排，而我又不知道怎么排，那当然就是猴排了…… 35分骗分代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010typedef long long int64;struct Tuple &#123; int A; int B; &#125;;int N;Tuple tuple[maxn];// 这个 tuple 在某些地方好像会编译出错......map&lt;string, int64&gt; mp;int64 ans = (1 &lt;&lt; 30), prefix[maxn];string sit;inline void prepare() &#123; prefix[1] = tuple[1].A; for (int i = 2; i &lt;= N; ++i) prefix[i] = prefix[i - 1] + tuple[i].A;&#125;inline int64 calc() &#123; int64 T_i_1, T_i; for (int i = 1; i &lt;= N; ++i) &#123; if (i == 1) &#123; T_i = tuple[i].A + tuple[i].B; T_i_1 = T_i; &#125; else &#123; T_i = tuple[i].B + max(T_i_1, prefix[i]); T_i_1 = T_i; &#125; &#125; return T_i;&#125;inline string hash() &#123; ostringstream ret; for (int i = 1; i &lt;= N; ++i) ret &lt;&lt; tuple[i].A &lt;&lt; " " &lt;&lt; tuple[i].B &lt;&lt; endl; return ret.str();&#125;int main() &#123; ifstream in("gaokao.in"); ofstream out("gaokao.out"); srand((unsigned)time(NULL)); in &gt;&gt; N; for (int i = 1; i &lt;= N; ++i) &#123; in &gt;&gt; tuple[i].A &gt;&gt; tuple[i].B; &#125; for (int i = 1; i &lt;= 10000000; ++i) &#123; if (clock() &gt;= 600) break; prepare(); mp[hash()] = calc(); if (clock() &gt;= 600) break; random_shuffle(tuple + 1, tuple + N + 1); if (clock() &gt;= 600) break; // 骗分精髓之处，极限卡时 &#125; map&lt;string, int64&gt;::iterator iter; for (iter = mp.begin(); iter != mp.end(); ++iter) if (ans &gt; iter-&gt;second) &#123; ans = iter-&gt;second; sit = iter-&gt;first; &#125; out &lt;&lt; ans &lt;&lt; endl &lt;&lt; sit; return 0;&#125; 这个代码看看开心一下就好，虽然说对于某些数据是可能对的，但是还是要看人品。 正解先双手送上洛谷上的原题👍。首先，我们来了解一下偏序关系这个东西，我们其实只要明白严格偏序和非严格偏序的性质就行了（主要是传递性这个东西）。然后我们就可以开始求解这道题了。这道题无非就是找出一个排序方法来令所有的情况下的结果最小或最大。因为我们有公式： $$T_i=\begin{cases}A_i+B_i &amp; \text{when $i=1$} \\B_i+\max\lbrace T_{i-1},\sum_{j=1}^i A_j\rbrace &amp; \text{when $i\neq1$}\end{cases}$$ 所以 $T_i\geqslant T_{i-1}$ 是严格递增的。然后我们用相邻交换法来考虑偏序关系（排序的方法）。对于某两个元组 $(A_i,B_i)$ 和 $(A_{i+1}, B_{i+1})$，如果我们不交换，那么： $$\begin{aligned}\max\lbrace T_i, T_{i+1}\rbrace = {}&amp; T_{i+1} {} \\= {}&amp; B_{i+1}+\max\lbrace T_{i},\sum_{j=1}^{i+1}A_j\rbrace {} \\= {}&amp; B_{i+1}+\max\lbrace B_i+\max\lbrace T_{i-1},\sum_{j=1}^i A_j\rbrace,\sum_{j=1}^{i+1}A_j\rbrace\end{aligned}$$ 我们令 $S=\sum_{j=1}^{i-1}A_j$，那么上式可以表示为： $$\max\lbrace T_i,T_{i+1}\rbrace=B_{i+1}+\max\lbrace B_i+\max\lbrace T_{i-1},S+A_i\rbrace,S+A_i+A_{i+1}\rbrace$$ 即： $$\max\lbrace T_i,T_{i+1}\rbrace=\max\lbrace \left(T_{i-1}+B_i+B_{i+1}\right),\left(S+A_i+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_{i+1}\right)\rbrace$$ 如果这两个元组交换，那么 $\max\lbrace T_i,T_{i+1}\rbrace=T_i$，即： $$\begin{aligned}\max\lbrace T_i,T_{i+1}\rbrace=\max\lbrace \left(T_{i-1}+B_i+B_{i+1}\right),\left(S+A_{i+1}+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_i\right)\rbrace\end{aligned}$$ 我们不妨设不交换更优，那么我们可以得到： $$\begin{aligned}{}&amp; \max\lbrace \left(T_{i-1}+B_i+B_{i+1}\right),\left(S+A_i+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_{i+1}\right)\rbrace\leqslant {} \\{}&amp; \max\lbrace \left(T_{i-1}+B_i+B_{i+1}\right),\left(S+A_{i+1}+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_i\right)\rbrace\end{aligned}$$ 所以我们现在就需要思考如何删去 $\left(T_{i-1}+B_i+B_{i+1}\right)$ 这一项了。考虑对于一个不等式 $\max\lbrace a,c\rbrace\leqslant\max\lbrace b,c\rbrace$，如果我们删去 $c$，那么就变成了 $a\leqslant c$，如果这个不等式成立，那么我们不用管，如果不成立，我们就可以进行交换，于是，我们判断更优条件就变成了 $$\begin{aligned}{}&amp; \max\lbrace \left(S+A_i+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_{i+1}\right)\rbrace\leqslant {} \\{}&amp; \max\lbrace \left(S+A_{i+1}+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_i\right)\rbrace\end{aligned}$$ 两边消去 $S$： $$\begin{aligned}{}&amp; \max\lbrace \left(A_i+B_i+B_{i+1}\right),\left(A_i+A_{i+1}+B_{i+1}\right)\rbrace\leqslant {} \\{}&amp; \max\lbrace \left(A_{i+1}+B_i+B_{i+1}\right),\left(A_i+A_{i+1}+B_i\right)\rbrace\end{aligned}$$ 化简得： $$\max\lbrace A_{i+1},B_i\rbrace+A_i+B_{i+1}\leqslant\max\lbrace A_i,B_{i+1}\rbrace+A_{i+1}+B_i$$ 移项： $$\max\lbrace A_{i+1},B_i\rbrace-A_{i+1}-B_i\leqslant\max\lbrace A_i,B_{i+1}\rbrace-A_i-B_{i+1}$$ 我们可以发现，两边式子中大的数被删去了，留下的是小的数的相反数，所以，我们了可以得到： $$-\min\lbrace A_{i+1},B_i\rbrace\leqslant -\min\lbrace A_i, B_{i+1}\rbrace$$ 即： $$\min\lbrace A_i, B_{i+1}\rbrace\leqslant\min\lbrace A_{i+1},B_i\rbrace$$ 这也就是我们判断更优的条件了，但是细细一想，发现不对，这个式子不满足偏序的传递性啊！举个例子： 7 3 1 1 1 6 显然，这样可以是排完序后的结果，因为两两之间用条件判断都是等于。这样算出来答案是 $17$。而如果这样排： 1 1 1 6 7 3 答案是 $12$，显然这样更优。所以这个偏序关系并不能得出最优解。 我们从 $A, B$ 的大小关系来分三组考虑： $A_i&lt;B_i,A_{i+1}&lt;B_{i+1}$ 时，$A_i\leqslant A_{i+1}$，按照 $A$ 升序排序 $A_i=B_i,A_{i+1}=B_{i+1}$ 时，随便这么排都可以 $A_i&gt;B_i,A_{i+1}&gt;B_{i+1}$ 时，$B_i\geqslant B_{i+1}$，按照 $B$ 来降序排序 接下来思考这三组如何排序： $1$ 组和 $2$ 组，$1$ 组在 $2$ 组前肯定能保证满足条件。 $2$ 组和 $3$ 组，$2$ 组在 $3$ 组前面肯定能保证满足条件。 那么 $1$ 组在前，$2$ 组在中，$3$ 组在后，是肯定能保证满足要求的。 我们令 $C_i=\operatorname{sgn}(A_i - B_i)$，则对于 $1$ 组 $C=-1$，对于 $2$ 组 $C=0$，对于第三组 $C=1$，所以最终的排序方法是：先按 $C$ 值排序；然后若 $C$ 值小于等于 $0$，按 $A$ 升序排序（这里把 $2$ 组归入 $1$ 组）；若 $C$ 值大于 $0$，则按 $B$ 降序排序。 正确代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 20010typedef long long int64;struct TU &#123; int64 A, B, C; &#125;;int64 N, p[maxn];TU t[maxn];inline bool cmp(TU a, TU b) &#123; if (a.C != b.C) return a.C &lt; b.C; if (a.C &lt;= 0) return a.A &lt; b.A; return a.B &gt; b.B;&#125;int main() &#123; freopen("gaokao.in", "r", stdin); freopen("gaokao.out", "w", stdout); scanf("%lld", &amp;N); for (int64 i = 1; i &lt;= N; ++i) &#123; scanf("%lld%lld", &amp;t[i].A, &amp;t[i].B); if (t[i].A &gt; t[i].B) t[i].C = 1; else if (t[i].A &lt; t[i].B) t[i].C = -1; else t[i].C = 0; &#125; sort(t + 1, t + N + 1, cmp); p[1] = t[1].A; int64 Ti1, Ti; for (int64 i = 2; i &lt;= N; ++i) p[i] = p[i - 1] + t[i].A; for (int64 i = 1; i &lt;= N; ++i) &#123; if (i == 1) &#123; Ti = t[i].A + t[i].B; Ti1 = Ti; &#125; else &#123; Ti = t[i].B + max(Ti1, p[i]); Ti1 = Ti; &#125; &#125; printf("%lld\n", T_i); for (int64 i = 1; i &lt;= N; ++i) printf("%lld %lld\n", t[i].A, t[i].B); return 0;&#125; (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 一次出卷老师把题目出反的模拟赛]]></title>
    <url>%2F2018%2F10%2F01%2FNOIP-%E6%A8%A1%E6%8B%9F-%E4%B8%80%E6%AC%A1%E5%87%BA%E5%8D%B7%E8%80%81%E5%B8%88%E6%8A%8A%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%8D%E7%9A%84%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[在这里先祝祖国母亲生日快乐，以及成为世界上存在时间最长的社会主义国家！😊😊。 好了，说今天这套题目，隶属于国庆七连测😭，第一道题最恶心，第二题最难想，第三道题最简单。 T1 bread题目N 个数，M 次操作，给出两个参数 p, q，第i次染色将区间 (i * p + q) % N + 1 和 (i * q + p) % N + 1 之间的数变为 i（后面的操作将前面的覆盖） 输入 M, N, p, q 输出每个数的最终数字 100% 数据 n &lt;= 1e6, m &lt;= 1e7 m * p + q, m * q + p 在 int 范围内 题解一开始看到这道题是懵逼的，先打了一波暴力模拟，最大的数据跑一年都跑不出来，于是开始思考更好的算法，后来在某大佬的提示下，想到了并查集的做法。先打表，发现在 $M &gt; N$ 时，区间是会有循环的，并且是 $N$ 次一循环，而这道题中最后某个点的颜色是以最后一次染色为准的，所以只要对 $\max\lbrace M - N + 1, 1\rbrace$ 到 $M$ 这几次操作进行运算即可。但是发现这样还是会超时，因为区间是会有重复的，这会造成冗余的复杂度，所以需要考虑如何将这些运算去掉。考虑倒序进行处理，当我们对区间 $[l, r]$ 进行处理时，对于我们遇到的每一个点 $k$ 有两种情况： $k$ 未被更新过。 $k$ 已经被更新过了，那么上次更新时它所在区间的所有的点也都被更新过了。 从 $r$ 向前到 $l$ 进行更新，我们记录点 $k$ 上次更新时的左边界 $l’$，若 $k$ 被更新过，那么直接跳到 $l’-1$ 再继续向前更新。那为什么要用并查集呢？因为若 $l’-1$ 也被更新过了，就可以直接跳到更前面，进一步减少冗余运算，同时也防止数据卡我们。 贴上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline void read(int &amp;x) &#123; x = 0; static char ch = 0; static bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125;struct PAINT &#123; int l, r; &#125;;#define maxm 10000010#define maxn 1000010int N, M, p, q, ans[maxn], fa[maxn];bool painted[maxn];PAINT paint[maxm];inline int get(int x) &#123; if (fa[x] == x) return x; return fa[x] = get(fa[x]); // 这里交的时候打成了 fa[x] == get(fa[x]) TAT // 然而只 WA 了一个点 orz&#125;int main() &#123; freopen("bread.in", "r", stdin); freopen("bread.out", "w", stdout); read(N); read(M); read(p); read(q); memset(ans, 0, sizeof(ans)); for (int i = 1; i &lt;= N; ++i) fa[i] = i; int low = max(M - N + 1, 1); for (int i = M; i &gt;= low; --i) &#123; int l = min((i * p + q) % N + 1, (i * q + p) % N + 1); int r = max((i * p + q) % N + 1, (i * q + p) % N + 1); paint[i].l = l; paint[i].r = r; &#125; // 防止区间出错，因为又可能出现 l &gt; r 的情况。 for (int i = M; i &gt;= low; --i) &#123; int l = paint[i].l; int r = paint[i].r; int j = r; while (j &gt;= l) &#123; if (ans[j] == 0) &#123; ans[j] = i; fa[j] = get(l); j--; &#125; else &#123; j = fa[j] - 1; &#125; &#125; &#125; for (int i = 1; i &lt;= N; ++i) &#123; write(ans[i]); puts(""); &#125; return 0;&#125; T2 divide题目你有 n1 个 1，n2 个 2, n3 个 3, n4 个 4, n5 个 5, n6 个 6，问能否将他们分成两部分使得两部分的和相等 输入 第一行一个整数n，之后n行每行六个整数n1, n2, n3, n4, n5, n6 输出 如果可以输出 &quot;Can be divided.&quot;，不行输出 &quot;Can&apos;t be divided.&quot; 题解这道题老师来说了下 $n$ 最大有 $5000$，于是坚信了这道题是数论题 TAT。所以思考的角度完全错误，直接爆零。比赛结束后知道了应该用背包做，但是裸的多重背包会 TLE，更何况有 $5000$ 的数据，所以去阅读了标程，发现了原来正解是一个很神奇的 dp。 首先我们令 $f[i][j]$ 表示当总和为 $j$ 时，$i$ 这个数还可以使用的个数，$a[i]$ 表示 $i$ 这个数可以使用的总个数，于是我们有动态规划方程如下： $$f[i][j] =\begin{cases}a[i], &amp; \text{when $f[i - 1][j]\geqslant 0$} \\f[i][j - i] - 1, &amp; \text{when $j\geqslant i$ and $f[i - 1][j]\leqslant 0$} \\-1, &amp; \text{otherwise}\end{cases}\\\text{There is a solution only when $f[6][\frac{\sum_{i = 1}^6 a[i]\times i}{2}] \geqslant 0$}$$ 然后发现数组 f 其实只需要一维就够了，而且 $j$ 也只需要枚举到 $\frac{\sum_{i = 1}^6 a[i]\times i}{2}$ 就行了，所以实现的时候只要这样子就行了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline void read(int &amp;x) &#123; x = 0; static char ch = 0; static bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125;#define maxn 20010// 这个 maxn 不能省int n, a[10], sum, f[maxn];int main() &#123; read(n); while (n--) &#123; sum = 0; for (int i = 1; i &lt;= 6; ++i) &#123; read(a[i]); sum += a[i] * i; &#125; if (sum &amp; 1) &#123; puts("Can't be divided."); continue; &#125; sum &gt;&gt;= 1; memset(f, -1, sizeof(f)); f[0] = 0; for (int i = 1; i &lt;= 6; ++i) &#123; for (int j = 0; j &lt;= sum; ++j) &#123; if (f[j] &gt;= 0) f[j] = a[i]; else if (i &lt;= j) f[j] = f[j - i] - 1; else f[j] = -1; &#125; &#125; if (f[sum] &gt;= 0) puts("Can be divided."); else puts("Can't be divided."); &#125; return 0;&#125; T3 cmi题目有一全排列，每次移动一个数，求使其变为升序的最少移动次数 输入 两行，第一行为排列中数字的数量，第二行为排列 输出 一行，最少移动的次数 题解就是最长上升子序列（LIS），中间再加一点优化（可以二分，也可以直接用 lower_bound() 函数） 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;inline void read(int &amp;x) &#123; x = 0; static char ch = 0; static bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125;#define maxn 200010int n, a[maxn], f[maxn], ans;int main() &#123; freopen("cmi.in", "r", stdin); freopen("cmi.out", "w", stdout); read(n); read(a[1]); ans = 1; f[1] = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; read(a[i]); if (a[i] &gt; f[ans]) &#123; ans++; f[ans] = a[i]; &#125; else &#123; int pos = lower_bound(f + 1, f + ans + 1, a[i]) - f; f[pos] = a[i]; &#125; &#125; write(n - ans); return 0;&#125; 总结今天的题目做完后真的是感觉出卷老师出反了，以后还是得先浏览一遍题目 orz。 (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 初赛] 各类排序算法时间/空间复杂度整理]]></title>
    <url>%2F2018%2F09%2F28%2FNOIP-%E5%88%9D%E8%B5%9B-%E5%90%84%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[排序算法在初赛中似乎每次都会考到，而且考到的不外乎它们的时间复杂度和空间复杂度，所以此处进行一次整理。 时间复杂度 算法名称 平均时间复杂度 最好时间复杂度 最坏时间复杂度 稳定性 桶排序 $\mathcal{O}(n)$ $\mathcal{O}(n)$ $\mathcal{O}(n)$ 不稳定 基数排序 $\mathcal{O}(n)$ $\mathcal{O}(n)$ $\mathcal{O}(n)$ 稳定 归并排序 $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ 稳定 快速排序 $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ $\mathcal{O}(n^2)$ 不稳定 选择排序 $\mathcal{O}(n^2)$ $\mathcal{O}(n)$ $\mathcal{O}(n)$ 不稳定 插入排序 $\mathcal{O}(n^2)$ $\mathcal{O}(n)$ $\mathcal{O}(n^2)$ 稳定 希尔排序 见维基百科 见维基百科 见维基百科 不稳定 堆排序 $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ 不稳定 冒泡排序 $\mathcal{O}(n^2)$ $\mathcal{O}(n^2)$ $\mathcal{O}(n^2)$ 稳定 注：《算法》的作者曾经说过，所有的不稳定算法都可以用额外空间变成稳定的，所以这里的整理只能用于 NOIP 初赛 空间复杂度冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为 $\mathcal{O}(1)$，因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)快速排序空间复杂度为 $\mathcal{O}(\log n)$ （因为递归调用了），归并排序空间复杂是 $\mathcal{O}(n)$，需要一个大小为n的临时数组.基数排序的空间复杂是 $\mathcal{O}(n)$，桶排序的空间复杂度不确定。]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 初赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEXO] hexo 中加入 AdSense 广告服务的方法]]></title>
    <url>%2F2018%2F09%2F25%2FHEXO-hexo-%E4%B8%AD%E5%8A%A0%E5%85%A5-AdSense-%E5%B9%BF%E5%91%8A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[就在昨天！我的 AdSense 申请终于过了！这里来总结一下 hexo 上 AdSense 通过的经验。 注册 AdSense 账号这个不多说了，直接去这里 更改自己 hexo 主题文件此处以 NexT 主题为例（注：可能不是最简方式，自行斟酌）： 新建 theme/next/layout/_custom/google_adsense.swig，将 AdSense 上的代码粘贴进去 在 theme/next/layout/_custom/head.swig 中也粘贴一份 如果在每篇博客里也想看到广告的话，在 theme/next/layout/post.swig 里中在希望看到的地方加上: 1&#123;% include &apos;_custom/google_adsense.swig&apos; %&#125; 例如：在 &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &lt;/div&gt; 中间插入，总代码如下： 123456&#123;% block content %&#125; &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;&#123; post_template.render(page) &#125;&#125; &#123;% include &apos;_custom/google_adsense.swig&apos; %&#125; &lt;/div&gt;&#123;% endblock %&#125; 此时如果 hexo server 的话是看不到广告的，因为 AdSense 的显示是 Google 控制的。 疯狂更新博客你需要使你的网站内容充足以通过 AdSense 的审核（我写了 21 篇左右才通过，其实算上所有网页其实还不止），如果被拒绝了，就再重新申请一次，说不定就过了🤣。 总结使用 AdSense 来赚外块，美滋滋~~]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++ 奇技淫巧] 终极快速读入/输出]]></title>
    <url>%2F2018%2F09%2F22%2FC-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E7%BB%88%E6%9E%81%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5-%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[上次看到一个手写 getchar() 的大神，发现自己的快速读入还是不够骚，于是去查了下网络，发现了更加厉害的快读方式。顺便把自己的快输用非递归优化了一下。 手写 getchar()12345inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125; // 使用 fread() 来提高速度 快读使用 nextchar()1234567891011inline void read(int&amp; x) &#123; x = 0; static char ch = 0; static bool sign = false; // 使用 static 节省空间 while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; // 这里 x * 10 和 (x &lt;&lt; 1) + (x &lt;&lt; 3) 编译后的代码是一样的 // 所以不需要用位运算了 x = sign ? -x : x;&#125; 非递归 write()1234567inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) &#123; putchar(stk[top--] + '0'); &#125;&#125; 速度测试数据生成12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ofstream test("testdata.txt"); srand((unsigned)time(NULL) * 19260817); // +1s for (int i = 1; i &lt;= 5000000; ++i) test &lt;&lt; rand() &lt;&lt; " "; return 0;&#125; // 祖传代码 老版本测试12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;inline void read(int&amp; x) &#123; x = 0; char ch = 0; bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int main() &#123; freopen("testdata.txt", "r", stdin); freopen("output.txt", "w", stdout); int array[1000000]; auto start = system_clock::now(); for (int i = 1; i &lt;= 1000000; ++i) read(array[i - 1]); for (int i = 1; i &lt;= 1000000; ++i) write(array[i - 1]), putchar(' '); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; cost: 0.406813 seconds 新版本测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125; // 使用 fread() 来提高速度inline void read(int&amp; x) &#123; x = 0; char ch = 0; bool sign = false; // 使用 static 节省空间 while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; // 这里 x * 10 和 (x &lt;&lt; 1) + (x &lt;&lt; 3) 编译后的代码是一样的 // 所以不需要用位运算了 x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) &#123; putchar(stk[top--] + '0'); &#125;&#125;int main() &#123; freopen("testdata.txt", "r", stdin); freopen("output.txt", "w", stdout); int array[1000000]; auto start = system_clock::now(); for (int i = 1; i &lt;= 1000000; ++i) read(array[i - 1]); for (int i = 1; i &lt;= 1000000; ++i) write(array[i - 1]), putchar(' '); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; cost: 0.275003 seconds 总结新的快读几乎是快了一倍，不过两者都已经是神仙打架了，像 scanf 这种都已经被踢飞了，不过，快读虽好，使用还是要谨慎，速度的提高主要还是靠算法的优化（除了某些高性能的题）。 补充这个 nextchar() 函数只能在读入文件时使用，在控制台输入时会出错，因为 fread() 是专门针对文件的。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>C++ 奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 初赛] 总结一波读程序写结果题目]]></title>
    <url>%2F2018%2F09%2F20%2FNOIP-%E5%88%9D%E8%B5%9B-%E6%80%BB%E7%BB%93%E4%B8%80%E6%B3%A2%E8%AF%BB%E7%A8%8B%E5%BA%8F%E5%86%99%E7%BB%93%E6%9E%9C%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[为了提高初赛分数，痛下决心总结一波读程序写结果的题。ps: 一次更新不完，会持续更新 第二十一届 / NOIP 20151234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void fun(char *a, char *b) &#123; a = b; (*a)++;&#125;int main() &#123; char c1, c2, *p1, *p2; c1 = 'A'; c2 = 'a'; p1 = &amp;c1; p2 = &amp;c2; fun(p1, p2); cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; endl; return 0;&#125;// 输出：Ab 这道题中先是将 p1 赋值为 c1 的地址，将 p2 赋值为 c2 的地址，然后将 p1 赋值为 p2 的值，即现在 p1 所表示的是 c2 的地址，所以最后只有 c2 会发生改变，这道题一开始没看出来，后来仔细想了想才反应过来，不失为一道坑题。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int fun(int n, int fromPos, int toPos) &#123; int t, tot; if (n == 0) return 0; for (t = 1; t &lt;= 3; t++) if (t != fromPos &amp;&amp; t != toPos) break; tot = 0; tot += fun(n - 1, fromPos, t); tot++; tot += fun(n - 1, t, toPos); return tot;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; fun(n, 1, 3) &lt;&lt; endl; return 0;&#125;// 输入：5// 输出：31 这道题其实纯属糊弄人，可以发现 fun 这个函数中不管 fromPos 和 toPos 为何值，总能继续下去，所以简化后的函数如下： 1234int fun(int n) &#123; if (n == 0) return 0; return fun(n - 1) * 2 + 1;&#125; 好了，这样子的递归函数手推就行了。 未完待续……]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 初赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 初赛] 总结各种坑人基础知识]]></title>
    <url>%2F2018%2F09%2F16%2FNOIP-%E5%88%9D%E8%B5%9B-%E6%80%BB%E7%BB%93%E5%90%84%E7%A7%8D%E5%9D%91%E4%BA%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[初赛临近，每天一张初赛卷让我发现了很多基础知识上的坑，于是决定总结一下。 信仰坑NOI（1984 至今）: 已组织 33 次活动，各省选拔五名选手，至少一名为女选手。NOIP（1995 至今）: 已组织 22 次比赛，全国同一时间，不同地点。IOI（1989 至今）: 已组织 19 次比赛，IOI 2000 由中国主办，CCF 承办。APIO（2007 创建）: APIO 中国赛区由中国计算机学会组织。 NOIP 2022 年开始将停止支持 Pascal 网络协议坑ARP (Address Resolution Protocol) 地址解析协议DHCP (Dynamic Host Configuration Protocol) 动态主机配置协议FTP (File Transfer Protocol) 文件传输协议HTTP (Hypertext Transfer Protocol) 超文本传输协议HTTPS (Secure Hypertext Transfer Protocol) 安全超文本传输协议IMAP4 (Internet Mail Access Protocol Version 4) Internet 邮件访问协议——版本4IPv6 (Internet Protocol Version 6) Internet 协议——版本6POP3 (Post Office Protocol version 3) 邮局协议——版本3SMTP (Simple Mail Transfer Protocol) 简单邮件传输协议TFTP (Trivial File Transfer Protocol) 小型文件传输协议 WWW 是 URL，不是网络协议]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 初赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 记录一道坑题]]></title>
    <url>%2F2018%2F09%2F01%2FNOIP-%E6%A8%A1%E6%8B%9F-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E5%9D%91%E9%A2%98%2F</url>
    <content type="text"><![CDATA[昨天的一场模拟，第二题本来应该是一道很水的题，然而最后打崩了，归根结底还是自己不够仔细，题目审错，最后导致方法用错。 题目描述[问题描述] 神即将带领一些人去他们的孤寂之境，由于这个世界的不稳定，地点之间的有向道路会不 定期地毁坏，出于工作准备，神想知道在某些道路毁坏之后某两点之间的最短路。 就是给定一个有向图，现有两个操作，操作1 是删除一条边（一条边可重复删除），操作2 是询问两个点之间的最短路。 [输入格式] 输入文件名为journey.in。 第1 行两个正整数n, m，分别表示图的点数和操作数。 第2 行至第n + 1 行每行n 个正整数，为图的邻接矩阵，第i 行第j 列的数表示点i 和点 j 间距离，保证对角线为0。 接下来m 行每行三个正整数c, x, y； c 表示操作种类，为1 或2，当c = 1 时表示删除x 与y 相连的边，当 c = 2 时表示询问 x 到 y 的最短路，若不可达则输出 -1。 [输出格式] 输出文件名为journey.out 输出若干行，每个 2 操作对应一行，答案为询问中 x 到 y 的最短路或 -1 [样例] 见下发/girls/girls.in(out)。 [数据规模与约定] 对于30% 的数据：n, m &lt;= 10 对于50% 的数据：n, m &lt;= 50 对于100% 的数据：n &lt;= 200; m &lt;= 100000, 操作1 不超过200 次，边权不超过10000 题解一碰到查找的题，那肯定就是两条路了，离线和在线两种思路，乍一看这 $n$ 的数据范围，并且题目中还说输入邻接矩阵，那求最短路肯定是 Floyd 了，再一想，如果是在线查询那只有朴素算法了，查一次求一次全源最短路，然后这种方法就 TLE 了，代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 210#define INF 0x3f3f3f3finline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;inline void writeln(int &amp;x) &#123; write(x); puts(""); &#125;inline void read(int &amp;a, int &amp;b) &#123; read(a); read(b); &#125;inline void read(int &amp;a, int &amp;b, int &amp;c) &#123; read(a); read(b); read(c); &#125;int g[maxn][maxn], d[maxn][maxn], n, m, c, x, y;void Floyd() &#123; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);&#125;int main() &#123; freopen("journey.in", "r", stdin); freopen("journey.out", "w", stdout); memset(d, INF, sizeof(d)); read(n, m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) read(g[i][j]); while (m--) &#123; read(c, x, y); switch (c) &#123; case 1: &#123; g[x][y] = INF; break; &#125; case 2: &#123; memcpy(d, g, sizeof(g)); Floyd(); if (g[x][y] == INF) puts("-1"); else writeln(g[x][y]); memcpy(g, d, sizeof(d)); break; &#125; &#125; &#125; return 0;&#125; 所以正解肯定就是离线操作了，先把该删的边都给删掉，然后从最后一个操作开始处理，遇到操作一就加边，求一次最短路，当然这里不是用 Floyd 而是用一个 $\mathcal{O}(n^2)$ 的方法，附上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3f#define maxn 210#define maxm 100010struct op &#123; int c, x, y; &#125;;// op 结构体，记录操作op ops[maxm];int g[maxn][maxn], d[maxn][maxn];int w[maxm], ans[maxm];int n, m;inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;inline void writeln(int x) &#123; write(x); puts(""); &#125;inline void read(int &amp;a, int &amp;b) &#123; read(a); read(b); &#125;inline void read(int &amp;a, int &amp;b, int &amp;c) &#123; read(a); read(b); read(c); &#125;// 快读快写黑科技void Floyd() &#123; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125;// Floyd 对 d[][] 操作求最短路int main() &#123; freopen("journey.in", "r", stdin); freopen("journey.out", "w", stdout); read(n, m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) read(g[i][j]); memcpy(d, g, sizeof(g)); // 输入，g[][] 用来备份原邻接矩阵 for (int i = 1; i &lt;= m; ++i) &#123; read(ops[i].c, ops[i].x, ops[i].y); if (ops[i].c == 1) &#123; w[i] = g[ops[i].x][ops[i].y]; d[ops[i].x][ops[i].y] = INF; &#125; &#125; Floyd(); // 读入所有操作后 Floyd int cnt = 0; for (int k = m; k &gt; 0; --k) &#123; // 注意循环顺序，从最后一个开始 int x = ops[k].x; int y = ops[k].y; if (ops[k].c == 2) ans[++cnt] = (d[x][y] == INF ? -1 : d[x][y]); // 题目中要求如果不连通输出 -1，所以这里特判一下 // 标程中似乎没有这一句，自己搞了一个数据把标程给卡掉了，所以还是要加的 else &#123; // 求一次最短路，只要把 d[x][y] 加进去再比较一下就可以了 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; int tmp = d[i][x] + d[y][j] + w[k]; if (tmp &lt; d[i][j]) d[i][j] = tmp; &#125; &#125; &#125; &#125; // 最后输出要注意顺序 for (int i = cnt; i &gt; 0; --i) writeln(ans[i]); return 0;&#125; 总结以后看到这种题必须要读清楚题意，然后决定是否离线操作，考试的时候我根本就是智障了，直接在数组 $d$ 上面删边，求最短路，然后 GG。幸好最后醒悟过来打了个暴力。邻阶矩阵就是这点太坑。。。容易让人误操作。。。]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEXO] NexT 主题提高博客颜值]]></title>
    <url>%2F2018%2F08%2F30%2FHEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC%2F</url>
    <content type="text"><![CDATA[今天是把博客好好地美化了一把，今天就来讲一下 hexo 博客美化过程中的心得，因为自己使用的是 NexT 主题，所以这里的有些过程仅供别的主题的用户做参考。 文章的模板文件为了每次更新方便，我直接改了 blog/scaffolds/ 下的 post.md，每次生成的时候模板就都有了，不需要自己再去弄。这个是我的模板： 1234567891011121314151617---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:mathjax: truecopyright: truecomment: truephoto: ---&#123;% note default %&#125;&#123;% endnote %&#125;&lt;!-- more --&gt;--- 说明一下，这个 note 要在 next\_config.yml 中开启才可以写。下面会讲到。photo 是文章开头的图片，就像这篇文章开头那样，注意一定要加绝对路径，比如我这张图片存在文章的文件夹下，那么路径就是 /2018/08/30/HEXO-NexT-主题提高博客颜值/photo1.jpg。copyright 这一项也是要开启之后才行，我的博客的 copyright 是自己重新写的，后面会讲到。最后这个 --- 是结束符，和最后的结束语一起用。 Markdown 技巧与内置样式基础的语法就不提了，点进来的应该都会了。这里就讲讲一些技巧。 编辑器我用的 Markdown 编辑器是 Typora，有些行内公式的显示可以在设置里打开。这是我用过的最好的 Markdown编辑器 分隔线和空行12345这是文字&lt;hr /&gt;上面是分隔线&lt;br /&gt;上面是空行 效果如下： 这是文字 上面是分隔线上面是空行 引用123&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;!-- 如果前后间隙很小，可以像下面这样写 --&gt;&lt;p&gt;&lt;blockquote&gt;引用内容&lt;/blockquote&gt;&lt;/p&gt; 效果如下： 引用内容 引用内容 居中和右对齐1234&lt;!-- 居中 --&gt;&lt;center&gt;内容&lt;/center&gt;&lt;!-- 右对齐 --&gt;&lt;div style="text-align:right"&gt;内容&lt;/div&gt; 效果如下： 内容 内容 字体大小和颜色12&lt;font color="#187892" size="number"&gt;内容&lt;/font&gt;&lt;!-- 详细请查看 http://www.w3school.com.cn/tags/tag_font.asp --&gt; 效果如下： 内容 Todo list1234&lt;ul&gt;&lt;li&gt;&lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成&lt;/li&gt;&lt;li&gt;&lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成&lt;/li&gt;&lt;/ul&gt; 效果如下： 已完成 未完成 Note 嵌套 Todo list1234567891011121314151617181920212223&lt;!-- 一共有两种写法，效果看下面 --&gt;&lt;div class="note primary"&gt; &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成&lt;/div&gt;&lt;div class="note primary"&gt; &lt;p&gt; &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; 已完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;i class="fa fa-square"&gt;&lt;/i&gt; 未完成 &lt;/p&gt;&lt;/div&gt; 效果如下： 已完成 已完成 已完成 已完成 已完成 未完成 未完成 未完成 已完成 已完成 已完成 已完成 已完成 未完成 未完成 未完成 这两个写法熟悉 HTML 的同学应该是明白的，这里因为我太菜了就不讲了。主要说一下 &lt;i class=&quot;fa fa-square&quot;&gt;&lt;/i&gt; 是从 Font Awesome 上获取图标的方法，不过有些图标似乎是不能加载的，我也不知道为什么。 Font AwesomeFont Awesome 更多的使用可以看官网示例，这里讲一个放大图标的方法 123&lt;i class="fa fa-download"&gt;&lt;/i&gt; 普通&lt;i class="fa fa-download fa-lg"&gt;&lt;/i&gt; 变大 33%&lt;i class="fa fa-download fa-2x"&gt;&lt;/i&gt; 两倍大 效果如下： 普通 变大 33% 两倍大 代码高亮主题自带样式 代码块高亮12```[language] [title] [url] [link-text]`代码` [language] 是代码语言的名称，用来设置代码块颜色高亮，非必须；[title] 是顶部左边的说明，非必须；[url] 是顶部右边的超链接地址，非必须；[link text] 如它的字面意思，超链接的名称，非必须。亲测这 4 项应该是根据空格来分隔，而不是[]，故请不要加[]。除非如果你想写后面两个，但不想写前面两个，那么就必须加 [] 了，要这样写：[] [] [url] [link text]。 首先关于代码块颜色高亮，高亮的模式可以在主题配置文件中设置：123456# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties 要颜色正确高亮，代码语言的名称肯定要写对，各种支持语言的名称可以查看这篇文章。当然，如果你和我一样懒，可以在站点配置文件 _config.yml 中设置自动高亮（不过这个自动高亮似乎有问题，不建议打开）：123456highlight: enable: true line_number: true# 代码自动高亮- auto_detect: false+ auto_detect: true 从网上找到的一个文本效果如下（别跟我说你不知道 diff 是什么）：123456789101112131415161718192021222324252627Index: languages/ini.js===================================================================--- languages/ini.js (revision 199)+++ languages/ini.js (revision 200)@@ -1,8 +1,7 @@ hljs.LANGUAGES.ini = &#123;- case_insensitive: true,- defaultMode: &#123;+ defaultMode: &#123;- contains: ['comment', 'title', 'setting'],+ illegal: '[^\\s]'+ &#125;,*** /path/to/original timestamp--- /path/to/new timestamp****************** 1,3 ****--- 1,9 ----+ This is an important+ notice! It should+ therefore be located at+ the beginning of this+ document!! compress the size of the! changes. It is important to spell 代码仅仅高亮肯定是不够地，代码块地功能也很重要，比如复制这个功能。只要在 _config.yml 里打开就行啦：123456789codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: 3 # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true Note 标签在主题配置文件_config.yml里有一个关于这个的配置:123456789# Note tag (bs-callout).note: # 风格 style: flat # 要不要图标 icons: true # 圆角矩形 border_radius: 3 light_bg_offset: 0 用 HTML 写就是这个样子1234567&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt;&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt;&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt;&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt;&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger no-icon"&gt;&lt;p&gt;danger no-icon&lt;/p&gt;&lt;/div&gt; 用 swig 语法写就是这样 12345&#123;% note [class] %&#125;Any content (support inline tags too).&#123;% endnote %&#125;[class] : default | primary | success | info | warning | danger. May be not defined. 里面的三种风格长啥样？开启图标长啥样？可以查看这个页面，更多的介绍也在这个页面，请自行查看 最后的几种效果： defaultprimarysuccessinfowarningdangerdanger no-icon Label 标签label 标签不建议加在段首, 首先可以在主题配置文件中有配置：12# Label tag.label: true 然后效果如下（@前面的是label的名字，后面的是要显示的文字） default 1&#123;% label default@default %&#125; primary 1&#123;% label primary@primary %&#125; success 1&#123;% label success@success %&#125; info 1&#123;% label info@info %&#125; warning 1&#123;% label warning@warning %&#125; danger 1&#123;% label danger@danger %&#125; Tab 选项卡当然也是要先配置一下：1234567# Tabs tag.tabs: enable: true transition: tabs: true labels: true border_radius: 3 代码如下：1234567891011&#123;% tabs 选项卡, 2 %&#125;&lt;!-- tab --&gt;**这是选项卡 1** 呵呵哈哈哈哈哈哈&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 2** 额。。。&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3** 哇，你找到我了！&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 效果如下：选项卡 1选项卡 2选项卡 3这是选项卡 1 呵呵哈哈哈哈哈哈这是选项卡 2 额。。。这是选项卡 3 哇，你找到我了！ 上面源码中，2 表示一开始在第二个选项卡，非必须，若数值为 -1 则隐藏选项卡内容。 按钮样式代码如下：1&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, 更多关于按钮的使用点这里, download fa-lg fa-fw %&#125; 效果如下： 更多关于按钮的使用点这里 更多的主题配置返回顶部按钮与阅读进度在 next/_config.yml 里找到 b2t 这个地方进行如下配置：1234# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 添加 RSS 订阅首先安装一个模块1$ npm install hexo-generator-feed --save 然后在根目录下的 _config.yml 里添加：1plugins: hexo-generate-feed 最后在 next\_config.yml 里配置：1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 重新生成就可以使用 RSS 了。 评论系统重配置以前用的是 Disqus，然而需要翻墙，所以决定换成 Valine。这个 Valine 要先在 LeanCloud 里注册并创建一个应用，这里就不再赘述.然后在 next\_config.yml 里配置。注意：得在 LeanCloud -&gt; 应用 -&gt; 设置 -&gt; 应用 Key 中把 AppID 和 AppKey 给复制到 next\_config.yml 里面去，并且在 LeanCloud -&gt; 应用 -&gt; 设置 -&gt; 安全中心 里将自己的域名添加到 Web 安全域名 中。 1234567891011valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: # your leancloud application appid appkey: # your leancloud application appkey notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: 😎看了这么多，不想说点什么嘛😉 # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html 这个 LeanCloud 也是比较良心的啊，可以免费使用，当然我用的是开发版，所以大家不要太着急🤣。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[杂谈] 编程规范那些事]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%9D%82%E8%B0%88-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[写在前面一直很想写一篇博客来普及一下“编程规范”这个看似不重要其实很重要的东西，首先，它是团队合作的基础，有些 OI 竞赛也是有团队合作的。其次，下到 OI 中几十行的程序，上到大项目中几千行甚至几万行乃至上亿（额，这个似乎很少见），如果写得太难看那就会让人实在是无法忍受（比如在写 DP 的时候硬是将一个状态转移方程压成了一行，行数比列数还多一倍）。可见编程规范是多么的重要! Google C++ 编程规范Google 的项目一直都让人看起来赏心悦目，即使有些混乱的宏定义也让人看起来赏心悦目，首先贴一张图，转自 CSDN 上的一篇博客 然后贴上谷歌编程指南的详细说明 评价Google 的编程指南真的是高妙，看起来赏心悦目，但个人觉得还是要去其糟粕的，比如“不用全局变量”这种，在竞赛中就可以直接忽视了，还是以代码的易用性为第一要务。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEXO] hexo 中插入视频的方法]]></title>
    <url>%2F2018%2F08%2F29%2FHEXO-hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面以前一直以为 hexo 是不能插入视频的，今天突然知道了，原来插入视频是可以的！！本篇博客主要讲解一下 hexo 博客如何插入视频。 插入 Youtube 视频插入 Youtube 视频其实很简单，在 YouTube 视频的下方的“共享”中，选择嵌入即可获取类似这样的链接： 1&lt;iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/7gJ8mGFjeqA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt; 效果如下（要梯子）： 可以将 width 或 height 改为 &quot;100%&quot;（当然也可以两个都改，具体效果试了才知道，这个数值是可以随便改的） 1&lt;iframe width="100%" height="350" src="https://www.youtube-nocookie.com/embed/7gJ8mGFjeqA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt; 效果如下（要梯子）： 插入 Bilibili 视频其实也是一样，点击“分享”，获取 iframe 这个代码就可以了 1&lt;iframe src="//player.bilibili.com/player.html?aid=19448254&amp;cid=31715906&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"&gt; &lt;/iframe&gt; 效果如下： 自定义了大小之后的效果： 通用方法直接把视频文件放在资源文件夹里，然后直接写 HTML 代码： 123&lt;video width="100%" height="400" src="movie.mp4" controls="controls"&gt;The `&lt;video&gt;` tag is not supported by your browser.&lt;/video&gt; 效果如下： The &lt;video&gt; tag is not supported by your browser. 总结嗯…… HTML 大法好，在 Markdown 里用 HTML 控件简直美滋滋。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论] Dijkstra 最短路计数]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%9B%BE%E8%AE%BA-Dijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面最短路计数是一个很经典的问题，今天刚好做到了这样一道题，就来总结一下。 最短路计数题目：洛谷 P1144 最短路计数最短路计数本质上还是求最短路，只不过在迭代的同时来更新最短路数量。首先来回忆一下 Dijkstra 求最短路的更新条件，对于一条有向边 $(u,v,w)$，我们更新到 $v$ 的最短路的条件是：$$dist[v] &gt; dist[u] + w$$在最短路计数的时候我们可以用动态规划的思想，记 $num[x]$ 表示到 $x$ 的最短路的数量，那么： 若 $dist[v] = dist[u] + w$ 我们更新 $num[v] = num[v] + num[u]$，即有另外一条路径。 若 $dist[v] &gt; dist[u] + w$ 我们更新 $num[v] = num[u]$，即有更短的路径，前面的全部作废。 所以这道题的代码就呼之欲出了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define maxm 2000010#define maxn 1000010#define modn 100003#define INF 0x7f7f7f7fstruct heapNode &#123; int u, d; bool operator&lt;(const heapNode &amp;b) const &#123; return d &gt; b.d; &#125; // 这里似乎是一定要加 const，否则会 CE&#125;;struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125; edges[maxm &lt;&lt; 1];int numEdges = 0, heads[maxn];priority_queue&lt;heapNode&gt; Q;int dist[maxn], num[maxn];int n, m, x, y;void init() &#123; numEdges = 0; memset(heads, -1, sizeof(heads)); memset(dist, INF, sizeof(dist)); memset(num, 0, sizeof(num)); while (!Q.empty()) Q.pop();&#125;void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125;void Dijkstra(int x) &#123; dist[x] = 0; num[x] = 1; Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int d = f.d; if (d != dist[u]) continue; for (int i = heads[u]; i != -1; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] == dist[u] + w) &#123; num[j] += num[u]; // 更新情况一 num[j] %= modn; // 题目要求取模 &#125; else if (dist[j] &gt; dist[u] + w) &#123; num[j] = num[u]; // 更新情况二 dist[j] = dist[u] + w; Q.push((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; if (x == y) continue; addDuplexEdge(x, y, 1); &#125; Dijkstra(1); for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; num[i] &lt;&lt; endl; &#125; return 0;&#125; 总结由这个最短路计数我们可以看出动态规划实在是实用啊！]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最短路计数</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[平衡树] Treap 总结]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%B9%B3%E8%A1%A1%E6%A0%91-Treap-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[写在前面为了继续完善自己的数据结构有关的知识，决定先总结一波 Treap。Treap 是我学的第一个平衡树结构，花了很长时间才把板子背下来把它真正理解了，不禁感叹数据结构真的是神奇啊！ BST 二叉查找树的性质因为想重点总结的是 Treap 而不是普通 BST，所以这里只稍微提一下它的性质： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 BST 是 Treap 学习的基础，更多内容可以看这篇博客。上面这些性质，可以使得在 BST 上查找前驱 / 后继更为方便。这些性质是构建 BST 的基础，但是也使得 BST 不能很好地保持树的平衡，即左右子树的大小相差太大，最极端的情况就是一条链，为了保持 BST 的平衡，诞生了各种平衡树。 TreapZig 和 Zag保持 Treap 平衡的方式就是改变 Treap 的形态，同时又必须保证 Treap 仍然具备 BST 的性质，于是 Zig 和 Zag 操作就诞生了 可见这并不是简单的旋转，它还将某个节点向根节点移动，这个过程只可意会不可言传，还是好好理解上图。旋转的代码实现如下：12345678910111213void zig(int &amp;p) &#123; int q = treap[p].lChild; treap[p].lChild = treap[q].rChild; treap[q].rChild = p; p = q;&#125;void zag(int &amp;p) &#123; int q = treap[p].rChild; treap[p].rChild = treap[q].lChild; treap[q].lChild = p; p = q;&#125; 保证 Treap 的平衡什么样的旋转才能保证它的平衡呢？Treap 是 Tree 和 Heap 的复合名词，所以它还满足堆性质。它利用“随机”来创造平衡的条件，每一个节点都有一个随机生成的额外权值，Treap 在满足 BST 性质的同时还通过旋转使得权值满足大根堆的性质。特别的，在删除 Treap 的节点时，可以直接把这个节点旋转到叶节点来直接删除，这样就免去了很多复杂的操作。 从一道例题看代码实现题目在这：洛谷 P3369 【模板】普通平衡树 因为题目中同一个节点可能有多个，所以可以为每个节点增加一个“副本数”，同时在获取 Rank 的时候别忘了减一，因为初始化的时候有一个正无穷，一个负无穷，它们只是为了保证 BST 性质，并不是实际的节点。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define INF 0x7fffffffstruct treapNode &#123; int lChild, rChild; // 左右子节点下标 int value, weight; // 节点关键码及权值 int count, size; // 副本数及子树大小&#125; treap[maxn];int numNodes, root, n;int newNode(int val) &#123; numNodes++; treap[numNodes].value = val; treap[numNodes].weight = rand(); // 随机权值 treap[numNodes].count = treap[numNodes].size = 1; return numNodes;&#125; // 建立一个新的节点void update(int p) &#123; treap[p].size = treap[treap[p].lChild].size + treap[treap[p].rChild].size + treap[p].count;&#125; // 更新某一个点的 size 方便获取排名void build() &#123; newNode(-INF); // 保证 BST 性质的两个点 newNode(INF); root = 1; treap[root].rChild = 2; update(root);&#125; // 初始化int getRankByVal(int p, int val) &#123; if (p == 0) return 0; if (val == treap[p].value) return treap[treap[p].lChild].size + 1; if (val &lt; treap[p].value) return getRankByVal(treap[p].lChild, val); return getRankByVal(treap[p].rChild, val) + treap[treap[p].lChild].size + treap[p].count;&#125;// 上下两个函数很好理解，不作赘述// 一切从 BST 性质出发int getValByRank(int p, int rnk) &#123; if (p == 0) return INF; if (treap[treap[p].lChild].size &gt;= rnk) return getValByRank(treap[p].lChild, rnk); if (treap[treap[p].lChild].size + treap[p].count &gt;= rnk) return treap[p].value; return getValByRank(treap[p].rChild, rnk - treap[treap[p].lChild].size - treap[p].count);&#125;void zig(int &amp;p) &#123; int q = treap[p].lChild; treap[p].lChild = treap[q].rChild; treap[q].rChild = p; p = q; update(treap[p].rChild); update(p); // 别忘记更新&#125;void zag(int &amp;p) &#123; int q = treap[p].rChild; treap[p].rChild = treap[q].lChild; treap[q].lChild = p; p = q; update(treap[p].lChild); update(p);&#125;void insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == treap[p].value) &#123; treap[p].count++; update(p); return; &#125; if (val &lt; treap[p].value) &#123; insert(treap[p].lChild, val); if (treap[p].weight &lt; treap[treap[p].lChild].weight) zig(p); &#125; else &#123; insert(treap[p].rChild, val); if (treap[p].weight &lt; treap[treap[p].rChild].weight) zag(p); &#125; // zig 和 zag 操作，保证满足大根堆性质 update(p);&#125; // 插入一个点int getPre(int val) &#123; int ans = 1; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].lChild &gt; 0) &#123; p = treap[p].lChild; // 左子树上不断向右走，获取最大的前驱 while (treap[p].rChild &gt; 0) p = treap[p].rChild; ans = p; &#125; break; &#125; if (treap[p].value &lt; val &amp;&amp; treap[p].value &gt; treap[ans].value) ans = p; // 尝试更新答案 p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125; // 获取前驱int getNext(int val) &#123; int ans = 2; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].rChild &gt; 0) &#123; p = treap[p].rChild; // 右子树上不断向左走，获取最小的后继 while (treap[p].lChild &gt; 0) p = treap[p].lChild; ans = p; &#125; break; &#125; if (treap[p].value &gt; val &amp;&amp; treap[p].value &lt; treap[ans].value) ans = p; // 尝试更新答案 p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125;void remove(int &amp;p, int val) &#123; if (p == 0) return; if (val == treap[p].value) &#123; if (treap[p].count &gt; 1) &#123; treap[p].count--; update(p); &#125; else if (treap[p].lChild != 0 || treap[p].rChild != 0) &#123; if (treap[p].rChild == 0 || treap[treap[p].lChild].weight &gt; treap[treap[p].rChild].weight) &#123; zig(p); remove(treap[p].rChild, val); &#125; else &#123; zag(p); remove(treap[p].lChild, val); &#125; // 通过旋转来删除节点 update(p); &#125; else p = 0; return; &#125; if (val &lt; treap[p].value) remove(treap[p].lChild, val); else remove(treap[p].rChild, val); update(p);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); numNodes = 0; build(); cin &gt;&gt; n; int opt, x; while (n--) &#123; cin &gt;&gt; opt &gt;&gt; x; switch (opt) &#123; case 1: &#123; insert(root, x); break; &#125; case 2: &#123; remove(root, x); break; &#125; case 3: &#123; cout &lt;&lt; getRankByVal(root, x) - 1 &lt;&lt; endl; break; &#125; // 减一 case 4: &#123; cout &lt;&lt; getValByRank(root, x + 1) &lt;&lt; endl; break; &#125; // 加一 case 5: &#123; cout &lt;&lt; getPre(x) &lt;&lt; endl; break; &#125; case 6: &#123; cout &lt;&lt; getNext(x) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; 总结班里的某个大佬和我说 Treap 没有 ZigZag，这让我很懵逼。但是 Zig 和 Zag 操作的确是很重要的，似乎在学 Splay 的时候也会用到，多学无害。Treap 还是很有用的，关键时候可以救命。]]></content>
      <categories>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>Treap</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论] OI 中素数有关的算法整理]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%95%B0%E8%AE%BA-OI-%E4%B8%AD%E7%B4%A0%E6%95%B0%E6%9C%89%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面本来是想总结一道数论神题的，但是怎么证明似乎都不是很完美，而且代码的实现涉及到很多数论有关的算法，于是想现总结一下与素数有关的算法。 素数的判定Brute-Force 朴素算法额，这个就不多说了吧，最无脑的，$2\thicksim n$ 枚举所有小于 $n$ 的数来进行判定。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;bool isPrime(int n) &#123; if (n == 2) return true; for (int i = 2; i &lt; n; ++i) if (n % i == 0) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (isPrime(n) ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; Optimized-Brute-Force 优化过的朴素算法如果一个数不是素数是合数， 那么一定可以由两个大于 $1$ 自然数相乘得到， 其中一个大于或等于它的平方根，一个小于或等于它的平方根。并且成对出现。所以可以优化朴素算法 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;bool isPrime(int n) &#123; if (n == 2) return true; for (int i = 2; i * i &lt; n; ++i) if (n % i == 0) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (isPrime(n) ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; 筛法求素数上面两个菜鸡方法只能针对数很小的情况，这些情况在 OI 中出现的话出卷老师会死得很惨变成广大 OIer 的恩人，然而这种情况是不可能的。于是又有了更高效的方法——筛法。它的思想就是将一个范围内的素数全部筛出来，预处理之后方便查找和判定。最朴素的筛法莫过于 Eratosthenes 筛法了（不要纠结这个名字怎么读，因为我也不会），它是将所有素数的倍数都给筛掉，剩下的就是素数了。时间复杂度为 $O(N\log\log N)$ 接近线性 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1000010bool prime[maxn];void Eratosthenes() &#123; memset(prime, true, sizeof(prime)); prime[1] = false; for (int i = 2; i &lt;= maxn; ++i) &#123; if (!prime[i]) continue; for (int j = i; j &lt;= maxn / i; ++j) &#123; // 这里是一个小优化，因为小于 i^2 的数在前面肯定已经筛过了 // 所以 j 从 i 开始取 prime[j * i] = false; &#125; &#125;&#125;int main() &#123; int n; Eratosthenes(); cin &gt;&gt; n; cout &lt;&lt; (prime[n] ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; 然而，Eratosthenes 筛会重复标记素数，造成时间复杂度冗余，如果对于每个数有唯一的方法确定它，那么就可以解决这个问题。由此引出了线性筛这个方法，它通过从大到小累计质因子的方法标记每一个合数，即让 $12$ 只有 $2\times 2\times 3$ 这种产生方式。设数组 $fac$ 记录每个数的最小质因子，我们按照下面的步骤来维护 $fac$： 依次考虑 $1\thicksim n$ 之见的每一个数 $i$ 若 $fac[i]=i$ 说明 $i$ 是质数，将它保存下来 扫描不大于 $fac[i]$ 的每个质数 $p$，令 $fac[i\times p]=p$，即在 $i$ 的基础上累积一个质因子 $p$，因为 $p\leqslant fac[i]$，所以 $p$ 为合数 $i\times p$ 的最小质因子。 这样子，每个合数只会被它的最小质因子 $p$ 筛一次，时间复杂度为线性。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1000010int fac[maxn], prime[maxn];void LinearSieve(int n) &#123; memset(fac, 0, sizeof(fac)); int m = 0; for (int i = 2; i &lt;= n; ++i) &#123; if (fac[i] == 0) &#123; fac[i] = i; prime[++m] = i; &#125; for (int j = 1; j &lt;= m; ++j) &#123; // 跳出循环的条件 if (prime[j] &gt; fac[i] || prime[j] &gt; n / i) break; fac[i * prime[j]] = prime[j]; &#125; &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; prime[i] &lt;&lt; " ";&#125;int main() &#123; int n; LinearSieve(100000); return 0;&#125; 线性筛又名欧拉筛。 伪素数测试在开始 Miller-Rabin 算法之前我们先来看一下伪素数测试，首先要了解费马小定理： $a^{p-1}\equiv1(\bmod p)$ 当 $p$ 为素数时且 $gcd(a,p)=1$ 时。费马小定理的逆命题虽然不是真命题，但是几乎成立，而不成立的时候，即如果 $n$ 是一个合数且 $a^{n-1}\equiv 1(\bmod n)$，那么称 $n$ 为基为 $a$ 的伪素数。如果我们找到一个 $a$ 使得 $n$ 不满足上述等式，那么 $n$ 必定为合数，那如果满足呢？$n$ 不一定是素数，这样的数被称作 Carmicheal 数，但是这种数十分稀少，前 $10000$ 个 $n$ 中只有 $22​$ 个数为 Carmicheal 数，所以这种方法还是比较可靠的。附上算法导论中的伪代码： 因为 Carmicheal 数的存在，人们寻求更好的，更准确的素数判定方法，于是就有了 Miller-Rabin 算法 Miller-Rabin 算法通过费马小定理我们可以得出一个推论，若 $p$ 为一个奇素数，那么有：$$a^p\equiv a\pmod p,1\leqslant a\leqslant p$$ 我们记$$p-1=2^kq,2\nmid q$$设 $a$ 是不被 $p$ 整除的数，那么下面两个条件之一必然成立： $a^q \equiv 1 \pmod p$ $a^q, a^{2q}, a^{2^2q}, \dots, a^{2^{k-1}q} \equiv -1 \pmod p$ 之中有一个等式成立 根据如下命题：$$a^2 \equiv 1 \pmod p \Rightarrow a \equiv \pm 1 \pmod p$$又因为上面第二个条件中的数，每一个都是前一个的平方，且最后一个数的平方是 $1$，所以如果表中一个数它模 $p$ 不余 $1$，但是它的平方模 $p$ 余 $1$，那么那个数一定是 $-1$，所以在这种情况下表中包含 $ -1$，又或者表中全是 $1$，那么第一个条件就会成立。 所以我们得到了 Miller-Rabin 素性测试的方法，也就是说，如果一个数不满足上面的性质，那么它就是和数，这个 $a$ 就成为证据。而 Miller-Rabin 的证据和上面提到的方法的证据不同，它能够保证每一个奇合数 $p$ 都会有不少于 $\frac{(p−1)}{2}$个证据（具体证明详见算法导论）。 我们只要随机 $50$ 个数来测试，那么测试失败的概率一定小于 $2^{−50}$，大约是 $8.9⋅10^{−16}$，如果你觉得不够，还可以找更多的数来测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;inline int64 rand64() &#123; return abs((int64)rand() &lt;&lt; 32 | rand()); &#125;inline int64 random(int64 x, int64 y) &#123; return x + rand64() % (y - x + 1); &#125;// 随机数生成函数int64 montgomery(int64 a, int64 b, int64 c) &#123; int64 result = 1; int64 temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;bool witness(int64 a, int64 p) &#123; int k = 0; int64 q = p - 1; while ((q &amp; 1) == 0) &#123; k++; q &gt;&gt;=1; &#125; int64 v = montgomery(a, q, p); // 判断一 if (v == 1 || v == p - 1) return false; while (k--) &#123; v = v * v % p; if (v == p - 1) return false; // 判断二 &#125; return true;&#125;bool MillerRabin(int64 p) &#123; if (p == 1) return false; if (p == 2) return true; if (p % 2 == 0) return false; // 这里其实可以加更多的特判来节约时间 for (int i = 1; i &lt;= 50; ++i) if (witness(random(1, p - 1), p)) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) if (MillerRabin(i)) cout &lt;&lt; i &lt;&lt; " "; // 输出 1 ~ n 之间的所有素数 return 0;&#125; 对于大的素数，为了节约判定的时间，我们只能退而求其次选择非完美算法来进行验证，不过不得不说，Miller-Rabin 其实已经很完备了。 总结事实上，对于素数的判定还有很多算法，例如 Solovay-Strassen 算法和 AKS 算法，然而这两个似乎都超出了 OI 的范围，一般不会用得到，这里也就不再赘述。 质因数分解试除法结合素数判定的“试除法”和“Eratosthenes 筛法”，我们可以扫描 $2\thicksim\lfloor\sqrt{n}\rfloor$ 中的每个数 $d$，若 $d$ 能整除 $n$，则从 $n$ 中除掉所有的因子 $d$，同时累计个数。 12345678910111213int p[maxn], c[maxn];void divide(int n) &#123; int m = 0; for (int i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; p[++m] = i; c[m] = 0; while (n % i == 0) &#123; n /= i; c[m]++; &#125; &#125; &#125; if (n &gt; 1) &#123; p[++m] = n; c[m] = 1 &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; p[i] &lt;&lt; '^' &lt;&lt; c[i] &lt;&lt; endl;&#125; Pollard-Rho 算法Pollard-Rho 也是一个不完美算法，不完美之处在时间复杂度上体现。Pollard-Rho算法分解一个数 $n$ 的过程大体上是这样子的： 找到一个数 $p$，使得 $p|n$，将 $n$ 分解为 $p$ 与 $\frac{n}{p}$ 如果 $p$ 或 $\frac{n}{p}$ 不为质数，将其带入递归上述过程 如果其是质数，将其记录并退出 那有人就会问了：这跟暴力分解有什么区别？好像时间复杂度比暴力还高啊！！？？所以，下面的优化才是关键。第一个优化，使用 Miller-Rabin 判定其是否为质数。第二个优化才是最关键的：对于一个大整数n，我们要找到一个 $p$ 满足 $p|n$，这如同大海捞针。但是如果我们要找出 $p_1$、$p_2$，使得 $(|p_1−p_2|)|n$，这看起来似乎要容易一些。实际上我们只需要找出 $\gcd((|p1−p2|),n)&gt;1$的 $p_1$、$p_2$，则其 $\gcd$ 值肯定为n的约数。这看起来又容易了一些。实际上，这让整个算法容易许多。根据生日悖论，这种两两比较的方式，在加入比较的数越来越多的时候，其效率会大大提升，比找一个数的效率快很多。于是，找 $p$ 的过程变成了这个样子： 找到一个数 $p_1$ 通过某种玄学推导手段找出一个与 $p_1$ 对应的 $p_2$ 判断 $\gcd((|p1−p2|),n)$ 是否大于 $1$，不大于则将 $p_2$作为新的 $p_1$，重复过程，否则就找到了 为什么要用玄学手段？因为只有通过推导手段，才能保证不做重复判断。理论上的推导手段可以有很多，但实际使用中一般使用如下公式推导：$$p_2=(p_1^2+c)\bmod n$$其中 $c$ 为随机常数。这个公式的好处: 推导出来的 $p_2-p_1$ 差值基本不会相等。 可以证明，该推导结果会出现循环。也就是说，在出现循环之前，结果不会重复，少做了许多无用的判断。 出现循环了怎么办？换一个随机常数再搞。这就是该算法“非完美”的地方，时间复杂度要看脸的。那么如何判环呢？这里介绍一个算法：Floyd 判圈。 需要注意的是，之所以不能一个标记定在原地，是因为循环节不一定在开头就产生，可能走着走着才遇到循环。这条路径就类似于 $\rho$，Pollard-Rho 算法也是因此得名的。顺便附上算法导论中的一张玄学图： 注意，在小数分解的时候就别用这个了，老老实实用试除法吧。 未完待续……]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论] OI 中的模运算计算方法]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%95%B0%E8%AE%BA-OI-%E4%B8%AD%E7%9A%84%E6%A8%A1%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面模运算在 OI 中是非常神奇的存在，有时候题目会非常好（m）心（m）地（p）让我们将答案取模，然而计算模的方法随着题目的变化而变化，网上很多博客又太零散，这里痛下决心总结一下。 预备知识 恒等式： $(a\bmod n)\bmod n=a\bmod n$ 对于所有的正数 $x$ 有：$n^x\bmod n = 0$ 如果 p 是一个质数，且不为 b 的因数，此时由费马小定理有：$ab^{p−1}\bmod p=a\bmod p$ 分配律 $(a-b)\bmod n=(a\bmod n-b\bmod n)\bmod n$ $(a+b)\bmod n=(a\bmod n+b\bmod n)\bmod n$ $ab\bmod n=(a\bmod n)(b\bmod n)\bmod n$ 高次幂函数的取模暴力取模法由于我们的高次幂函数往往拥有很高的幂，而我们在计算机中只有int、float、double、long long这几种变量类型，远远不能满足我们对于大数字运算的要求，从而导致数据溢出无法完成运算。所以这里我们需要在每次迭代取模的过程中进行取模运算，从而保证数据不会溢出。代码如下：1234567long long pow(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; while (b--) result = result * a % c; return result;&#125;// 计算 a^b % c 这种算法的正确性毋庸置疑，但是如果幂指数太大的话，需要耗费的时间就更非常多，直接导致运算效率低下，所以只适用于指数不大的情况下使用。 二分幂要求 $a^n$，如果知道了 $a^{\frac{n}{2}}$ 那么再平方就行了。令 $A=a^{\lfloor\frac{n}{2}\rfloor}$若 $n$ 为偶数，那么 $Result=A^2$若 $n$ 为奇数，那么 $Result=a\times A^2$这样子复杂度从 $O(n)$ 降到了 $O(\log n)$ 12345678long long pow(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; if (b == 0) return 1; long long x = pow(a, b / 2, c); long long ans = (long long)x * x % m; if (b % 2 == 1) ans = ans * a % m; return (long long)ans;&#125; 蒙哥马利算法具体详细介绍见维基百科，这里直接上代码： 1234567891011long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125; 组合数取模方法一：杨辉三角递推使用递推公式：$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$写成数组：$C[n][m]=C[n-1][m]+C[n-1][m-1]$这也是杨辉三角的递推公式，所以边界为 $C[0][0]=1$。下面给出求一个组合数的方法：123456789101112131415161718#include &lt;iostream&gt;using namespace std;int n, m;long long c[10010];int main() &#123; cin &gt;&gt; n &gt;&gt; m; m = min(m, n - m); // 因为 c[n][m] == c[n][n - m] // 所以取最小值减少运算。 c[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 1; --j) c[j] = c[j] + c[j - 1]; cout &lt;&lt; c[m]; return 0;&#125;// 因为只求一个组合数，所以使用了滚动数组的方式 由于递推时间复杂度为 $O(n^2)$，所以只适用于小数据的情况。 方法二：乘法逆元在数据很大的时候，我们对组合数取模就会比较麻烦，因为数据不一定能存下，而且通过观察组合数的公式：$$C_n^m=\frac{n!}{m!(n-m)!}=\frac{n\times (n-1)\times…\times(n-m+1)}{m!}$$我们发现组合数是带有除法的，不能走一步取一次模，为了解决除法取模的问题，人们发明了逆元这个东西。若 $a\times b\equiv1\pmod p$ 则称 $b$ 为 $a$ 在模 $p$ 下的乘法逆元，一般认为，$b &lt; p$，$b$ 记为 $a^{-1}$。注意，此处 $a$ 与 $p$ 必须互质，否则乘法逆元不存在。那么逆元该怎么用呢？当然是借助它将除法转为乘法，再用分配律来计算了。我们来看一个式子：$$\frac{a}{b}\equiv\frac{a}{b}\times b\times b^{-1}\equiv a\times b^{-1}\pmod p$$这样就可以把问题转化为求一个数的逆元，再转化为乘法运算。 递推求逆元求 $i​$ 在模 $p​$ 下的乘法逆元，满足 $gcd(i, p)=1, i&lt; p​$使用欧几里得除法的形式，令 $p=k\times i+r​$，则 $k=\lfloor\frac{p}{i}\rfloor,r=p\bmod i​$显然，$k\times i+r\equiv 0(\bmod p)​$两边同乘 $i^{-1}\times r^{-1}​$，得 $k\times r^{-1}+i^{-1}\equiv 0\pmod p​$移项，整理：$i^{-1}\equiv -k\times r^{-1}\equiv (p-k)\times r^{-1}\pmod p​$将 $k​$ 和 $r​$ 用 $p​$ 来替换：$i^{-1}\equiv (p-\lfloor\frac{p}{i}\rfloor)\times (p\bmod i)^{-1}\pmod p​$使用 inv[i] 来表示 i 的逆元，有 inv[i] = (p - p / i) * inv[p % i]时间复杂的为线性，代码如下： 123456long long inv[10000010];long long getInverse(long long x, long long p) &#123; if (inv[x] != 0) return inv[x]; inv[x] = (p - p / i) * getInverse(p % x, p) % p; return inv[x];&#125; 费马小定理求逆元费马小定理：如此可爱的定理名称 $a^{p-1}\equiv1\pmod p$ 当 $p$ 为素数时且 $gcd(a,p)=1$ 时。所以求 $a$ 的逆元时，只要求出 $a^{p-2}$ 的值就可以了。 1234567891011121314long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getinverse(long long x, long long p) &#123; return Montgomery(x, p - 2, p);&#125; 逆元求组合数从组合数原公式出发$$C_n^m=\frac{n!}{m!(n-m)!}=\frac{n\times (n-1)\times…\times(n-m+1)}{m!}$$ 对于分子，我们可以用传统方法，边乘边模，对于分母，我们可以求逆元再乘分子。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getInverse(long long x, long long p) &#123; return Montgomery(x, p - 2, p);&#125;long long c(long long n, long long m, long long p) &#123; long long x = 1, y = 1; for (long long i = n; i &gt;= n - m + 1; --i) x = x * i % p; for (long long i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; long long n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; 注：$p$ 一定要是大质数，起码得大于 $m$。若要求 $a$ 在模 $p$ 下的乘法逆元，必须要保证 $a$ 与 $p$ 互质。在此题中，要求 $m!$ 的乘法逆元，那么 $p$ 必须与 $m!$ 互质，所以 $p$ 要大于 $m$，且是个质数。我一开始忘记了这点，导致调了一年 方法三：卢卡斯定理适用于对答案模一个质数的情况。与逆元不同的是，这个方法不要求 $p$ 是个很大的素数，因此，适用范围更广（也许吧）。卢卡斯定理：对于非负整数 $m$ 和 $n$ 及素数 $p$，有同余式：$$\binom{n}{m}\equiv\prod_{i=0}^k\binom{n_i}{m_i} \pmod p$$成立。其中：$$n=n_kp^k+n_{k-1}p^{k-1}+…+n_1p+n_0$$并且$$m=m_kp^k+m_{k-1}p^{k-1}+…+m_1p+m_0$$以上两个式子是 $n$ 和 $m$ 的 $p$ 进制展开。当 $m &lt; n$ 时，二项式系数 $\binom{n}{m}=0$。可以通过一系列的推导得出下面这个结论：$$\binom{n}{m}\equiv\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{m}{p}\rfloor}\times \binom{n\bmod p}{m\bmod p} \pmod p$$由这个公式我们可以得出结论：在 $n$ 和 $m$ 都小于 $p$ 时，公式一点用都没有。（啥？你问我为什么？$\binom{0}{0}=1$ 啊！）所以这个公式是在 $n\geqslant p$ 或 $m\geqslant p$ 的情况下使用的。这样可以减小 $n$ 和 $m$，使之小于 $p$，再用乘法逆元去求组合数。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getInverse(long long a, long long b) &#123; return Montgomery(a, b - 2, b);&#125;long long c(int n, int m, int p) &#123; if (m == 0) return 1 % p; if (n == 0) return 0; if (n &gt;= p || m &gt;= p) return c(n / p, m / p, p) * c(n % p, m % p, p) % p; // 核心语句 long long x = 1, y = 1; for (int i = n; i &gt;= n - m + 1; --i) x = x * i % p; for (int i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; long long n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; 未完待续……]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++ 奇技淫巧] 流迭代器使用]]></title>
    <url>%2F2018%2F08%2F17%2FC-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写在前面自从熟知了 STL 库这个东西，我就再也离不开它了，以前一直以为只有容器才会有迭代器可以用，然而这是因为自己的知识水平还不够高，今天就介绍一下流迭代器这种神奇的存在。 流迭代器iostream 迭代器（iostream iterator）：与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。 虽然 iostream 类型不是容器，但标准库同样提供了在 iostream 对象上使用的迭代器：istream_iterator 用于读取输入流，而 ostream_iterator 则用于写输出流。这些迭代器将它们所对应的流视为特定类型的元素序列。 下面列出流迭代器的使用方法： iostream 迭代器的构造函数 对应的意义 istream_iterator&lt;T&gt; in(strm) 创建从输入流 strm 中读取T类型对象的 istream_iterator 对象 istream_terator&lt;T&gt; in istream_iterator 对象的超出末端迭代器 ostream_iterator&lt;T&gt; out(strm) 创建将T类型的对象写到输出流 strm 的 ostream_iterator 对象 ostream_iterator&lt;T&gt; out(str, delim) 创建将 T 类型的对象写到输出流 strm 的 ostream_iterator 对象，在写入过程中使用 delim 作为元素的分隔符。delim 是以空字符结束的字符数组（C风格字符串）。 istream_iterator 的操作 对应的意义 it1 == it2; it1 != it2 比较两上 istream_iterator 对象是否相等（不等）。迭代器读取的必须是相同的类型。如果两个迭代器都是 end 值，则它们相等。对于两个都不指向流结束位置的迭代器，如果它们使用同一个输入流构造，则它们也相等 *it 返回从流中读取的值 it-&gt;mem 是 (*it).mem 的同义词。返回从流中读取的对象的 mem 成员 ++it; it++ 通过使用元素类型提供的 &gt;&gt; 操作从输入流中读取下一个元素值，使迭代器向前移动。通常，前缀版本使用迭代器在流中向前移动，并返回对加 $1$ 后的迭代器的引用。而后缀版本使迭代器在流中向前移动后，返回原值 注：流迭代器都是类模板：任何已定义输入操作符（&gt;&gt; 操作符）的类型都可以定义istream_iterator。任何已定义输出操作符（&lt;&lt; 操作符）的类型可定义 ostream_iterator。 流迭代器使用注：迭代器的头文件别忘记引入。 #include &lt;iterator&gt; 1234567891011121314151617#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;iterator&gt;using namespace std;int main() &#123; istream_iterator&lt;int&gt; cinIter(cin); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec; while (cinIter != endOfStream) //注意++先引用后增值，不能写出前缀 vec.push_back(*cinIter++); //也可以写成 vector&lt;int&gt; vec(cinIter, endOfStream); for (int i = 0; i != vec.size(); ++i) cout &lt;&lt; vec[i]; return 0;&#125; 注：其中 end_of_stream 定义为空的迭代器对象，用作结束迭代器。绑定流上的迭代器在遇到文件结束或某个错误时，将等于结束迭代器的值。 1234567int main(int argc, char **argv) &#123; ostream_iterator&lt;string&gt; outIter(cout, "\n"); istream_iterator&lt;string&gt; inIter(cin), endOfStream; while(endOfStream != inIter) *outIter++ = *inIter++; return 0;&#125; 注：执行顺序是先 iter++，返回 iter，最后 *iter。注意输出，输入 1 2 3 4 5，按 enter 输出 1\n2\n3\n4\n，按 ctrl+z 输出 5。 12345678910111213141516#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;using namespace std; int main(int argc, char **argv) &#123; ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); sort(vec.begin(), vec.end()); ostream_iterator&lt;int&gt; output(cout, " "); unique_copy(vec.begin(), vec.end(), output); return 0;&#125; 示例输入/输出： INPUT(in.txt): 1 2 2 2 5 5 6 6 7 8 9 10 9 100 OUTPUT: 1 2 5 6 7 8 9 10 100 流迭代器的限制 不可能从 ostream_iterator 对象读入，也不可能写到 istream_iterator 对象中。 一旦给 ostream_iterator对象赋了一个值，写入就提交了。赋值后，没有办法再改变这个值。此外，ostream_iterator 对象中每个不同的值都只能正好输出一次。 ostream_iterator 没有 -&gt; 操作符。 流迭代器的速度为了测试流迭代器的速度，我先随机生成了 $10000000$ 个数据，生成代码如下： 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ofstream test("in.txt"); srand((unsigned)time(NULL) * 19260817); // +1s for (int i = 1; i &lt;= 10000000; ++i) test &lt;&lt; rand() &lt;&lt; " "; return 0;&#125; 迭代器测试12345678910111213141516171819202122#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono; int main(int argc, char **argv) &#123; auto start = system_clock::now(); ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; 结果： cost: 10.7543 seconds 注：为了测试时间尽量精准，这里引入了 chrono 库，使用了支持 C++ 11 的 gcc 7.3.0，并且是在 Linux(Ubuntu) 上编译运行的，鉴于编译器的优化能力一个版本比一个版本强，此处没有开优化但结果仍可能有误差，与 OI 中使用迭代器的速度不一样，读者可以使用别的库再进行实验。 开了 $O_2$ 优化的流迭代器123456789101112131415161718192021222324#pragma GCC optimize(2)#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono; int main(int argc, char **argv) &#123; auto start = system_clock::now(); ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; 结果： cost: 2.31234 seconds 注：开了优化的结果，读者自行判断 OI 中快读的时间测试1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;using namespace std::chrono;inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;int main(int argc, char **argv) &#123; auto start = system_clock::now(); freopen("in.txt", "r", stdin); int x; vector&lt;int&gt; a; for (int i = 0; i &lt; 10000000; ++i) &#123; read(x); a.push_back(x); &#125; auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; 结果 cost: 2.61905 seconds 注：快读的写法也许不是最优，读者可以自行实验。 总结事实上，抛开 OI 比赛不说，STL 的库使用优化还是很强的，但是 OI 中嘛，如果作大死用这个也许真的会崩。至于有关 STL 速度的讨论可以看这里。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>C++ 奇技淫巧</tag>
        <tag>迭代器</tag>
        <tag>iostream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[算法] Manacher 算法求最长回文子串]]></title>
    <url>%2F2018%2F08%2F14%2F%E7%AE%97%E6%B3%95-Manacher-%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[写在前面最近几次考试都涉及到了字符串处理这个话题，所以自己打算恶补字符串有关的算法，同时又刚好做到了 LeetCode 上这么一道题，所以干脆一同解决掉。 最长回文字串问题最长回文子串问题：给定一个字符串，求它的最长回文子串长度。如果一个字符串正着读和反着读是一样的，那它就是回文串。下面是一些回文串的实例： 12321 a aba abba aaaa tattarrattat（牛津英语词典中最长的回文单词 那么如何解决这个问题呢？有很多种方法： Brute-Force 暴力求解：找到所有字串，一一验证，时间复杂度为 $O(n^3)$ 改进版 Brute-Force：遍历整个字符串的中间字符及空隙，然后向两端扫描，时间复杂度为 $O(n^2)$。 动态规划，此处暂时不介绍 下面将要介绍的 Manacher 算法，又名马拉车。 Manacher 算法暴力解法的缺陷所在 回文串奇偶性不定，使用上述方法二需要分类讨论，降低效率。 字串重复访问，时间复杂度冗余。 举个例子： char: a b a b a i: 0 1 2 3 4 在 $i=1$ 和 $i=2$ 时，字串 aba 被分别遍历了一次。Manacher 算法正式针对这些算法进行改进的算法，可以大大提高算法的运行效率。 解决长度奇偶性问题Manacher 算法通过一种预处理方式来解决第一个问题，它在字符串首尾及中间空隙插入一个字符，并且满足这个符号不在字符串中出现，这样就可以让所有的字符串长度变为奇数。以插入#为例： aba --&gt; #a#b#a# abba --&gt; #a#b#b#a# 插入的是同样的符号，且符号不存在于原串，因此子串的回文性不受影响，原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文 解决重复访问问题我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher定义了一个回文半径数组 $RL$，用 $RL[i]$ 表示以第 $i$ 个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义 $RL[i]$ 为第 $i$ 个字符为对称轴的回文串的最右一个字符与字符 $i$ 的距离。对于上面插入分隔符之后的两个串，可以得到 $RL$ 数组： $char$ # $a$ # $b$ # $a$ # $RL$ $1$ $2$ $1$ $4$ $1$ $2$ $1$ $RL-1$ $0$ $1$ $0$ $3$ $0$ $1$ $0$ $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ 上面我们还求了一下 $RL[i]-1$。通过观察可以发现，$RL[i]-1$的值，正是在原本那个没有插入过分隔符的串中，以位置i为对称轴的最长回文串的长度。那么只要我们求出了 $RL$ 数组，就能得到最长回文子串的长度。 于是问题变成了，如何高效地求的 $RL$ 数组。基本思路是利用回文串的对称性，扩展回文串。 我们再引入一个辅助变量 $MaxRight$，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下 $MaxRight$ 对应的回文串的对称轴所在的位置，记为 $pos$，它们的位置关系如下： 我们从左往右地访问字符串来求 $RL$，假设当前访问到的位置为 $i$，即要求 $RL[i]$，在对应上图，$i$ 必然是在 $pos$ 右边的。但我们更关注的是，$i$ 是在 $MaxRight$ 的左边还是右边。我们分情况来讨论： 情况一：$i$ 在 $MaxRight$ 左边如下图所示： 我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以 $i$ 为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到 $i$ 关于 $pos$ 的对称位置 $j$，这个 $j$ 对应的 $RL[j]$ 我们是已经算过的。根据回文串的对称性，以i为对称轴的回文串和以j为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况: 以 $j$ 为对称轴的回文串较短如下图： 这时我们知道 $RL[i]$ 至少不会小于 $RL[j]$，并且已经知道了部分的以i为中心的回文串，于是可以令 $RL[i]=RL[j]$。但是以i为对称轴的回文串可能实际上更长，因此我们试着以 $i$ 为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。 以 $j$ 为对称轴的回文串较长如下图： 这时，我们只能确定，两条蓝线之间的部分（即不超过 $MaxRight$ 的部分）是回文的，于是从这个长度开始，尝试以i为中心向左右两边扩展，，直到左右两边字符不同，或者到达边界。 小结不论以上哪种情况，之后都要尝试更新MaxRight和pos，因为有可能得到更大的MaxRight。 具体操作如下： 令 $RL[i]=min\lbrace RL[2\times pos-i], MaxRight-i\rbrace$ 以 $i$ 为中心扩展回文串，直到左右两边字符不同，或者到达边界 更新 $MaxRight$ 和 $pos$ 情况二：$i$ 在 $MaxRight$ 右边如下图： 遇到这种情况，说明以 $i$ 为对称轴的回文串还没有任何一个部分被访问过，于是只能从 $i$ 的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新 $MaxRight$ 和 $pos$。 代码实现此处以 LeetCode 上的题为例： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); if (len &lt;= 1) return s; string str = preProcess(s); int n = str.size(), pos = 0, MaxRight = 0; vector&lt;int&gt; RL(n, 0); for (int i = 1; i &lt; n - 1; ++i) &#123; RL[i] = MaxRight &gt; i ? min(RL[2 * pos - i], MaxRight - i) : 1; while (str[i + RL[i]] == str[i - RL[i]]) ++RL[i]; if (i + RL[i] &gt; MaxRight) &#123; MaxRight = i + RL[i]; pos = i; &#125; &#125; int maxLen = 0, index = 0; for(int i = 1; i &lt; n - 1; ++i) &#123; if(RL[i] &gt; maxLen) &#123; maxLen = RL[i]; index = i; &#125; &#125; // 这里可以和上面并在一起 return s.substr((index - maxLen) / 2, maxLen - 1); &#125; //预处理字符串，abc预处理后变成$#a#b#c#^ string preProcess(const string &amp;s) &#123; int n = s.size(); string res; res.push_back('$'); res.push_back('#'); for(int i = 0; i &lt; n; i++) &#123; res.push_back(s[i]); res.push_back('#'); &#125; res.push_back('^'); return res; &#125; // 注：此处字符串预处理在头上加入 '$' 是为了方便处理 // 如果是空间瘤患者，直接在有关的地方减一就行了&#125;; 总结Manacher 算法其实可以算奇技淫巧吧，主要还是掌握它的思路，充分利用待求解问题的性质，从而降低求解的复杂度。这个也是在竞赛中会用到的技巧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode 刷题日志] LeetCode-3 无重复字符的最长子串]]></title>
    <url>%2F2018%2F08%2F12%2FLeetCode-%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97-LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[写在前面今天开始刷 LeetCode，虽然说里面都是大公司的面试题，但是作为一个 OIer，刷刷也无妨，还能够提高自己的代码能力。本来希望花个 3 天刷完 LeetCode，结果发现这是完全不可能的，今天就被很基础的第三题给卡住了…… LeetCode-3 题解——坑人的大水题 题目描述： 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例： 给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。 给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。 给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 [题解] 直接上代码，具体说明看注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; int maxLen = 0; int currLen = 0; // table 用于记录字符出现的次数，之所以设为 128 是为了适配 ASCII 码 int table[128], start = 0; // 全部初始化为 0 memset(table, 0, sizeof(table)); for (int i = 0; i &lt; s.length(); ++i) &#123; // 如果 ++table[s[i]] 为 2，则说明这个数在所选的子串中已经出现过了 // 当然这里还有好多写法 if (++table[s[i]] == 2) &#123; // 因为遇到重复的字符了，所以要先更新 maxLen if (currLen &gt; maxLen) maxLen = currLen; // 接下来查找重复的数字出现的地方，并且更新字串起始位置 // 这里可以优化：使用一个 map&lt;char, int&gt; // 或 table0[128] 来记录字符的出现位置 // 同时也可以与前面的 table 数组合并，既加快速度又减少空间 // 这里因为不需要（懒），所以就打了这个未优化的算法 // 有兴趣的读者可以去试一试优化算法。 for (int j = start; j &lt; i; ++j) &#123; if (s[j] == s[i]) &#123; table[s[j]] = 1; start = j + 1; break; // 因为最多出现一次，所以直接 break &#125; else &#123; // 没找到的话必须减小答案 --currLen; // 重置 table[s[j]] = 0; &#125; &#125; &#125; else ++currLen; // 没有重复就直接自加一 &#125; // 最后的判断必不可少 if (currLen &gt; maxLen) maxLen = currLen; return maxLen; &#125;&#125;;// 由于本人是一个 OIer，还是 Google 资深老粉丝，所以代码风格比较混搭（逃）。 那么，是什么卡了我那么长时间呢？一开始的代码遇到重复的字符，直接更新起始位置到当前字符，殊不知会有 abcdaefg 这种情况，于是一直 WA。论充分思考的重要性….. 总结LeetCode 的题目难度并不是很大的，很多题差不多是提高-的难度，但是细节太多，同时对代码能力的要求比较高，某些数据结构也与 OI 中所写地不太一样。但是当作算法训练场来做也没什么坏处。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[算法] RMQ 问题与 ST 算法]]></title>
    <url>%2F2018%2F08%2F11%2F%E7%AE%97%E6%B3%95-RMQ-%E9%97%AE%E9%A2%98%E4%B8%8E-ST-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面因为很多次模拟测试都败在区间最值问题（RMQ）上，所以决定开一篇博客好好总结一下。本篇文章着重介绍 RMQ 问题中最著名的 ST 算法。 RMQ 问题给定一个长度为 $N$ 的数列 $A$，然后进行若干次询问，每次给定一个区间 $[l_i,r_i]$ 求这个区间中的最大或最小值，这就是区间最值问题，也就是 RMQ 问题。一般来说，这样的问题都要求区间的查询是在线的，也就是提出一个查询回答一次，不能全部收到后统一回答。对于某些确定区间求最值的问题，通常采用倍增的方法来求解。而 ST 算法其实就是倍增的产物，同时加入了动态规划的思想。 ST 算法在 RMQ 问题中，ST 算法可以在 $O(NlogN)$ 的时间预处理数据后，以 $O(1)$ 的时间在线回答查询。一个序列的子空间个数显然有 $O(N^2)$ 个，我们首先在这个规模为 $O(N^2)$ 的状态空间中选择一些 $2$ 的整数次幂的位置作为代表值。 设 $F[i,j]$ 表示子空间 $A$ 中下标在在子区间 $[i,i+2^j-1]$ 里数的最大值，即从 $i$ 开始的 $2^j$ 个数的最大值。显然 $F[i,0]=A[i]$，即数列 $A$ 在子区间 $[i,i]$ 中的最大值。 递推时，我们将子区间长度成倍增长，公式如下： $$F[i,j]=max\lbrace F[i,j-1],F[i+2^{j-1},j-1] \rbrace$$ 即长度为 $2^j$ 的子区间的最大值是左右两半长度为 $2^{j-1}$ 的子区间的最大值中较大的那一个。所以我们先预处理我们要用到的数组： 1234567void STprework() &#123; for (int i = 1; i &lt;= n; ++i) f[i][0] = a[i]; int t = log(n) / log(2) + 1; for (int j = 1; j &lt; t; ++j) for (int i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; ++i) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125; 当我们要查询区间 $[l,r]$ 的最值时，我们先计算出一个 $k$，满足 $2^k &lt; r-l+1 \leqslant 2^{k+1}$，也就是使二的 $k$ 次幂小于区间长度的前提下最大的 $k$。那么“从 $l$ 开始的 $2^k$ 个数”和“以 $r$ 结尾的 $2^k$ 个数” 这两段一定覆盖了原来的整个区间，这两段的最大值分别为 $F[l,k]$ 和 $F[r-2^k+1,k]$，二者中较大的就是整个区间的最值。因为求的是最大值，所以只要覆盖区间就行，重叠是没有关系的。 1234int STquery(int l, int r) &#123; int k = log(r - l + 1) / log(2); return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);&#125; 如果要进一步提高执行效率，可以将 $f$ 数组的两个维度交换，这样对缓存更加友好。并且可以预处理出 $1 \thicksim n$ 中 $log_2 n$ 的值，甚至是各个区间对应的 $k$ 的值，具体方法视情况而定。 总结 为什么使用 log() 函数而不是 log2() 呢，原因是前者效率更快，而且众所周知，对数是有换底公式的（啥？你不知道？赶紧补一下高中数学必修一吧！），所以这里效率会高一点 ST 表的模板题地址——洛谷 p3865 附上完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define max(a, b) (a &gt; b ? a : b)#define G(a) putchar(a + 48)int n, m, A[maxn];int li, ri;int f[21][maxn];int logn[maxn];inline int read() &#123; int ans = 0; char c; bool sign = false; while (!isdigit(c = getchar()) &amp;&amp; c != '-'); if (c == '-') &#123; sign = true; c = getchar(); &#125; do &#123; ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + (c - '0'); &#125; while (isdigit(c = getchar())); return sign ? -ans : ans;&#125;inline void write(int s)&#123; if (s &lt; 0) &#123; G(-3); s = -s; &#125; if (s &gt; 9) write(s / 10); G(s % 10);&#125;void STprework() &#123; for (int i = 1; i &lt;= n; ++i) f[0][i] = A[i]; int t = logn[n] + 1; for (int j = 1; j &lt; t; ++j) for (int i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; ++i) f[j][i] = max(f[j - 1][i], f[j - 1][i + (1 &lt;&lt; (j - 1))]);&#125;int STquery(int l, int r) &#123; int k = logn[r - l + 1]; return max(f[k][l], f[k][r - (1 &lt;&lt; k) + 1]);&#125;void pre() &#123; logn[1] = 0; logn[2] = 1; for (int i = 3; i &lt;= n; ++i) logn[i] = logn[i / 2] + 1;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) A[i] = read(); pre(); STprework(); for (int i = 1; i &lt;= m; ++i) &#123; li = read(); ri = read(); write(STquery(li, ri)); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>RMQ 问题</tag>
        <tag>ST 算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论] 图论基础知识]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%9B%BE%E8%AE%BA-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[写在前面因为自己的图论其实掌握得不怎么样，所以开一篇博客，来加深一下自己图论的基础。注意，本文只是基础，主要普及图的存储，最短路和遍历（$DFS$ 和 $BFS$）。 定义在图论中，我们定义一张图为由顶点集（Vertices）和边集（Edges）组成的二元组，即 $G = (V, E)$。此处 $V$ 和 $E$ 也可写为 $V(G)$ 和 $E(G)$。 基本术语阶（Order）：图 $G$ 中顶集 $V$ 的大小称作图 $G$ 的阶。 子图（Sub-Graph）：图 $G’$ 称作图 $G$ 的子图如果 $V(G’)\subseteq V(G)$ 以及 $E(G’)\subseteq E(G)$。 生成子图（Spanning Sub-Graph）：指满足条件 $V(G’)=V(G)$ 的 $G$ 的子图 $G’$。 度（Degree）是一个顶点的度是指与该顶点相关联的总边数，顶点 $v$ 的度记作 $d(v)$。度和边有如下关系：$\sum_{v\in V} d(v)=2\left|E\right|$。 出度（Out-degree）和入度（In-degree）：对有向图而言，顶点的度还可分为出度和入度。一个顶点的出度为 $d_o$ ，是指有 $d_o$ 条边以该顶点为起点，或说与该点关联的出边共有 $d_o$ 条。入度的概念也类似。 自环（Loop）：若一条边的两个顶点相同，则此边称作自环。 路径（Path）：从顶点u到顶点v的一条路径是指一个序列 $v_0,e_1,v_1,e_2,v_2,…e_k,v_k$，$e_i$ 的起点终点为 $v_{i-1}$ 及 $v_i$； $k$ 称作路径的长度； $v_0=u$，称为路径的起点；$v_k=v$，称为路径的终点。如果 $u=v$，称该路径是闭的，反之则称为开的；如果 $v_1,…,v_k$ 两两不等，则称之为简单路径（Simple path，注意， $u=v$ 是允许的）。 行迹（Trace）：如果路径 $P(u,v)$ 中边各不相同，则该路径称为 $u$ 到 $v$ 的一条行迹。 轨道（Track）：即简单路径。 闭的行迹称作回路（Circuit），闭的轨道称作圈（Cycle）。（现存文献中的命名法并无统一标准。比如在另一种定义中，walk 对应上述的 path，path 对应上述的 track，trail对应上述的 trace。） 距离（Distance）：从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称作从 $u$ 到 $v$ 的距离。若从 $u$ 到 $v$ 根本不存在路径，则记该距离为无穷（$\infty$）。 桥（Bridge）：若去掉一条边，便会使得整个图不连通，该边称为桥。 编程实现图的存储邻接矩阵存图12345678910111213#define maxn 100#define INF 0x3fint g[maxn][maxn];void init() &#123; memset(g, INF, sizeof(g)); &#125; // 初始化void addEdge(int vertex1, int vertex2, int wieght) &#123; g[vertex1][vertex2] = weight;&#125; // 添加一条单向边void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // 添加一条双向边 / 无向边 其中 $g[i][j]$ 表示从 $i$ 到 $j$ 的边的权。注意邻接矩阵方便使用，但空间复杂度为 $O(n^2)$，在点比较多的时候不太实用，极有可能会爆。 邻接表存图先上代码： 1234567891011121314151617181920212223242526272829#define maxn 11000#define maxm 21000#define NOE -1int v[maxm], e[maxm], heads[maxn], nxt[maxm]int tot = 0;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;// 初始化void addEdge(int vertex1, int vertex2, int weight) &#123; tot++; v[tot] = vertex2; e[tot] = weight; nxt[tot] = heads[vertex1]; heads[vertex1] = tot;&#125; // 加边void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // 加双向边void travel(int x) &#123; for (int i = heads[x]; i != NOE; i = nxt[i]) &#123; int y = v[i]; int x = e[i]; // 找到一条有向边 (x, y) 边权为 z // do something here &#125; // 遍历从 x 出发的边&#125; $v[]$ 和 $e[]$ 记录了每条边的终点和边权，$nxt[]$模拟指针，表示从想同节点出发的下一条边在 $v[]$ 和 $e[]$ 中的存储位置，$heads[i]$ 表示从 $i$ 出发的第一条边。信息奥赛中使用数组模拟指针足够了，如果想知道具体的邻接表的相关知识看这里：Wikipedia 链式前向星个人认为最好的存图方式，虽然与邻接表没有太大区别，但是好写多了（与真正的邻接表对比，不是 OI 中的阉割版）。 12345678910111213141516171819202122232425262728293031323334#define maxn 11000#define maxm 21000#define NOE -1struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125;;edgeNode edges[maxm];int heads[maxn];int numEdges = 0;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125; // 加边void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // 加双向边void travel(int x) &#123; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; int z = edges[i].weight; // 找到一条有向边 (x, y) 边权为 z // do something here &#125; // 遍历从 x 出发的边&#125; 多写写就会熟悉了。 图的遍历深度优先遍历 DFS深度优先搜索法是树的先序遍历的推广，它的基本思想是：从图 $G$ 的某个顶点 $v_0$ 出发，访问 $v_0$，然后选择一个与 $v_0$ 相邻且没被访问过的顶点 $v_i$ 访问，再从 $v_i$ 出发选择一个与 $v_i$ 相邻且未被访问的顶点 $v_j$ 进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点 $w$，从 $w$ 出发按同样的方法向前遍历，直到图中所有顶点都被访问。具体实现如下： 12345678910bool visited[maxn];void initDFS() &#123; memset(visited, false, sizeof(visited)); &#125;void rDFS(int x) &#123; visited[x] = true; visit(); // 根据具体情况定义 visit() for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) if (!visited[edges[i].vertexTo]) rDFS(edges[i].vertexTo); return; // 最好加上 return&#125; // 因为这是递归实现的，故命名为 rDfS $DFS$ 全称为 $Depth$ $First$ $Search$，其实是一个搜索算法，有关搜索的算法，未来会开个专题详细讲解，通俗的语言概括就是不顾一切向前冲，撞墙了再回头。 对于下面这么一张图： 它的遍历方式如下： 遍历顺序：$$v_1 \rightarrow v_2 \rightarrow v_4 \rightarrow v_8 \rightarrow v_5 \rightarrow v_3 \rightarrow v_6 \rightarrow v_7$$ $DFS$ 还是很常用的，属于必备知识。 广度优先遍历 BFS图的广度优先搜索是树的按层次遍历的推广，它的基本思想是：首先访问初始点 $v_i$，并将其标记为已访问过，接着访问 $v_i$ 的所有未被访问过的邻接点 $v_{i1},v_{i2},…,v_{it}$，并均标记已访问过，然后再按照 $v_{i1},v_{i2},…,v_{it}$的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点 $v_i$ 有路径相通的顶点都被访问过为止。非递归实现如下： 123456789101112131415161718192021222324queue&lt;int&gt; Q;int dep[maxn];void initBFS() &#123; memset(dep, 0, sizeof(dep)); while (!Q.empty()) Q.pop();&#125;void BFS() &#123; Q.push(1); dep[1] = 1; // dep[i] 表示节点 i 的深度，即从 1 到 i 需要走过的最少点数 while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; if (dep[y]) continue; // 这里直接使用 dep[] 来替代 visited[]，顺便求出点的深度 dep[y] = dep[x] + 1; Q.push(y); &#125; &#125;&#125; 对于下面这么一张图： 它的遍历方式如下： 遍历顺序：$$v_1\rightarrow v_2\rightarrow v_3\rightarrow v_4\rightarrow v_5\rightarrow v_6\rightarrow v_7\rightarrow v_8$$ 最短路径算法Floyd 求多源最短路Floyd 的本质是动态规划，我们令 $D[i,j,k]$ 表示经过若干个编号不超过 $k$ 的节点，从 $i$ 到 $j$ 的最短路径的长度。该问题可以划分成两个子问题，经过编号不超过 $k-1$ 的节点从 $i$ 到 $j$，或者从 $i$ 先到 $k$ 再到 $j$，于是我们写出动态规划方程： $$D[i,j,k]=min\lbrace D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]\rbrace$$ 注意，$k$ 是阶段，所以必须置于外层循环中，$i$ 和 $j$ 是附加状态，所以置于内层循环。 与背包问题类似，我们可以忽略 $k$ 这一维，于是我们有： $$D[i,j]=min\lbrace D[i,j],D[i,k]+D[k,j]\rbrace$$ $D[i,j]$ 保存了从 $i$ 到 $j$ 的最短路的长度 实现代码如下： 12345678910111213141516171819202122232425#define maxn 310#define INF 0x3fint d[maxn][maxn], n, m;int x, y, x;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(d, INF, sizeof(d)); for (int i = 1; i &lt;= n; ++i) d[i][i] = 0; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; d[x][y] = min(d[x][y], z); &#125; // 初始化 &amp; 输入 for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); // Floyd 求最短路 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cout &lt;&lt; d[i][j] &lt;&lt; " "; // 输出&#125; 一般来说，在数据小的时候可以使用 Floyd 算法，数据大的时候尽量去思考别的方法。 Dijkstra 求单源最短路Dijkstra 算法流程如下： 初始化 $dist[1] = 0$，其余节点初始化为一个极大值。 找出一个未被标记的，$dist[x]$ 最小的节点 $x$，然后标记节点 $x$。 扫描节点 $x$ 的所有出边 $(u, v, w)$，若 $dist[v] &gt; dist[u] + w$，则使用 $dist[u] + w$ 更新 $dist[v]$ 重复 $2 \thicksim 3$ 两个步骤，直到节点全部被标记。 Dijkstra 算法基于贪心，只适用于边权非负的图。优化：使用二叉堆对 $dist$ 进行维护，$O(\log n)$ 的时间获取最小值并删除，$O(\log n)$ 的时间执行一条边的扩展和更新，最终在 $O((m+n) \log n)$ 的时间内完成 Dijkstra。 实现代码如下： 12345678910111213141516171819202122232425262728293031// 关于图的定义部分这里省略struct heapNode &#123; int u, d; bool operator&lt;(const heapNode&amp; b) const &#123; return d &gt; b.d; &#125;&#125;// 注意，为了建立小根堆，此处重载的运算符有一点不同。// 可以通俗地理解为：如果到 b 的距离比到 u 的距离小，那么 b 的优先级比 u 高。priority_queue&lt;heapNode&gt; Q; // 使用优先队列建立小根堆。int dist[maxn]; // 记录从 x 到 各点的最短距离void Dijkstra(int x) &#123; while (!Q.empty()) Q.pop(); for (int i = 1; i &lt;= n; ++i) dist[i] = INF; dist[x] = 0; // 到自己的距离为 0 Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int d = f.d; if (d != dist[u]) continue; for (int i = heads[u]; i != NOE; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[u] + w) &#123; dist[j] = dist[u] + w; Q.push()((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125; Bellman-Ford 及 SPFA 算法给定一张有向图，若对于图中的某一条边 $(x,y,z)$，有 $dist[y] \leqslant dist[x]+z$ 成立，则称该边满足三角形不等式。若所有的边都满足三角形不等式，则 $dist$ 数组就是所求的最短路。 首先介绍基于迭代思想的 Bellman-Ford 算法。它的流程如下： 扫描所有的边 $(x,y,z)$，若 $dist[y] &gt; dist[x]+z$，则用后者更新它。 重复上述步骤，直到没有操作发生。 Bellman-Ford 的时间复杂度为 $O(nm)$。 而 SPFA 实际上是队列优化的 Bellman-Ford 算法，这是国际上的通称。SPFA 的算法流程大致如下： 建立一个队列，最初队列中只含有起点 $1$。 取出队头结点 $x$，扫描它的所有出边 $(x, y, x)$，若 $dist[y] &gt; dist[x]+z$，则用后者更新前者，同时若 $y$ 不在队列中，则把 $y$ 入队。 重复上述步骤，直到队列为空。 SPFA 中的队列避免了 Bellman-Ford 中对不需要扩展的节点的冗余扫描，在稀疏图上的运行效率较高，为 $O(km)$ 级别，$k$ 是一个较小的常数，而在稠密图或特殊构造的网格图上，算法仍可能退化为 $O(nm)$，这也是很多人说 SPFA 算法玄学的原因。但是在遇到负边权的时候，只能够使用 SPFA。 SPFA 的实现： 12345678910111213141516171819202122232425262728int dist[maxn];bitset&lt;maxn&gt; inq; // 记录是否在队列中queue&lt;int&gt; Q;void SPFA(int x) &#123; memset(dist, INF, sizeof(dist)); dist[x] = 0; Q.push(x); inq[x] = true; int k; while (!Q.empty()) &#123; k = Q.front(); Q.pop(); inq[k] = false; if (dist[k] == INF) continue; for (int i = heads[k]; i != NOE; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[k] + w) &#123; dist[j] = dist[k] + w; if (!inq[j]) &#123; Q.push(j); inq[j] = true; &#125; &#125; &#125; &#125;&#125; 如果不是处理负边权的图的话， SPFA 尽量不要用，原因嘛……它太玄了。]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>图的遍历</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Floyd</tag>
        <tag>Bellman-Ford</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 2018-8-8 题解: 爆零日，我该何去何从...]]></title>
    <url>%2F2018%2F08%2F08%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-8-%E9%A2%98%E8%A7%A3-%E7%88%86%E9%9B%B6%E6%97%A5%EF%BC%8C%E6%88%91%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%2F</url>
    <content type="text"><![CDATA[写在前面今天的题似乎是 Day1 的题，然而却是压力山大，从第一题开始就崩，第二题考场上无脑 Dijkstra 求最短路，第三题更是懵逼（考后听说用 Dancing Link 做的时候彻底崩溃），总之，今天四十分，与爆零相差无几，所以这次在写题解的同时，还是会写一点考试技巧的，尤其是第一题和第二题（原谅我知识水平实在不够，对第三题仍然懵逼）。 T1 动态仙人掌(dinosaur.cpp/c/pas)——玩了这么多次小恐龙，没想到它还会报复我 [题目描述] 由于 Beny 做的烧网线实验，Fife 家断网了。Fife 照常打开了 Google Chrome，由于断网，他看到了以下内容： 看 到 这 个 简 单 而 又 有 趣 的 游 戏 ， 他 玩 了 起 来 。 然 后 ： Fife 永远没有 gameover，他觉得这个游戏太简单了，现在他想考考你。小恐龙在数轴上原点出发向右运动，速度为$1$个单位每秒。现在你知道每一个仙人掌的位置$p[i]$和高度$h[i]$，且没有怪鸟突袭，请你控制小恐龙跳跃，使它能跳过最后一个仙人掌且跳跃的最大高度最小。为了送温暖简化问题，跳跃满足以下规则：它的跳跃路线为严格的与地面夹角为$45$度的直线，它在平地上能随时起跳，它能在起点和落地时刻瞬间起跳。你能控制它起跳的时刻和下落的时刻，下落时它会沿与地面夹角为$45$度的直线下降。小恐龙能跳过一个仙人掌当且仅当它在这个仙人掌的位置时的高度大于等于仙人掌的高度。 [输入] 第 1 行 1 个正整数 n 接下来 n 行每行两个正整数 p[i]和 h[i],为第 i 个仙人掌的位置和高度， 不保证 p[i]单调递增， 可能会有两个仙人掌在同一位置。 [输出] 你需要控制小恐龙跳跃，使它能跳过所有仙人掌，且跳跃的最大高度最小， 输出这个高度， 保留 1 位小数，如果无解，输出-1 [样例输入] 5 5 2 9 3 13 2 19 3 20 1 [样例输出] 6.0 [数据规模] 对于 30%的数据：n&lt;=200, p[i] &lt;= 1000, h[i] &lt;= 100 对于 60%的数据：n&lt;= 50000, p[i] &lt;= 3000000, h[i] &lt;= 500 对于 100%的数据：n &lt;= 300000, p[i] &lt; 2^31, h[i] &lt;=40000, 数据保证无需使用 longlong 或 int64 [题解] 看到这是第一道题，心想，这一定很简单，只要贪心就行了，一堆判断，然后信心满满地提交……最后只对了一个点……此处附上 WA 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 310000#define max(a, b) (a &gt; b ? a : b)#define INF 0x3f3f3f3fint n, p[maxn], h[maxn];bitset&lt;maxn&gt; goDown;double ans = -INF;void init() &#123; goDown.set(); memset(h, 0, sizeof(h)); p[0] = 0;&#125;void judgeDown(int i) &#123; if (h[i] &gt;= h[i + 1] + p[i + 1] - p[i]) goDown[i] = 1; else if (h[i] + h[i + 1] &lt;= p[i + 1] - p[i]) goDown[i] = 1; else goDown[i] = 0;&#125;bool judgeCan(int i) &#123; if (p[i] - p[i - 1] + h[i - 1] &lt; h[i]) return false; else return true;&#125;// 以上两个 judge 函数是 WA 之精髓所在（雾）// 只考虑了相邻两个仙人掌的关系，如果在下降的时候撞到另外一个仙人掌// 那么小恐龙就 GG 了double calh(int x, int y) &#123; if (h[x] &gt; h[y] + p[y] - p[x] &amp;&amp; x + 1 == y) return (double)h[x]; else return (double)(p[y] - p[x] + h[x] + h[y]) / 2.0;&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("dinosaur.in"); ofstream out("dinosaur.out"); in.tie(NULL); in &gt;&gt; n; init(); for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; p[i] &gt;&gt; h[i]; if (!judgeCan(i)) &#123; out &lt;&lt; -1; return 0; &#125; else continue; &#125; for (int i = 1; i &lt; n; ++i) judgeDown(i); int key = 1; double tmp; for (int i = 1; i &lt;= n &amp;&amp; key &lt;= n; ++i) &#123; if (goDown[i]) &#123; double tmp = calh(key, i); ans = max(ans, tmp); key = i + 1; if (p[i] + h[i] &gt; p[i + 1]) key += 1; &#125; &#125; out &lt;&lt; setprecision(1) &lt;&lt; fixed &lt;&lt; ans; return 0;&#125;// 这个实例告诉大家，贪心前先做好分析准备工作，否则就会像我这样...... 那么到底该怎么做呢？ 由于这是一只理（bian）想（tai）化过的小恐龙，它只会与地面呈$45$度跳跃，而且可以无限升天，法力无边，所以我们可以从每一个仙人掌的跳跃边界来考虑： 考虑两种不同的仙人掌情况： 那么就有两种做法了，第一种，删去所有像绿色仙人掌那样的仙人掌，然后直接计算；第二种，也是标程的方法，逐个进行判断，维护 first 和 last 这两个值，分别表示一组跳跃（一次上和一次下）的左右边界，然后计算。 [参考代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 注：本代码使用的是第二种方法// 使用第一种方法的同学可以使用类链表的方式来存储数据，加快效率#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 310000struct segment &#123; int l; int r; &#125;;int n, p, h;double ans = 0;segment a[maxn];bool compare(segment a, segment b) &#123; return a.l &lt; b.l || (a.l == b.l &amp;&amp; a.r &lt; b.r);&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("dinosaur.in"); ofstream out("dinosaur.out"); in.tie(NULL); in &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; p &gt;&gt; h; a[i].l = p - h; a[i].r = p + h; &#125; sort(a + 1, a + n + 1, compare); if (a[1].l &lt; 0) &#123; cout &lt;&lt; -1; return 0; &#125; int last = a[1].r; int first = a[1].l; for (int i = 2; i &lt;= n; ++i) &#123; if (a[i].l &lt; last) last = max(last, a[i].r); else &#123; ans = max(ans, (last - first) * 1.0 / 2.0); first = a[i].l; last = a[i].r; &#125; &#125; ans = max(ans, (last - first) * 1.0 / 2.0); out &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; ans; return 0;&#125; [评价] 其实思维难度并不大，主要是考验对算法是否掌握到位，譬如用贪心，这道题并不能从头贪到尾，那样会出问题，必须考虑所有可能情况，这也是本题样例的坑人之处所在，以后考试时，如果只有一个样例，那必须得小心出题老师出阴招，最好是自己脑滚键盘来出几个数据手算测试一下。 T2 相交(inter.cpp/c/pas)——旧时 Dijkstra 堂前 O(mlog n)，飞入寻常 NOIER 家。 [题目描述] 一棵大树下有$n$个巢穴，由$n-1$条双向道路连接，任意两个城市均可互相到达。大树附近有两群蚂蚁，每天早上，第一群蚂蚁会派一只蚂蚁到这棵树下，并在第$a$个巢穴到第$b$ 个巢穴间的最短路径上的每个巢穴留下气味。每天傍晚，第二群蚂蚁会派一只蚂蚁到这棵树下，并侦查第$c$个巢穴到第$d$个巢穴间的最短路径上是否有蚂蚁留下的气味。每天蚂蚁留下的气味会在当天深夜消失。 [输入] 第一行一个正整数 n，含义如题所示。 接下来 n-1 行，每行两个正整数 u,v，表示第 u 个巢穴和第 v 个巢穴间有一条双向道路。 接下来一行一个正整数 q，表示天数。 接下来 q 行，每行四个正整数 a,b,c,d，含义如题所示。 [输出] q 行，每行一个字符串。 若第二群派出的蚂蚁侦查到蚂蚁留下的气味，则输出”YES”,否则输出”NO” [样例输入] 样例输入 1 8 1 2 1 3 2 4 2 5 5 6 5 7 3 8 4 2 5 4 3 5 3 8 8 5 4 6 7 4 8 6 7 样例输入 2 15 2 1 3 1 4 2 5 3 6 2 7 2 8 5 9 3 10 6 11 5 12 7 13 11 14 1 15 1 5 1 2 3 4 4 7 1 9 2 3 7 9 2 6 7 8 2 1 6 8 [样例输出] 样例输出 1 YES NO YES NO 样例输出 2 YES NO YES YES YES [数据规模] 对于 30%的数据 1&lt;=n,q&lt;=3000 对于另外 20%的数据 第 i 条边连接第 i 个巢穴和第 i+个巢穴 对于 100%的数据 1&lt;=n,q&lt;=100000 [题解] 首先讲一下我考试的时候是怎么想的，我想既然是最短路径，还是个图（当时没看出是树），那么 Dijkstra 无疑了，潇潇洒洒一百行打完，用了两个 bitset 再用了一个神奇的方法记录路径。好！就是这样，一定 AC 了！结果：TLE……附上 Dijkstra 暴力代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define maxq 110000#define NOE -1#define INF 0x3f3f3f3fstruct edgeNode &#123; int vertexFrom; int vertexTo; int edgeNext; bool weight;&#125;;struct heapNode &#123; int u, d; bool operator&lt;(const heapNode&amp; b) const &#123; return d &gt; b.d; &#125;&#125;;edgeNode edges[maxn];int heads[maxn];int numEdges = 0;int n, q, u, v, a, b, c, d;bool judge = true;bitset&lt;maxn&gt; smell1;bitset&lt;maxn&gt; smell2;int path[maxn];int dist[maxn];priority_queue&lt;heapNode&gt; Q;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexFrom = vertex1; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = true; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1);&#125;void Dijkstra(int x) &#123; while (!Q.empty()) Q.pop(); for (int i = 1; i &lt;= n; ++i) dist[i] = INF; for (int i = 1; i &lt;= n; ++i) path[i] = i; dist[x] = 0; Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int dis = f.d; if (dis != dist[u]) continue; for (int i = heads[u]; i != NOE; i= edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[u] + w) &#123; dist[j] = dist[u] + w; path[j] = u; // 记录路径 Q.push((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125;void updateSmell1(int a, int b) &#123; int tmp = b; while (tmp != a) &#123; smell1[tmp] = 1; tmp = path[tmp]; &#125;&#125;void updateSmell2(int c, int d) &#123; int tmp = d; while (tmp != c) &#123; smell2[tmp] = 1; tmp = path[tmp]; &#125;&#125;int main() &#123; freopen("inter.in", "r", stdin); freopen("inter.out", "w", stdout); // fstream 不知怎么就不能取消 sync_with_stdio，为了加快速度只能使用 freopen init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n - 1; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addDuplexEdge(u, v); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; smell1.reset(); smell2.reset(); scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); if ((a == c &amp;&amp; b == d) || (a == d &amp;&amp; b == c)) &#123; printf("YES\n"); continue; &#125; smell1[a] = 1; smell2[c] = 1; // TLE TLE TLE TLE TLE TLE TLE TLE TLE TLE TTTTTTLLLLLLEEEE Dijkstra(a); updateSmell1(a, b); Dijkstra(c); updateSmell2(c, d); // TLE TLE TLE TLE TLE TLE TLE TLE TLE TLE TTTTTTLLLLLLEEEE judge = (smell1 &amp; smell2).any(); if (judge) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 其实如果看出了这是棵树的话，是可以用广搜的……可以快不少。 好了，说正解：就像上面所说的，这是一棵树（啥？你问我怎么看出的？仔细读题！！），所以获取最短距离一定是求两个点的 $LCA$ 了。那如何标记呢？？这是个好问题，一般我们都会去想标记经过的点，然而，如果用倍增 $LCA$ 求，一定会跳过经过的点，如果用朴素算法求的话……那还不如 $BFS$，那么我们就必须使用另外的方法了。 首先我们画一棵树： 通过观察和举例，我们发现，只有当 $a$ 和 $LCA(c, d)$ 在同一条链上，且 $LCA(a, b)$ 也在这条链上； $b$ 和 $LCA(c, d)$ 在同一条链上，且 $LCA(a, b)$ 也在这条链上； $c$ 和 $LCA(a, b)$ 在同一条链上，且 $LCA(c, d)$ 也在这条链上； $d$ 和 $LCA(a, b)$ 在同一条链上，且 $LCA(c, d)$ 也在这条链上； 以上四者满足其一时才能够是 YES，否则就是 NO。 为什么是这样？如何实现呢？首先思考：到达$a$，$b$两点必定经过它们的 $LCA$，那么，只要它们两点与另外两点的 $LCA $在一条链上（这个不是很严谨，这里的链指的是将树看成 $DAG$ 时，即若 $LCA(u, v) = v$ 时，$u$，$v$在一条链上），且它们两个点的 $LCA$ 深度比另外两点的深度小时，两条路径必有重叠的部分（如图，$d$与 $LCA(a, b)$ 在一条链上，且 $LCA(a, b)$ 的深度比 $LCA(c, d)$ 的深度大，所以两者路径必有交集） 如此分析，代码也就呼之欲出了。 [参考代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define NOE -1struct edgeNode &#123; int vertexTo; int edgeNext;&#125;;edgeNode edges[maxn &lt;&lt; 1];// 注意由于是无向边，而前向星只能按照双向边处理，所以要乘二int heads[maxn];int numEdges = 0;int f[maxn][20], dep[maxn];int n, q, u, v, a, b, c, d;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1);&#125;void rDFS(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 18; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) if (edges[i]. vertexTo != fa) rDFS(edges[i].vertexTo, x);&#125;int LCA(int u, int v) &#123; for (int i = 18; i &gt;= 0; --i) if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; for (int i = 18; i &gt;= 0; --i) if (dep[f[v][i]] &gt;= dep[u]) v = f[v][i]; if (u == v) return u; for (int i = 18; i &gt;= 0; --i) if (f[u][i] != f[v][i]) &#123; u = f[u][i]; v = f[v][i]; &#125; return f[u][0];&#125;// 找 LCAbool inOneChain(int u, int v, int w) &#123; return (LCA(u, w) == w) &amp;&amp; (dep[w] &gt;= dep[v]); // 判断链和深度关系&#125;bool judge(int a0, int b0, int c0, int d0) &#123; int lca1 = LCA(a0, b0); int lca2 = LCA(c0, d0); return (inOneChain(a0, lca1, lca2) || inOneChain(b0, lca1, lca2) || inOneChain(c0, lca2, lca1) || inOneChain(d0, lca2, lca1)); // 四者只要满足其一就会有交集，所以取或就行&#125;int main() &#123; freopen("inter.in", "r", stdin); freopen("inter.out", "w", stdout); // 我也不知道为什么，fstream 一关掉同步就会崩，无奈只能用 freopen scanf("%d", &amp;n); init(); // 循环时 i 只能到 n - 1，还是提醒仔细读题 for (int i = 1; i &lt; n; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addDuplexEdge(u, v); &#125; memset(f, 0, sizeof(f)); // 别忘记初始化 rDFS(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); if (judge(a, b, c, d)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; [评价] 思维难度较大，想到求交集的方法后仍然要画很多图来总结规律，否则规律很有可能是错误的或者是片面的。再次提醒仔细读题，因为题目中包含了很多隐藏条件，这些隐藏条件也尤为重要，不管是对正解还是对暴力朴素算法来说，都可以提高效率。这是一道难题，还是一道坑题。 T3 聪明格(kenken.cpp/c/pas)[题目描述]聪明格是一种数字游戏，又堪称升级版的数独，诞生日本。它在数学上的要求比数独要高得多，它把数独规则与加减乘除四则运算相结合，使大脑在各种谜题中来回穿梭。 它的规则是这样的：有一个 $n\times n$ 的棋盘，每个格子里填一个在 1~n 范围内的数，使得每行每列没有重复的数字，(即 1~n 每个数在每行和每列各出现一次)，且满足下列条件: 现在给你一个 $n\times n$ 的棋盘，让你完成它，并输出解的个数和字典序最小的方案。数据保证一定有解。 [输入] 第一行一个正整数 n，表示棋盘的行数和列数。 接下来 n 行，每行 n 个正整数。表示：相同数字构成了许多个连通块， 假设这个四连通块内每个数字都为 a,那么你在这些格子上填的数的乘积 应该等于 a。（具体描述见样例） [输出] 输出共 n+1 行，第一行输出解的个数 接下来 n 行，每行 n 个正整数。表示 n*n 的矩阵里每个数字的值 （字典序最小的方案）。 [输入样例 1] 4 6 6 1 144 6 2 144 144 4 2 144 4 12 12 4 4 注：此样例所对应 4*4 的棋盘即为上图。 [输出样例 1] 1 2 3 1 4 1 2 4 3 4 1 3 2 3 4 2 1 [输入样例 2] 3 12 12 18 12 12 18 18 18 18 [输出样例 2] 4 1 2 3 2 3 1 3 1 2 [输入样例 3] 9 32353542 4254 54 544 322735576 10108108 1084 927576576 1040 40 1008 1008 9270576576 814 14 1008 1008 142702705768105 3283 14426882727 105 32810 302688268880 6105 63 6310 30 2688 12680 8024 3 639 66126126 126 24 24 40 40 [输出样例 3] 1 8 1 5 6 7 9 2 3 4 4 3 7 8 5 6 9 2 1 1 9 4 3 2 8 5 6 7 9 5 3 1 8 2 7 4 6 7 6 9 2 1 5 4 8 3 2 4 6 9 3 7 8 1 5 5 7 8 4 6 3 1 9 2 6 8 2 5 4 1 3 7 9 3 2 1 7 9 4 6 5 8 [数据规模] 测试点 n= 输入矩阵中不同种类数字个数 1-2 3 &gt;=3 3-4 5 &gt;=10 5-7 9 &gt;=30 8-10 9 &gt;=20 100% 的数据满足，矩阵中每个数字&lt;=100,000，合法棋盘个数（解的个数）&lt;=300 [题解] 这里先不多说了，关于舞蹈链我在后面的博客中会详细讲解，此处直接贴标程。 [参考代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std; const int N=11,M=510;const int dx[4]=&#123;1,0,-1,0&#125;;const int dy[4]=&#123;0,1,0,-1&#125;;struct node2&#123; int c[N][N]; &#125; ans[M];bool operator&lt; (node2 x,node2 y)&#123; for(int i = 1; i &lt; N; i++) for(int j = 1; j&lt;N; j++) if(x.c[i][j] != y.c[i][j]) return x.c[i][j] &lt; y.c[i][j]; return 0;&#125;struct node&#123; int x, y; &#125;;vector&lt;node&gt; b[N * N];vector&lt;int&gt; p[N * N]; int a[N][N], c[N][N], h[N][N], h1[N][N], h2[N][N];int n, cnt = 0, tot = 0;int read() &#123; int x = 0, f = 1; char c = 0; for (; !isdigit(c); c=getchar()) if(c == '-') f = -1; for (; isdigit(c); c=getchar()) x = x * 10 + c - 48; return x * f;&#125;int factor(int x) &#123; int t = 0; for (int i = 1; i * i &lt;= x; i++) t += (int)(x % i == 0); return t;&#125;bool cmp(vector&lt;node&gt; x, vector&lt;node&gt; y) &#123; if (x.size() == y.size()) return factor(x[0].x) &lt;= factor(y[0].x); return x.size() &lt; y.size();&#125;void divide(int t, int x)&#123; for (int i = 1; i &lt;= n; i++) if (x % i == 0) p[t].push_back(i);&#125;void dfs(int x, int y) &#123; h[x][y] = 1; b[cnt].push_back((node)&#123; x, y &#125;); for (int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i]; int ty = y + dy[i]; if (tx &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= n &amp;&amp; !h[tx][ty] &amp;&amp; a[tx][ty] == a[x][y]) dfs(tx, ty); &#125;&#125;void work(int dep);void fillp(int t, int dep, int s, int tot) &#123; if (dep &gt; tot) work(t + 1); else &#123; int x=b[t][dep].x, y = b[t][dep].y; for (int i = 0; i &lt; p[t].size(); i++) &#123; int u=p[t][i]; if ((s == u || dep &lt; tot) &amp;&amp; s % u == 0 &amp;&amp; !h1[x][u] &amp;&amp; !h2[y][u])&#123; h1[x][u] = 1； h2[y][u] = 1; c[x][y] = u; fillp(t, dep + 1, s / u, tot); c[x][y] = 0; h1[x][u] = 0； h2[y][u]=0; &#125; &#125; &#125;&#125;void work(int dep) &#123; if (dep &gt; cnt) &#123; tot++; for (int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) ans[tot].c[i][j] = c[i][j]; &#125; else &#123; int num=b[dep][0].x； int tot=b[dep].size() - 1; fillp(dep, 1, num, tot); &#125;&#125;int main() &#123; freopen("kenken.in", "r", stdin); freopen("kenken.out", "w", stdout); n = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (!h[i][j]) &#123; cnt++; b[cnt].push_back((node)&#123; a[i][j], 0 &#125;); dfs(i, j); &#125; sort(b + 1, b + cnt + 1, cmp); for (int i = 1; i &lt;= cnt; i++) divide(i, b[i][0].x); work(1); cout &lt;&lt; tot &lt;&lt; "\n"; node2 t = ans[1]; for (int i = 2; i &lt;= tot; i++) t = min(t, ans[i]); for (int i = 1;i &lt;= n; i++)&#123; for (int j = 1; j &lt; n; j++) cout &lt;&lt; t.c[i][j] &lt;&lt; " "; cout &lt;&lt; t.c[i][n] &lt;&lt; "\n"; &#125; return 0;&#125; 本次考试总结Too young, too simple, sometimes naive……还是要提高知识水平和编程素养，防止考试时 GG。]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
        <tag>题解</tag>
        <tag>神题</tag>
        <tag>爆零日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论] 数论基础知识----莫比乌斯函数]]></title>
    <url>%2F2018%2F08%2F08%2F%E6%95%B0%E8%AE%BA-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面最近自己在自学数论，为了保证遇到数论的题的时候能从容不迫地应对，本篇文章主要是对莫比乌斯函数( $\mu{(n)}$ )的初步了解 莫比乌斯函数定义莫比乌斯函数 $\mu{(n)}$ 的定义如下： $$ \mu(1) = 1; $$ 如果 $n&gt;1$，写 $n=p_1^{a_1}p_2^{a_2}p_3^{a_3}…p_k^{a_k}$，则： $$\mu(n)=\begin{cases}(-1)^k &amp; \text{when $a_1=a_2=a_3=…=a_k=1$,}\\0 &amp; \text{otherwise.}\end{cases}$$ 注 $\mu(n)=1$当且仅当$n$有一个大于$1$的平方因子。 定理莫比乌斯函数在数论中经常出现（上次就被它狠狠地坑了一次），它的基本性质之一是对约束求和 $\sum_{d|n}\mu{(d)}$ 的一个重要的简明公式，它在$n$的正约数上展开，式子中的 $\left[x\right]$ 表示不大于$x$的最大整数。定理如下： [定理描述]如果${n}\geqslant{1}$，我们有$$\sum_{d|n}\mu{(d)}=\left[\frac{1}{n}\right]=\begin{cases}1 &amp;\text{when $n=1$,}\\0 &amp;\text{when $n&gt;1$.}\end{cases}$$ [定理证明]（运用了二项式定理）对于 $n=1$，等式显然成立。设 $n&gt;1$ 并写 $n=p_1^{a_1}…p_k^{a_k}$ ，在 $\sum_{d|n}\mu{(d)}$ 中非零的项仅来自于 $d=1$ 与 $n$ 的约数是不同素数的乘积，即$$\begin{aligned}\sum_{d|n}\mu{(d)}={}&amp; \mu(1)+\mu(p_1)+…+\mu(p_k)+\mu(p_1p_k)+…+{} \\&amp;\mu(p_{k-1}p_k)+…+\mu(p_1p_2…p_k){}\\={}&amp;1+\binom{k}{1}(-1)+\binom{k}{2}(-1)^2+…+\binom{k}{k}(-1)^k{}\\={}&amp;0\end{aligned}$$ 总结莫比乌斯函数本身其实并不难，但是要深刻地理解它还是有一点点困难的，以后会和别的有关函数结合起来进行讲解，加深记忆。]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 2018-8-7 题解: 我写了个自己都看不懂的程序]]></title>
    <url>%2F2018%2F08%2F07%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-7-%E9%A2%98%E8%A7%A3-%E6%88%91%E5%86%99%E4%BA%86%E4%B8%AA%E8%87%AA%E5%B7%B1%E9%83%BD%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[写在前面今天创历史新高$290$分，第三道题考完自己都没看出自己用了啥方法（Orz），感觉自已要去补数据结构……另外第一道题实在是坑……十分啊！！ T1 选举[题目描述] $C$国的总统选举委员会最近遇到了一些麻烦。 他们在统计各省对H先生的支持率（百分比）时，把支持率四舍五入到了整数。等他们公布结果后，该国媒体发现这些省份的支持率之和不等于$100$（百分比）！在媒体黑幕声的质疑下，他们不得不找你寻求帮助。 你将得到各省四舍五入后的支持率，请计算这些省份的支持率在四舍五入前的和是否可能等于100？支持率是以百分比的形式统计的。请注意，各省的支持率可以是一个包含任意多位的有限小数。一个小数在四舍五入到整数时，若小数点后第一位小于5则舍，大于等于5则入。 例如：$26,17,58$是一种可能的支持率，因为它们可能是$25.8,16.5,57.7$四舍五入后得到的，而$25.8+16.5+57.7=100$。$49,49$是一种不可能的支持率，因为当$9$的个数有限时，无论有多少个$9$，均有$49.499+…+99+49.499+…+99&lt;100$。 [输入格式] 输入包含多组数据，第一行是一个整数T，表示数据组数。 接下来是T组数据，每组数据的第一行是一个整数N，表示参与选举的省份个数。 第二行是N个整数，表示各省四舍五入后的支持率。 [输出格式] 对于每组数据，若是一种可能的支持率，输出Yes，否则输出No。 [样例输入] 2 2 49 49 3 26 17 58 [样例输出] No Yes [数据范围与约定] 对于30%的数据，1&lt;=n&lt;=3； 对于50%的数据，1&lt;=n&lt;=5； 对于80%的数据，1&lt;=四舍五入后各省的支持率&lt;=99； 对于100%的数据，1&lt;=n&lt;=10000，输入数据中的所有整数均在有符号16位整数范围内。 [题解] 简单数值计算题，直接讨论情况并计算即可。具体来讲，可以求出使用给出的$N$个支持率，最终可能的支持率的取值范围，检查该范围是否包含$100$。一般情况下，一个数X在取舍前可能取$[X-0,5,X+0.5)$之间的任意数值。需要注意$0$和$100$等边界问题，因为支持率（百分比）一定是一个$[0,100]$之间的数。求出的取值范围最好使用整数并加以开闭区间判断，避免实数精度误差。 [参考代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define int64 long longint T, n, x;int64 sum, l, r;int main() &#123; ios::sync_with_stdio(false); ifstream in("election.in"); ofstream out("election.out"); in.tie(NULL); in &gt;&gt; T; while (T--) &#123; in &gt;&gt; n; int cnt0 = 0, cnt100 = 0, flag = 0; sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; x; sum += x; if (x == 0) ++cnt0; if (x == 100) ++cnt100; if (x &gt; 100) flag = 1; &#125; if (flag) &#123; out &lt;&lt; "No" &lt;&lt; endl; continue; &#125; l = sum - (n - cnt0) / 2; r = sum + (n + cnt100) / 2; bool cond0 = (l &lt;= 100); bool cond1; if ((n - cnt100) &amp; 1 || (n - cnt100) == 0) cond1 = (r &gt;= 100); else cond1 = r &gt; 100; if (cond0 &amp;&amp; cond1) out &lt;&lt; "Yes" &lt;&lt; endl; else out &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125;// 注：这个其实是标程，连 double 都没有用 （Orz） [评价] 考察了基础的数学知识，只要搞清楚开区间和闭区间就好了。 T2 异象石[题目描述] Adera 是 Microsoft 应用商店中的一款解谜游戏。异象石是进入 Adera 中异时空的引导物，在 Adera 的异时空中有一张地图。这张地图上有$N$个点，有$N-1$条双向边把它们连通起来。起初地图上没有任何异象石，在接下来的$M$个时刻中，每个时刻会发生以下三种类型的事件之一： 地图的某个点上出现了异象石（已经出现的不会再次出现）； 地图某个点上的异象石被摧毁（不会摧毁没有异象石的点）； 向玩家询问使所有异象石所在的点连通的边集的总长度最小是多少。 请你作为玩家回答这些问题。 [输入格式] 第一行有一个整数N，表示点的个数。 接下来N-1行每行三个整数x,y,z，表示点x和y之间有一条长度为z的双向边。 第N+1行有一个正整数M。 接下来M行每行是一个事件，事件是以下三种格式之一： + x 表示点x上出现了异象石 - x 表示点x上的异象石被摧毁 ?表示询问使当前所有异象石所在的点连通所需的边集的总长度最小是多少。 [输出格式] 对于每个 ?事件，输出一个整数表示答案。 [样例输入] 6 1 2 1 1 3 5 4 1 7 4 5 3 6 4 2 10 + 3 + 1 ? + 6 ? + 5 ? - 6 - 3 ? [样例输出] 5 14 17 10 [数据范围与约定] 对于30%的数据，1 ≤ n, m ≤ 1000。 对于另20%的数据，地图是一条链，或者一朵菊花。 对于100%的数据，1 ≤ n, m ≤ 10^5, 1 ≤ x, y ≤ n, x ≠ y, 1 ≤ z ≤ 10^9。 [题解] 如果在$a_1,a_2…a_k$这些点上有异象石，则所需代价就是按照DFS序依次遍历这$k$个点再回到根的总距离。这个距离数还等于$a_1,a_2…a_k$排成一个环形序列，相邻两个点的距离之和。因此用set维护有异象石的点构成的DFS序，用一个全局变量记录答案，插入、删除时更新set的同时利用LCA算法更新答案。 [参考代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define NOE -1#define int64 long longint n, m, x, y, z, v;char op;set&lt;int&gt; s;int64 ans, dis[maxn], g[maxn];int cnt = 0;int f[maxn][20], dep[maxn], dfn[maxn], seq[maxn];struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125;;edgeNode edges[maxn &lt;&lt; 1];int heads[maxn &lt;&lt; 1];int numEdges = 0;inline void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;inline void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;inline void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125;inline void rDFS(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; dfn[x] = ++cnt; seq[cnt] = x; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int vt = edges[i].vertexTo; if (vt != fa) &#123; dis[vt] = dis[x] + edges[i].weight; rDFS(vt, x); &#125; &#125;&#125;inline void initFa() &#123; for (int i = 1; i &lt;= 19; ++i) for (int j = 1; j &lt;= n; ++j) f[j][i] = f[f[j][i - 1]][i - 1];&#125;inline int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); int t = dep[x] - dep[y]; for (int i = 0; i &lt;= 16; ++i) if (t &amp; (1 &lt;&lt; i)) x = f[x][i]; if (x == y) return x; for (int i = 16; i &gt;= 0; --i) &#123; if (f[x][i] != f[y][i]) &#123; x = f[x][i]; y = f[y][i]; &#125; &#125; return f[x][0];&#125;inline int64 getDist(int x, int y) &#123; return dis[x] + dis[y] - dis[LCA(x, y)] * 2;&#125;inline void find(int x, int &amp;l, int &amp;r) &#123; set&lt;int&gt;::iterator it = s.lower_bound(x); if (it != s.end()) r = *it; else r = *s.begin(); if (it == s.begin()) it = s.end(); l = *(--it); l = seq[l]; r = seq[r];&#125;inline void insert(int x) &#123; if (!s.empty()) &#123; int l, r; find(dfn[x], l, r); ans -= g[r]; g[x] = getDist(l, x); g[r] = getDist(x, r); ans += g[x] + g[r]; &#125; else g[x] = 0; s.insert(dfn[x]);&#125;inline void erase(int x) &#123; int l, r; s.erase(dfn[x]); if (!s.empty()) &#123; find(dfn[x], l, r); ans -= g[x] + g[r]; g[r] = getDist(l, r); &#125; ans += g[r];&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("stone.in"); ofstream out("stone.out"); in.tie(NULL); init(); in &gt;&gt; n; for (int i = 1; i &lt; n; ++i) &#123; in &gt;&gt; x &gt;&gt; y &gt;&gt; z; addDuplexEdge(x, y, z); &#125; rDFS(1, 0); initFa(); in &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; in &gt;&gt; op; switch (op) &#123; case '+' : &#123; in &gt;&gt; v; insert(v); break; &#125; case '-' : &#123; in &gt;&gt; v; erase(v); break; &#125; case '?' : &#123; out &lt;&lt; ans / 2 &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;// 这道题必须一次操作更新一次答案，否则会 TLE 此处附上 std::set 的用法 [评价] 对于没有做过的同学来说，思维难度还是比较大的，这种方法就直接记住就行了，要用的时候直接拿出来用。 T3 序列变换（本次重点！！！）[题目描述] 给定一个长度为$N$的数列$A_i$。你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。 [输入格式] 第一行是一个正整数N。 第二行是N个正整数Ai。 [输出格式] 输出一个整数，表示最少需要的操作次数。 [样例输入] 5 6 3 7 8 6 [样例输出] 2 [数据范围与约定] 对于30%的数据，满足1≤n≤10。 对于60% 的数据，满足1≤n≤1000。 对于100% 的数据，满足1≤n≤1000000，1≤Ai≤1000000。 [题解] 经过分析可以发现，最优解情况下，需要保持一个子序列不动，这个子序列满足： 子序列单调递增； 若子序列中最小数是$L$，最大数是$R$，则子序列必须包含$[L+1,R-1]$中的数列中的所有数。 用单调队列求出满足这两个条件的子序列的最大长度，用$n$减去就是答案。即这个子序列保持不动，其余数向前或后移动一次。 [参考代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 以下为 std 代码，不感兴趣的同学可以跳过#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;set&gt;using namespace std;const int SIZE = 1000010;int a[SIZE], q[SIZE];int n, m, ans;vector&lt;int&gt; b[SIZE];int main() &#123; freopen("change.in","r",stdin); freopen("change.out","w",stdout); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[a[i]].push_back(i); m = max(m, a[i]); &#125; int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) &#123; reverse(b[i].begin(), b[i].end()); for (int j = 0; j &lt; b[i].size(); j++) &#123; int k = b[i][j]; while (l &lt;= r &amp;&amp; q[r] &gt; k) &#123; while (l &lt; r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++; r--; &#125; ans = max(ans, r - l + 2 + j); &#125; for (int j = b[i].size() - 1; j &gt;= 0; j--) &#123; q[++r] = b[i][j]; &#125; //cout &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; n - ans &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 以下是考试时瞎打的代码：#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1100000#define INF 0x3f3f3f3fint n, A[maxn], B[maxn];int ans = -INF;int len = 0;inline bool compare(int x, int y) &#123; if (A[x] == A[y]) return x &lt; y; return A[x] &lt; A[y];&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("change.in"); ofstream out("change.out"); in.tie(NULL); in &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; A[i]; B[i] = i; &#125; sort(B + 1, B + n + 1, compare); // B 数组记录 A 中元素的 位置，且以 A 中相应的元素大小为优先排序 int j; for (int i = 1; i &lt;= n; i = j + 1) &#123; for (j = i; i &lt; n &amp;&amp; B[j] &lt; B[j + 1]; j++); len = j - i + 1; // 以上这段先找出从 i 开始序号递增的子序列的最大长度 for (int k = i - 1; k != 0 &amp;&amp; A[B[k]] == A[B[i - 1]]; --k) if (B[k] &lt; B[i]) len++; for (int k = j + 1; k &lt;= n &amp;&amp; A[B[j + 1]] == A[B[k]]; ++k) if (B[j] &lt; B[k]) len++; // 因为前面 i 直接变为 j + 1，所以可能出现重复的数字忽略的情况 // 故在上面两个循环中： // 一个向左扫，一个向右扫，同时判断在原数组中的位置是否递增 // 这种方法速度会更快一点。 ans = max(ans, len); // 获取最大长度 &#125; out &lt;&lt; n - ans; // 相减 return 0;&#125;// 考完试后自己都无法记起这是什么神奇的算法，不过仔细想想还是能想起来的。 [评价] 这道题既考验思维又考验代码能力，好题。 总结首先，仍然要记住仔细读题，这次第一题就是因为读题不仔细，思考不充分才出问题的。其次，有些代码还是好好打打草稿，写写流程图比较好，防止像第三题一样想不起来（#滑稽）。]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
        <tag>题解</tag>
        <tag>神题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 2018-8-6 题解: 一次戏剧性的模拟测试]]></title>
    <url>%2F2018%2F08%2F06%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-6-%E9%A2%98%E8%A7%A3-%E4%B8%80%E6%AC%A1%E6%88%8F%E5%89%A7%E6%80%A7%E7%9A%84%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[今天模拟测试一共有三道题，这里先发一下有关这三道题的题解，有关这几类题目的详解会在以后更新。 T1 奇数码问题[题目描述] 你一定玩过八数码游戏，它实际上是在一个$3\times 3$的网格中进行的，$1$个空格和$1 \sim 8$这$8$个数字恰好不重不漏地分布在这$3 \times 3$的网格中。 例如： 5 2 8 1 3 _ 4 6 7 在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。例如在上例中，空格可与左、上、下面的数字交换，分别变成： 5 2 8 5 2 _ 5 2 8 1 _ 3 1 3 8 1 3 7 4 6 7 4 6 7 4 6 _ 奇数码游戏是它的一个扩展，在一个$n \times n$的网格中进行，其中n为奇数，1个空格和$1 \sim n\times n-1$这$n\times n-1$个数恰好不重不漏地分布在$n\times n$的网格中。 空格移动的规则与八数码游戏相同，实际上，八数码就是一个$n=3$的奇数码游戏。 现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。 [输入格式] 多组数据，对于每组数据： 第1行一个奇整数n。 接下来n行每行n个整数，表示第一个局面。 接下来n行每行n个整数，表示第二个局面。 局面中每个整数都是0~n*n-1之一，其中用0代表空格，其余数值与奇数码游戏中的意 义相同，保证这些整数的分布不重不漏。 [输出格式] 对于每组数据，若两个局面可达，输出TAK，否则输出NIE。 [样例输入] 3 1 2 3 0 4 6 7 5 8 1 2 3 4 5 6 7 8 0 1 0 0 [样例输出] TAK TAK [数据范围与约定] 对于30%的数据，1&lt;=n&lt;=3； 对于60%的数据，1&lt;=n&lt;=50； 对于100%的数据，1&lt;=n&lt;=500，n为奇数，每个测试点不超过10组。 [题解] 通过题目可知，这是一道经典的八数码问题，可以说是模板题。对于这种问题，可以把方阵转为链（忽略输入的$0$），然后统计初始状态和目标状态的逆序对的数量。若逆序对数的奇偶性相同，则可以到达，否则不行。 [参考代码] 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int n, a, t[300010];inline void modify(int x) &#123; for (int i = x; i &lt;= n; i += i &amp; -i) ++t[i];&#125;inline int query(int x) &#123; int res = 0; for (int i = x; i; i -= i &amp; -i) res += t[i]; return res;&#125;inline int work() &#123; memset(t, 0, sizeof(t)); int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;a); if (!a) continue; cnt += query(n) - query(a); modify(a); &#125; return cnt &amp; 1;&#125;int main() &#123; freopen("digital.in", "r", stdin); freopen("digital.out", "w", stdout); for (; scanf("%d", &amp;n) == 1; ) &#123; n *= n; if (work() == work()) printf("TAK\n"); else printf("NIE\n"); &#125; return 0;&#125;// 此处使用了树状数组做// 本题还可以使用归并排序做，有兴趣的同学可以试试看用归并排序做。 [评价] 第一题嘛……水题，模板题，送分题…… T2 树洞[题目描述] 在一片栖息地上有$N$棵树，每棵树下住着一只兔子，有$M$条路径连接这些树。更特殊地是，只有一棵树有$3$条或更多的路径与它相连，其它的树只有$1$条或$2$条路径与其相连。换句话讲，这些树和树之间的路径构成一张$N$个点、$M$条边的无向连通图，而度数大于$2$的点至多有$1$个。 近年以来，栖息地频繁收到人类的侵扰。兔子们联合起来召开了一场会议，决定在其中$K$棵树上建造树洞。当危险来临时，每只兔子均会同时前往距离它最近的树洞躲避，路程中花费的时间在数值上等于距离。为了在最短的时间内让所有兔子脱离危险，请你安排一种建造树洞的方式，使最后一只到达树洞的兔子所花费的时间尽量少。 [输入格式] 第一行有3个整数N，M，K，分别表示树（兔子）的个数、路径数、计划建造的树洞数。 接下来M行每行三个整数x,y，表示第x棵树和第y棵树之间有一条路径相连。 1&lt;=x,y&lt;=N，x≠y，任意两棵树之间至多只有1条路径。 [输出格式] 一个整数，表示在最优方案下，最后一只到达树洞的兔子所花费的时间。 [样例输入] 5 5 2 1 2 2 3 3 1 1 4 4 5 [样例输出] 1 [数据范围与约定] 对于20%的数据，1 ≤ n ≤ 10。 对于另外30%的数据，每棵树至多与2条路径相连。 对于另外30%的数据，保证存在一种最优解，使与3条或更多路径相连的树上一定建造了树洞。 对于100%的数据，1 ≤ n ≤ 2000，n-1&lt;=m&lt;=n*(n-1)/2。 [题解] 求最大值最小，而且答案满足单调，很显然可以用二分如何验证？首先考虑一条链的情况，答案必然是$\frac{n - k}{k}$； 而另外存在一个特殊点有三条及以上的边的情况我们先枚举一个点，可以将特殊点覆盖，覆盖后，原来的图将断成若干条链，然后重复之前链的做法统计答案是否超过k，来判断二分的答案是否正确 [参考代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;int n, m, k, rt, deep, mi;int deg[2005], dis[2005];bool vis[2005], first[2005];int head[2005], num;struct edge &#123; int nxt, to;&#125; e[4000005];void add(int x, int y) &#123; e[++num].nxt = head[x]; e[num].to = y; head[x] = num;&#125;void dfs(int x, int len) &#123; deep += 1; vis[x] = 1; if (!len) return; for (int i = head[x]; i; i = e[i].nxt) &#123; int v = e[i].to; if (!vis[v]) &#123; dis[v] = dis[x] + 1; dfs(v, len - 1); &#125; &#125;&#125;bool check(int x) &#123; memset(vis, 0, sizeof(vis)); dfs(rt, x); memcpy(first, vis, sizeof(vis)); for (int i = 1; i &lt;= n; i++) &#123; if (first[i]) &#123; int res = 0; memset(vis, 0, sizeof(vis)); dfs(i, x); for (int j = 1; j &lt;= n &amp;&amp; res &lt; k; j++) if (!vis[j]) &#123; deep = 0; dfs(j, n); res += (deep + 2 * x) / (2 * x + 1); &#125; if (res &lt; k) return 1; &#125; &#125; return 0;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); deg[x]++; deg[y]++; add(x, y); add(y, x); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt; 2) &#123; rt=i; break; &#125; &#125; if (!rt) &#123; printf("%d", (n + k - 1) / k / 2); return 0; &#125; int l = 1, r = n - 1, ans = n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; printf("%d", ans);&#125; [评价] 之所以标题称这次模拟为“戏剧性的模拟测试”，是因为这道题一开始不会，用了个随机数骗了个 10 分（逃）。 虽然这种骗分方法不值得提倡，但也是没有办法的办法，毕竟信奥有时就是这么玄。 对于这种二分答案的题要记住题目所满足的条件：单调性，一般遇到最大值求最小，最小值求最大的这种坑题可以考虑二分答案的方法了。 T3 まんふは函数[吐槽] 为什么这道题一上来就吐槽呢？首先，这道题的思维难度比较大，其次，这道题的思维难度比较小（WTF!!??）。 首先来看一下题目中日语的发音： 重新排列之后： 经过 Google 的提醒： 这不就是 Huffman 的意思吗……明摆着让我们用霍夫曼树…… （当然，从题中所给的公式也可以看出来，比如考试的时候我就看出来了（逃）。） [题目描述] 有n个正整数 $A[1], A[2]…A[n]$，满足 ${A[i]}\geqslant{A[i+1]}$。它们可以产生$n$个正整数 $B[1], B[2]…B[n]$，其中 $B[i]=\sum_{j=i}^n A[j]$ まんふは函数（マンフハ函数）$f:(Z,Z) \rightarrow Z$定义为： $$f(i,j)=\begin{cases}0, &amp; \text{($i$,$j$) = (1,1)}\\\min\lbrace f(i-1,j+1), f(i,\lceil\frac{j}{2}\rceil)+B[i]\rbrace, &amp; i,j \in [1,n], \text{ } i,j \neq{(1,1)}\\10^{11037}, &amp; \text{otherwise}\end{cases}$$ 试求$f(n,1)$。 [输入格式] 输入包含多组数据，不超过10组。 每组数据的第一行是一个正整数，第二行n个正整数A[i]。 [输出格式] 对于每组数据，输出一个整数表示f(n,1)。 [样例输入] 3 1 1 1 5 28 26 25 24 1 10 996 901 413 331 259 241 226 209 139 49 [样例输出] 5 233 11037 [样例解释] 对于第一组数据： f(1, 1) = 0 f(1, 2) = f(1, 1) + 3 = 3 f(1, 3) = f(1, 2) + 3 = 6 f(2, 1) = min(f(2, 1) + 2, f(1, 2)) = 3 f(2, 2) = min(f(2, 1) + 2, f(1, 3)) = 5 f(2, 3) = f(2, 2) + 2 = 7 f(3, 1) = min(f(3, 1) + 1, f(2, 2)) = 5 [数据范围与约定] 对于30%的数据，满足1 ≤ n ≤ 20。 对于60% 的数据，满足1 ≤ n ≤ 1000。 对于 100% 的数据，满足1 ≤ n ≤ 100000，1 ≤ A[i] ≤ 10000。 [题解] 对于会日语的同学，直接看吐槽就行了，如果不会日语呢？先仔细读题，研究题中所给的表达式，有两个边界条件，这是不是很像状态转移方程？那么我们就可以从动态规划的角度来解决题目的意思。$B$ 数组其实是 $A$ 的一个后缀和，而 $min$ 中的两个 $f(i,j)$, 一个减一，一个除以二，自然而然地联想到这是树的合并，记 $f(i,j)$ 为合并了 $i$ 个点，产生 $j$ 棵树的状态，那么我们要么合并到树中，要么合并两棵子树，为了使合并的总量最小，我们就可以用霍夫曼树来解了，题目的思路就开朗了。 [参考代码] 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define int64 long longint64 node[maxn], u[maxn];int64 tot, n, len, ans;int64 x, y;int64 top() &#123; if (x &lt;= n &amp;&amp; (y &gt; len || node[x] &lt; u[y])) return node[x++]; else return u[y++];&#125;int main() &#123; while (~scanf("%d",&amp;n)) &#123; ans = 0; len = 0; x = 1; y = 1; tot = 0; memset(node, 0, sizeof(node)); memset(u, 0, sizeof(u)); tot = n; for (int i = 1; i &lt;= n; ++i) &#123; int tmp; scanf("%d",&amp;tmp); node[tot--] = tmp; &#125; for (int i = 1; i &lt; n; ++i) &#123; u[len + 1] = top() + top(); ans += u[++len]; &#125; printf("%lld\n",ans); &#125; return 0;&#125;// 提醒注意多组数据读入问题// ++i 和 i++ 的区别要清楚 [评价] 好题，由类状态转移方程推出题目的原意，再进行解答，思维难度比较大，好题。 总结今天三道题，除了第三道题，另外两道题都不是很考验思维，只要还是技巧。看来我还是需要提升自己的知识水平，防止再出现第二题做不出，只能随机数的情况。]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
        <tag>题解</tag>
        <tag>神题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world!]]></title>
    <url>%2F2018%2F08%2F05%2FHello-world%2F</url>
    <content type="text"><![CDATA[重新弄了一个 Github 账号，因为高中决定搞信息竞赛了，所以以后会在这个新的博客里不定期地更新一些有关信息竞赛的内容，当然也可能会更新其他的内容。 目录TO BE CONTINUED……]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
