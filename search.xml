<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>[算法] RMQ 问题与 ST 算法</title>
      <link href="/2018/08/11/%E7%AE%97%E6%B3%95-RMQ-%E9%97%AE%E9%A2%98%E4%B8%8E-ST-%E7%AE%97%E6%B3%95/"/>
      <url>/2018/08/11/%E7%AE%97%E6%B3%95-RMQ-%E9%97%AE%E9%A2%98%E4%B8%8E-ST-%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>因为很多次模拟测试都败在区间最值问题（RMQ）上，所以决定开一篇博客好好总结一下。本篇文章着重介绍 RMQ 问题中最著名的 ST 算法。<br><a id="more"></a></p><h3 id="RMQ-问题"><a href="#RMQ-问题" class="headerlink" title="RMQ 问题"></a>RMQ 问题</h3><p>给定一个长度为 $N$ 的数列 $A$，然后进行若干次询问，每次给定一个区间 $[l_i,r_i]$ 求这个区间中的最大或最小值，这就是区间最值问题，也就是 RMQ 问题。一般来说，这样的问题都要求区间的查询是在线的，也就是提出一个查询回答一次，不能全部收到后统一回答。对于某些确定区间求最值的问题，通常采用倍增的方法来求解。而 ST 算法其实就是倍增的产物，同时加入了动态规划的思想。</p><h3 id="ST-算法"><a href="#ST-算法" class="headerlink" title="ST 算法"></a>ST 算法</h3><p>在 RMQ 问题中，ST 算法可以在 $O(NlogN)$ 的时间预处理数据后，以 $O(1)$ 的时间在线回答查询。一个序列的子空间个数显然有 $O(N^2)$ 个，我们首先在这个规模为 $O(N^2)$ 的状态空间中选择一些 $2$ 的整数次幂的位置作为代表值。</p><p>设 $F[i,j]$ 表示子空间 $A$ 中下标在在子区间 $[i,i+2^j-1]$ 里数的最大值，即从 $i$ 开始的 $2^j$ 个数的最大值。显然 $F[i,0]=A[i]$，即数列 $A$ 在子区间 $[i,i]$ 中的最大值。</p><p>递推时，我们将子区间长度成倍增长，公式如下：</p><p>$$F[i,j]=max\lbrace F[i,j-1],F[i+2^{j-1},j-1] \rbrace$$</p><p>即长度为 $2^j$ 的子区间的最大值是左右两半长度为 $2^{j-1}$ 的子区间的最大值中较大的那一个。所以我们先预处理我们要用到的数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STprework</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">int</span> t = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i)</span><br><span class="line">f[i][j] = max(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们要查询区间 $[l,r]$ 的最值时，我们先计算出一个 $k$，满足 $2^k &lt; r-l+1 \leqslant 2^{k+1}$，也就是使二的 $k$ 次幂小于区间长度的前提下最大的 $k$。那么“从 $l$ 开始的 $2^k$ 个数”和“以 $r$ 结尾的 $2^k$ 个数” 这两段一定覆盖了原来的整个区间，这两段的最大值分别为 $F[l,k]$ 和 $F[r-2^k+1,k]$，二者中较大的就是整个区间的最值。因为求的是最大值，所以只要覆盖区间就行，重叠是没有关系的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">STquery</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> max(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要进一步提高执行效率，可以将 $f$ 数组的两个维度交换，这样对缓存更加友好。并且可以预处理出 $1 \thicksim n$ 中 $log_2 n$ 的值，甚至是各个区间对应的 $k$ 的值，具体方法视情况而定。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>为什么使用 <code>log()</code> 函数而不是 <code>log2()</code> 呢，原因是前者效率更快，而且众所周知，对数是有换底公式的（啥？你不知道？赶紧补一下高中数学必修一吧！），所以这里效率会高一点</li><li><a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">ST 表的模板题地址——洛谷 p3865</a></li></ol><p>附上完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 110000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(a) putchar(a + 48)</span></span><br><span class="line"><span class="keyword">int</span> n, m, A[maxn];</span><br><span class="line"><span class="keyword">int</span> li, ri;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">21</span>][maxn];</span><br><span class="line"><span class="keyword">int</span> logn[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c = getchar()) &amp;&amp; c != <span class="string">'-'</span>);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">'-'</span>) &#123;</span><br><span class="line">sign = <span class="literal">true</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">ans = (ans &lt;&lt; <span class="number">3</span>) + (ans &lt;&lt; <span class="number">1</span>) + (c - <span class="string">'0'</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c = getchar()));</span><br><span class="line"><span class="keyword">return</span> sign ? -ans : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">G(<span class="number">-3</span>);</span><br><span class="line">s = -s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s &gt; <span class="number">9</span>) write(s / <span class="number">10</span>);</span><br><span class="line">G(s % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STprework</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[<span class="number">0</span>][i] = A[i];</span><br><span class="line"><span class="keyword">int</span> t = logn[n] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; t; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++i)</span><br><span class="line">f[j][i] = max(f[j - <span class="number">1</span>][i], f[j - <span class="number">1</span>][i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">STquery</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = logn[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> max(f[k][l], f[k][r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logn[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">logn[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) logn[i] = logn[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = read();</span><br><span class="line">m = read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) A[i] = read();</span><br><span class="line">pre();</span><br><span class="line">STprework();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">li = read();</span><br><span class="line">ri = read();</span><br><span class="line">write(STquery(li, ri));</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> NOIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> RMQ 问题 </tag>
            
            <tag> ST 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[图论] 图论基础知识</title>
      <link href="/2018/08/10/%E5%9B%BE%E8%AE%BA-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/08/10/%E5%9B%BE%E8%AE%BA-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>因为自己的图论其实掌握得不怎么样，所以开一篇博客，来加深一下自己图论的基础。注意，本文只是基础，主要普及图的存储，最短路和遍历（$DFS$ 和 $BFS$）。</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在图论中，我们定义一张图为由顶点集（Vertices）和边集（Edges）组成的二元组，即 $G = (V, E)$。此处 $V$ 和 $E$ 也可写为 $V(G)$ 和 $E(G)$。</p><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><p><strong>阶（Order）</strong>：图 $G$ 中顶集 $V$ 的大小称作图 $G$ 的阶。</p><p><strong>子图（Sub-Graph）</strong>：图 $G’$ 称作图 $G$ 的子图如果 $V(G’)\subseteq V(G)$ 以及 $E(G’)\subseteq E(G)$。</p><p><strong>生成子图（Spanning Sub-Graph）</strong>：指满足条件 $V(G’)=V(G)$ 的 $G$ 的子图 $G’$。</p><p><strong>度（Degree）</strong>是一个顶点的度是指与该顶点相关联的总边数，顶点 $v$ 的度记作 $d(v)$。度和边有如下关系：$\sum_{v\in V} d(v)=2\left|E\right|$。</p><p><strong>出度（Out-degree）和入度（In-degree）</strong>：对有向图而言，顶点的度还可分为出度和入度。一个顶点的出度为 $d_o$ ，是指有 $d_o$ 条边以该顶点为起点，或说与该点关联的出边共有 $d_o$ 条。入度的概念也类似。</p><p><strong>自环（Loop）</strong>：若一条边的两个顶点相同，则此边称作自环。</p><p><strong>路径（Path）</strong>：从顶点u到顶点v的一条路径是指一个序列 $v_0,e_1,v_1,e_2,v_2,…e_k,v_k$，$e_i$ 的起点终点为 $v_{i-1}$ 及 $v_i$； $k$ 称作路径的长度； $v_0=u$，称为路径的起点；$v_k=v$，称为路径的终点。如果 $u=v$，称该路径是闭的，反之则称为开的；如果 $v_1,…,v_k$ 两两不等，则称之为简单路径（Simple path，注意， $u=v$ 是允许的）。</p><p><strong>行迹（Trace）</strong>：如果路径 $P(u,v)$ 中边各不相同，则该路径称为 $u$ 到 $v$ 的一条行迹。</p><p><strong>轨道（Track）</strong>：即简单路径。</p><p>闭的行迹称作<strong>回路（Circuit）</strong>，闭的轨道称作圈（Cycle）。（现存文献中的命名法并无统一标准。比如在另一种定义中，walk 对应上述的 path，path 对应上述的 track，trail对应上述的 trace。）</p><p><strong>距离（Distance）</strong>：从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称作从 $u$ 到 $v$ 的距离。若从 $u$ 到 $v$ 根本不存在路径，则记该距离为无穷（$\infty$）。</p><p><strong>桥（Bridge）</strong>：若去掉一条边，便会使得整个图不连通，该边称为桥。</p><h3 id="编程实现图的存储"><a href="#编程实现图的存储" class="headerlink" title="编程实现图的存储"></a>编程实现图的存储</h3><h4 id="邻接矩阵存图"><a href="#邻接矩阵存图" class="headerlink" title="邻接矩阵存图"></a>邻接矩阵存图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(g, INF, <span class="keyword">sizeof</span>(g)); &#125; <span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> wieght)</span> </span>&#123;</span><br><span class="line">g[vertex1][vertex2] = weight;</span><br><span class="line">&#125; <span class="comment">// 添加一条单向边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDuplexEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">addEdge(vertex1, vertex2, weight);</span><br><span class="line">addEdge(vertex2, vertex1, weight);</span><br><span class="line">&#125; <span class="comment">// 添加一条双向边 / 无向边</span></span><br></pre></td></tr></table></figure><p>其中 $g[i][j]$ 表示从 $i$ 到 $j$ 的边的权。<br>注意邻接矩阵方便使用，但空间复杂度为 $O(n^2)$，在点比较多的时候不太实用，极有可能会爆。</p><h4 id="邻接表存图"><a href="#邻接表存图" class="headerlink" title="邻接表存图"></a>邻接表存图</h4><p>先上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 11000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 21000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOE -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[maxm], e[maxm], heads[maxn], nxt[maxm]</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(heads, NOE, <span class="keyword">sizeof</span>(heads)); &#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">v[tot] = vertex2;</span><br><span class="line">e[tot] = weight;</span><br><span class="line">nxt[tot] = heads[vertex1];</span><br><span class="line">heads[vertex1] = tot;</span><br><span class="line">&#125; <span class="comment">// 加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDuplexEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">addEdge(vertex1, vertex2, weight);</span><br><span class="line">addEdge(vertex2, vertex1, weight);</span><br><span class="line">&#125; <span class="comment">// 加双向边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[x]; i != NOE; i = nxt[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> y = v[i];</span><br><span class="line"><span class="keyword">int</span> x = e[i];</span><br><span class="line"><span class="comment">// 找到一条有向边 (x, y) 边权为 z</span></span><br><span class="line"><span class="comment">// do something here</span></span><br><span class="line">&#125; <span class="comment">// 遍历从 x 出发的边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$v[]$ 和 $e[]$ 记录了每条边的终点和边权，$nxt[]$模拟指针，表示从想同节点出发的下一条边在 $v[]$ 和 $e[]$ 中的存储位置，$heads[i]$ 表示从 $i$ 出发的第一条边。信息奥赛中使用数组模拟指针足够了，如果想知道具体的邻接表的相关知识看这里：<a href="https://zh.wikipedia.org/wiki/%E9%82%BB%E6%8E%A5%E8%A1%A8" target="_blank" rel="noopener">Wikipedia</a></p><h4 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h4><p><strong>个人认为最好的存图方式，虽然与邻接表没有太大区别，但是好写多了（与真正的邻接表对比，不是 OI 中的阉割版）。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 11000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 21000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOE -1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> vertexTo;</span><br><span class="line"><span class="keyword">int</span> edgeNext;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edgeNode edges[maxm];</span><br><span class="line"><span class="keyword">int</span> heads[maxn];</span><br><span class="line"><span class="keyword">int</span> numEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(heads, NOE, <span class="keyword">sizeof</span>(heads)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">numEdges++;</span><br><span class="line">edges[numEdges].vertexTo = vertex2;</span><br><span class="line">edges[numEdges].weight = weight;</span><br><span class="line">edges[numEdges].edgeNext = heads[vertex1];</span><br><span class="line">heads[vertex1] = numEdges;</span><br><span class="line">&#125; <span class="comment">// 加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDuplexEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">addEdge(vertex1, vertex2, weight);</span><br><span class="line">addEdge(vertex2, vertex1, weight);</span><br><span class="line">&#125; <span class="comment">// 加双向边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123;</span><br><span class="line"><span class="keyword">int</span> y = edges[i].vertexTo;</span><br><span class="line"><span class="keyword">int</span> z = edges[i].weight;</span><br><span class="line"><span class="comment">// 找到一条有向边 (x, y) 边权为 z</span></span><br><span class="line"><span class="comment">// do something here</span></span><br><span class="line">&#125; <span class="comment">// 遍历从 x 出发的边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多写写就会熟悉了。</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历 DFS"></a>深度优先遍历 DFS</h4><p>深度优先搜索法是树的先序遍历的推广，它的基本思想是：从图 $G$ 的某个顶点 $v_0$ 出发，访问 $v_0$，然后选择一个与 $v_0$ 相邻且没被访问过的顶点 $v_i$ 访问，再从 $v_i$ 出发选择一个与 $v_i$ 相邻且未被访问的顶点 $v_j$ 进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点 $w$，从 $w$ 出发按同样的方法向前遍历，直到图中所有顶点都被访问。具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initDFS</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rDFS</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">visited[x] = <span class="literal">true</span>;</span><br><span class="line">visit(); <span class="comment">// 根据具体情况定义 visit()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[x]; i != NOE; i = edges[i].edgeNext)</span><br><span class="line"><span class="keyword">if</span> (!visited[edges[i].vertexTo])</span><br><span class="line">rDFS(edges[i].vertexTo);</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 最好加上 return</span></span><br><span class="line">&#125; <span class="comment">// 因为这是递归实现的，故命名为 rDfS</span></span><br></pre></td></tr></table></figure><p>$DFS$ 全称为 $Depth$ $First$ $Search$，其实是一个搜索算法，有关搜索的算法，未来会开个专题详细讲解，通俗的语言概括就是不顾一切向前冲，撞墙了再回头。</p><p>对于下面这么一张图：</p><div style="align: center"> <img src="pic1.jpg"> </div><p>它的遍历方式如下：</p><div style="align: center"> <img src="pic2.jpg"> </div><p>遍历顺序：<br>$$v_1 \rightarrow v_2 \rightarrow v_4 \rightarrow v_8 \rightarrow v_5 \rightarrow v_3 \rightarrow v_6 \rightarrow v_7$$</p><p>$DFS$ 还是很常用的，属于必备知识。</p><h4 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历 BFS"></a>广度优先遍历 BFS</h4><p>图的广度优先搜索是树的按层次遍历的推广，它的基本思想是：首先访问初始点 $v_i$，并将其标记为已访问过，接着访问 $v_i$ 的所有未被访问过的邻接点 $v_{i1},v_{i2},…,v_{it}$，并均标记已访问过，然后再按照 $v_{i1},v_{i2},…,v_{it}$的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点 $v_i$ 有路径相通的顶点都被访问过为止。非递归实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> dep[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initBFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) Q.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Q.push(<span class="number">1</span>);</span><br><span class="line">dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// dep[i] 表示节点 i 的深度，即从 1 到 i 需要走过的最少点数</span></span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123;</span><br><span class="line"><span class="keyword">int</span> y = edges[i].vertexTo;</span><br><span class="line"><span class="keyword">if</span> (dep[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 这里直接使用 dep[] 来替代 visited[]，顺便求出点的深度</span></span><br><span class="line">dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">Q.push(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于下面这么一张图：</p><div style="align: center"> <img src="pic3.jpg"> </div><p>它的遍历方式如下：</p><div style="align: center"> <img src="pic4.jpg"> </div><p>遍历顺序：<br>$$v_1\rightarrow v_2\rightarrow v_3\rightarrow v_4\rightarrow v_5\rightarrow v_6\rightarrow v_7\rightarrow v_8$$</p><h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><h4 id="Floyd-求多源最短路"><a href="#Floyd-求多源最短路" class="headerlink" title="Floyd 求多源最短路"></a>Floyd 求多源最短路</h4><p>Floyd 的本质是动态规划，我们令 $D[i,j,k]$ 表示经过若干个编号不超过 $k$ 的节点，从 $i$ 到 $j$ 的最短路径的长度。该问题可以划分成两个子问题，经过编号不超过 $k-1$ 的节点从 $i$ 到 $j$，或者从 $i$ 先到 $k$ 再到 $j$，于是我们写出动态规划方程：</p><p>$$D[i,j,k]=min\lbrace D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]\rbrace$$</p><p><strong>注意，$k$ 是阶段，所以必须置于外层循环中，$i$ 和 $j$ 是附加状态，所以置于内层循环。</strong></p><p>与背包问题类似，我们可以忽略 $k$ 这一维，于是我们有：</p><p>$$D[i,j]=min\lbrace D[i,j],D[i,k]+D[k,j]\rbrace$$</p><p>$D[i,j]$ 保存了从 $i$ 到 $j$ 的最短路的长度</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 310</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[maxn][maxn], n, m;</span><br><span class="line"><span class="keyword">int</span> x, y, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">memset</span>(d, INF, <span class="keyword">sizeof</span>(d));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">d[x][y] = min(d[x][y], z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化 &amp; 输入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line"><span class="comment">// Floyd 求最短路</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，在数据小的时候可以使用 Floyd 算法，数据大的时候尽量去思考别的方法。</p><h4 id="Dijkstra-求单源最短路"><a href="#Dijkstra-求单源最短路" class="headerlink" title="Dijkstra 求单源最短路"></a>Dijkstra 求单源最短路</h4><p>Dijkstra 算法流程如下：</p><ol><li>初始化 $dist[1] = 0$，其余节点初始化为一个极大值。</li><li>找出一个未被标记的，$dist[x]$ 最小的节点 $x$，然后标记节点 $x$。</li><li>扫描节点 $x$ 的所有出边 $(u, v, w)$，若 $dist[v] &gt; dist[u] + w$，则使用 $dist[u] + w$ 更新 $dist[v]$</li><li>重复 $2 \thicksim 3$ 两个步骤，直到节点全部被标记。</li></ol><p>Dijkstra 算法基于贪心，只适用于边权非负的图。<br>优化：使用二叉堆对 $dist$ 进行维护，$O(log n)$ 的时间获取最小值并删除，$O(log n)$ 的时间执行一条边的扩展和更新，最终在 $O((m+n) log n)$ 的时间内完成 Dijkstra。</p><p>实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于图的定义部分这里省略</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heapNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, d;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> heapNode&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> d &gt; b.d; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意，为了建立小根堆，此处重载的运算符有一点不同。</span></span><br><span class="line"><span class="comment">// 可以通俗地理解为：如果到 b 的距离比到 u 的距离小，那么 b 的优先级比 u 高。</span></span><br><span class="line">priority_queue&lt;heapNode&gt; Q; <span class="comment">// 使用优先队列建立小根堆。</span></span><br><span class="line"><span class="keyword">int</span> dist[maxn]; <span class="comment">// 记录从 x 到 各点的最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dist[i] = INF;</span><br><span class="line">dist[x] = <span class="number">0</span>; <span class="comment">// 到自己的距离为 0</span></span><br><span class="line">Q.push((heapNode)&#123; x, <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">heapNode f = Q.top();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">int</span> u = f.u;</span><br><span class="line"><span class="keyword">int</span> d = f.d;</span><br><span class="line"><span class="keyword">if</span> (d != dist[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[u]; i != NOE; i = edges[i].edgeNext) &#123;</span><br><span class="line"><span class="keyword">int</span> j = edges[i].vertexTo;</span><br><span class="line"><span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; dist[u] + w) &#123;</span><br><span class="line">dist[j] = dist[u] + w;</span><br><span class="line">Q.push()((heapNode)&#123; j, dist[j] &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bellman-Ford-及-SPFA-算法"><a href="#Bellman-Ford-及-SPFA-算法" class="headerlink" title="Bellman-Ford 及 SPFA 算法"></a>Bellman-Ford 及 SPFA 算法</h4><p>给定一张有向图，若对于图中的某一条边 $(x,y,z)$，有 $dist[y] \leqslant dist[x]+z$ 成立，则称该边满足<strong>三角形不等式</strong>。若所有的边都满足三角形不等式，则 $dist$ 数组就是所求的最短路。</p><p>首先介绍基于迭代思想的 Bellman-Ford 算法。它的流程如下：</p><ol><li>扫描所有的边 $(x,y,z)$，若 $dist[y] &gt; dist[x]+z$，则用后者更新它。</li><li>重复上述步骤，直到没有操作发生。</li></ol><p>Bellman-Ford 的时间复杂度为 $O(nm)$。</p><p>而 SPFA 实际上是队列优化的 Bellman-Ford 算法，这是国际上的通称。SPFA 的算法流程大致如下：</p><ol><li>建立一个队列，最初队列中只含有起点 $1$。</li><li>取出队头结点 $x$，扫描它的所有出边 $(x, y, x)$，若 $dist[y] &gt; dist[x]+z$，则用后者更新前者，同时若 $y$ 不在队列中，则把 $y$ 入队。</li><li>重复上述步骤，直到队列为空。</li></ol><p>SPFA 中的队列避免了 Bellman-Ford 中对不需要扩展的节点的冗余扫描，在稀疏图上的运行效率较高，为 $O(km)$ 级别，$k$ 是一个较小的常数，而在稠密图或特殊构造的网格图上，算法仍可能退化为 $O(nm)$，这也是很多人说 SPFA 算法玄学的原因。但是在遇到负边权的时候，只能够使用 SPFA。</p><p>SPFA 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; inq; <span class="comment">// 记录是否在队列中</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, INF, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">dist[x] = <span class="number">0</span>;</span><br><span class="line">Q.push(x);</span><br><span class="line">inq[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">k = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">inq[k] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (dist[k] == INF) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[k]; i != NOE; i = edges[i].edgeNext) &#123;</span><br><span class="line"><span class="keyword">int</span> j = edges[i].vertexTo;</span><br><span class="line"><span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; dist[k] + w) &#123;</span><br><span class="line">dist[j] = dist[k] + w;</span><br><span class="line"><span class="keyword">if</span> (!inq[j]) &#123;</span><br><span class="line">Q.push(j);</span><br><span class="line">inq[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是处理负边权的图的话， SPFA 尽量不要用，原因嘛……它太玄了。</p><h3 id="完结撒花！！"><a href="#完结撒花！！" class="headerlink" title="完结撒花！！"></a>完结撒花！！</h3>]]></content>
      
      <categories>
          
          <category> NOIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 图的遍历 </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
            <tag> Floyd </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> Bellman-Ford </tag>
            
            <tag> SPFA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP 模拟] 2018-8-8 题解: 爆零日，我该何去何从...</title>
      <link href="/2018/08/08/NOIP-%E6%A8%A1%E6%8B%9F-2018-8-8-%E9%A2%98%E8%A7%A3-%E7%88%86%E9%9B%B6%E6%97%A5%EF%BC%8C%E6%88%91%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/"/>
      <url>/2018/08/08/NOIP-%E6%A8%A1%E6%8B%9F-2018-8-8-%E9%A2%98%E8%A7%A3-%E7%88%86%E9%9B%B6%E6%97%A5%EF%BC%8C%E6%88%91%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/</url>
      <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>今天的题似乎是 Day1 的题，然而却是压力山大，从第一题开始就崩，第二题考场上无脑 Dijkstra 求最短路，第三题更是懵逼（考后听说用 Dancing Link 做的时候彻底崩溃），总之，今天四十分，与爆零相差无几，所以这次在写题解的同时，还是会写一点考试技巧的，尤其是第一题和第二题（原谅我知识水平实在不够，对第三题仍然懵逼）。<br><a id="more"></a></p><h3 id="T1-动态仙人掌-dinosaur-cpp-c-pas"><a href="#T1-动态仙人掌-dinosaur-cpp-c-pas" class="headerlink" title="T1 动态仙人掌(dinosaur.cpp/c/pas)"></a>T1 动态仙人掌(dinosaur.cpp/c/pas)</h3><p><strong><em>——玩了这么多次小恐龙，没想到它还会报复我</em></strong></p><p><strong>[题目描述]</strong></p><p>由于 Beny 做的烧网线实验，Fife 家断网了。<br>Fife 照常打开了 Google Chrome，由于断网，他看到了以下内容：</p><div style="align: center"> <img src="pic1.jpg"> </div><p>看 到 这 个 简 单 而 又 有 趣 的 游 戏 ， 他 玩 了 起 来 。 然 后 ：</p><div style="align: center"> <img src="pic2.jpg"> </div><p>Fife 永远没有 gameover，他觉得这个游戏太简单了，现在他想考考你。小恐龙在数轴上原点出发向右运动，速度为$1$个单位每秒。现在你知道每一个仙人掌的位置$p[i]$和高度$h[i]$，且没有怪鸟突袭，请你控制小恐龙跳跃，使它能跳过最后一个仙人掌且跳跃的最大高度最小。为了送温暖简化问题，跳跃满足以下规则：它的跳跃路线为严格的与地面夹角为$45$度的直线，它在平地上能随时起跳，它能在起点和落地时刻瞬间起跳。你能控制它起跳的时刻和下落的时刻，下落时它会沿与地面夹角为$45$度的直线下降。小恐龙能跳过一个仙人掌当且仅当它在这个仙人掌的位置时的高度大于等于仙人掌的高度。 </p><p><strong>[输入]</strong></p><pre><code>第 1 行 1 个正整数 n接下来 n 行每行两个正整数 p[i]和 h[i],为第 i 个仙人掌的位置和高度，不保证 p[i]单调递增，可能会有两个仙人掌在同一位置。 </code></pre><p><strong>[输出]</strong></p><pre><code>你需要控制小恐龙跳跃，使它能跳过所有仙人掌，且跳跃的最大高度最小，输出这个高度，保留 1 位小数，如果无解，输出-1</code></pre><p><strong>[样例输入]</strong></p><pre><code>55 29 313 219 320 1</code></pre><p><strong>[样例输出]</strong></p><pre><code>6.0</code></pre><p><strong>[数据规模]</strong></p><pre><code>对于 30%的数据：n&lt;=200, p[i] &lt;= 1000, h[i] &lt;= 100对于 60%的数据：n&lt;= 50000, p[i] &lt;= 3000000, h[i] &lt;= 500对于 100%的数据：n &lt;= 300000, p[i] &lt; 2^31, h[i] &lt;=40000, 数据保证无需使用 longlong 或 int64</code></pre><p><strong>[题解]</strong></p><p>看到这是第一道题，心想，这一定很简单，只要贪心就行了，一堆判断，然后信心满满地提交……最后只对了一个点……此处附上 <strong>WA 代码</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 310000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p[maxn], h[maxn];</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; goDown;</span><br><span class="line"><span class="keyword">double</span> ans = -INF;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">goDown.<span class="built_in">set</span>();</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judgeDown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (h[i] &gt;= h[i + <span class="number">1</span>] + p[i + <span class="number">1</span>] - p[i]) goDown[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (h[i] + h[i + <span class="number">1</span>] &lt;= p[i + <span class="number">1</span>] - p[i]) goDown[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> goDown[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judgeCan</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[i] - p[i - <span class="number">1</span>] + h[i - <span class="number">1</span>] &lt; h[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两个 judge 函数是 WA 之精髓所在（雾）</span></span><br><span class="line"><span class="comment">// 只考虑了相邻两个仙人掌的关系，如果在下降的时候撞到另外一个仙人掌</span></span><br><span class="line"><span class="comment">// 那么小恐龙就 GG 了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calh</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (h[x] &gt; h[y] + p[y] - p[x] &amp;&amp; x + <span class="number">1</span> == y) <span class="keyword">return</span> (<span class="keyword">double</span>)h[x];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">double</span>)(p[y] - p[x] + h[x] + h[y]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"dinosaur.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"dinosaur.out"</span>)</span></span>;</span><br><span class="line">in.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">in &gt;&gt; n;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">in &gt;&gt; p[i] &gt;&gt; h[i];</span><br><span class="line"><span class="keyword">if</span> (!judgeCan(i)) &#123;</span><br><span class="line">out &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) judgeDown(i);</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; key &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (goDown[i]) &#123;</span><br><span class="line"><span class="keyword">double</span> tmp = calh(key, i);</span><br><span class="line">ans = max(ans, tmp);</span><br><span class="line">key = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (p[i] + h[i] &gt; p[i + <span class="number">1</span>]) key += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; fixed &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个实例告诉大家，贪心前先做好分析准备工作，否则就会像我这样......</span></span><br></pre></td></tr></table></figure><p>那么到底该怎么做呢？</p><p>由于这是一只理（bian）想（tai）化过的小恐龙，它只会与地面呈$45$度跳跃，而且可以无限升天，<del>法力无边</del>，所以我们可以从每一个仙人掌的跳跃边界来考虑：</p><div style="align: center"> <img src="T1_1.jpg"> </div><p>考虑两种不同的仙人掌情况：</p><div style="align: center"> <img src="T1_2.jpg"> </div><p>那么就有两种做法了，第一种，删去所有像绿色仙人掌那样的仙人掌，然后直接计算；第二种，也是标程的方法，逐个进行判断，维护 first 和 last 这两个值，分别表示一组跳跃（一次上和一次下）的左右边界，然后计算。</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注：本代码使用的是第二种方法</span></span><br><span class="line"><span class="comment">// 使用第一种方法的同学可以使用类链表的方式来存储数据，加快效率</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 310000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment</span> &#123;</span> <span class="keyword">int</span> l; <span class="keyword">int</span> r; &#125;;</span><br><span class="line"><span class="keyword">int</span> n, p, h;</span><br><span class="line"><span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">segment a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(segment a, segment b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.l &lt; b.l || (a.l == b.l &amp;&amp; a.r &lt; b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"dinosaur.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"dinosaur.out"</span>)</span></span>;</span><br><span class="line">in.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">in &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">in &gt;&gt; p &gt;&gt; h;</span><br><span class="line">a[i].l = p - h;</span><br><span class="line">a[i].r = p + h;</span><br><span class="line">&#125;</span><br><span class="line">sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, compare);</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>].l &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> last = a[<span class="number">1</span>].r;</span><br><span class="line"><span class="keyword">int</span> first = a[<span class="number">1</span>].l;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].l &lt; last) last = max(last, a[i].r);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans = max(ans, (last - first) * <span class="number">1.0</span> / <span class="number">2.0</span>);</span><br><span class="line">first = a[i].l;</span><br><span class="line">last = a[i].r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = max(ans, (last - first) * <span class="number">1.0</span> / <span class="number">2.0</span>);</span><br><span class="line">out &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>) &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[评价]</strong></p><p>其实思维难度并不大，主要是考验对算法是否掌握到位，譬如用贪心，这道题并不能从头贪到尾，那样会出问题，必须考虑所有可能情况，这也是本题样例的坑人之处所在，以后考试时，如果只有一个样例，那必须得小心出题老师出阴招，最好是自己<del>脑滚键盘</del>来出几个数据手算测试一下。</p><h3 id="T2-相交-inter-cpp-c-pas"><a href="#T2-相交-inter-cpp-c-pas" class="headerlink" title="T2 相交(inter.cpp/c/pas)"></a>T2 相交(inter.cpp/c/pas)</h3><p><strong><em>——旧时 Dijkstra 堂前 O(mlog n)，飞入寻常 NOIER 家。</em></strong></p><p><strong>[题目描述]</strong></p><p>一棵大树下有$n$个巢穴，由$n-1$条双向道路连接，任意两个城市均可互相到达。<br>大树附近有两群蚂蚁，每天早上，第一群蚂蚁会派一只蚂蚁到这棵树下，并在第$a$个巢穴到第$b$ 个巢穴间的最短路径上的每个巢穴留下气味。每天傍晚，第二群蚂蚁会派一只蚂蚁到这棵树下，并侦查第$c$个巢穴到第$d$个巢穴间的最短路径上是否有蚂蚁留下的气味。每天蚂蚁留下的气味会在当天深夜消失。 </p><p><strong>[输入]</strong></p><pre><code>第一行一个正整数 n，含义如题所示。接下来 n-1 行，每行两个正整数 u,v，表示第 u 个巢穴和第 v 个巢穴间有一条双向道路。接下来一行一个正整数 q，表示天数。接下来 q 行，每行四个正整数 a,b,c,d，含义如题所示。 </code></pre><p><strong>[输出]</strong></p><pre><code>q 行，每行一个字符串。若第二群派出的蚂蚁侦查到蚂蚁留下的气味，则输出”YES”,否则输出”NO”</code></pre><p><strong>[样例输入]</strong></p><pre><code>样例输入 181 21 32 42 55 65 73 842 5 4 35 3 8 85 4 6 74 8 6 7样例输入 2152 13 14 25 36 27 28 59 310 611 512 713 1114 115 151 2 3 44 7 1 92 3 7 92 6 7 82 1 6 8</code></pre><p><strong>[样例输出]</strong></p><pre><code>样例输出 1YESNOYESNO样例输出 2YESNOYESYESYES</code></pre><p><strong>[数据规模]</strong></p><pre><code>对于 30%的数据 1&lt;=n,q&lt;=3000对于另外 20%的数据 第 i 条边连接第 i 个巢穴和第 i+个巢穴对于 100%的数据 1&lt;=n,q&lt;=100000</code></pre><p><strong>[题解]</strong></p><p>首先讲一下我考试的时候是怎么想的，我想既然是最短路径，还是个图（当时没看出是树），那么 Dijkstra 无疑了，潇潇洒洒一百行打完，用了两个 bitset 再用了一个神奇的方法记录路径。好！就是这样，一定 <strong>AC</strong> 了！结果：<strong>TLE</strong>……附上 Dijkstra 暴力代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 110000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxq 110000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> vertexFrom;</span><br><span class="line"><span class="keyword">int</span> vertexTo;</span><br><span class="line"><span class="keyword">int</span> edgeNext;</span><br><span class="line"><span class="keyword">bool</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heapNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> u, d;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> heapNode&amp; b) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; b.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edgeNode edges[maxn];</span><br><span class="line"><span class="keyword">int</span> heads[maxn];</span><br><span class="line"><span class="keyword">int</span> numEdges = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, q, u, v, a, b, c, d;</span><br><span class="line"><span class="keyword">bool</span> judge = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; smell1;</span><br><span class="line"><span class="built_in">bitset</span>&lt;maxn&gt; smell2;</span><br><span class="line"><span class="keyword">int</span> path[maxn];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line">priority_queue&lt;heapNode&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(heads, NOE, <span class="keyword">sizeof</span>(heads)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2)</span> </span>&#123;</span><br><span class="line">numEdges++;</span><br><span class="line">edges[numEdges].vertexFrom = vertex1;</span><br><span class="line">edges[numEdges].vertexTo = vertex2;</span><br><span class="line">edges[numEdges].weight = <span class="literal">true</span>;</span><br><span class="line">edges[numEdges].edgeNext = heads[vertex1];</span><br><span class="line">heads[vertex1] = numEdges;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDuplexEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2)</span> </span>&#123;</span><br><span class="line">addEdge(vertex1, vertex2);</span><br><span class="line">addEdge(vertex2, vertex1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) Q.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dist[i] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) path[i] = i;</span><br><span class="line">dist[x] = <span class="number">0</span>;</span><br><span class="line">Q.push((heapNode)&#123; x, <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">heapNode f = Q.top();</span><br><span class="line">Q.pop();</span><br><span class="line"><span class="keyword">int</span> u = f.u;</span><br><span class="line"><span class="keyword">int</span> dis = f.d;</span><br><span class="line"><span class="keyword">if</span> (dis != dist[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[u]; i != NOE; i= edges[i].edgeNext) &#123;</span><br><span class="line"><span class="keyword">int</span> j = edges[i].vertexTo;</span><br><span class="line"><span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; dist[u] + w) &#123;</span><br><span class="line">dist[j] = dist[u] + w;</span><br><span class="line">path[j] = u; <span class="comment">// 记录路径</span></span><br><span class="line">Q.push((heapNode)&#123; j, dist[j] &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSmell1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = b;</span><br><span class="line"><span class="keyword">while</span> (tmp != a) &#123;</span><br><span class="line">smell1[tmp] = <span class="number">1</span>;</span><br><span class="line">tmp = path[tmp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSmell2</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = d;</span><br><span class="line"><span class="keyword">while</span> (tmp != c) &#123;</span><br><span class="line">smell2[tmp] = <span class="number">1</span>;</span><br><span class="line">tmp = path[tmp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"inter.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"inter.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="comment">// fstream 不知怎么就不能取消 sync_with_stdio，为了加快速度只能使用 freopen</span></span><br><span class="line">init();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">addDuplexEdge(u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">smell1.reset();</span><br><span class="line">smell2.reset();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="keyword">if</span> ((a == c &amp;&amp; b == d) || (a == d &amp;&amp; b == c)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">smell1[a] = <span class="number">1</span>;</span><br><span class="line">smell2[c] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// TLE TLE TLE TLE TLE TLE TLE TLE TLE TLE TTTTTTLLLLLLEEEE</span></span><br><span class="line">Dijkstra(a);</span><br><span class="line">updateSmell1(a, b);</span><br><span class="line">Dijkstra(c);</span><br><span class="line">updateSmell2(c, d);</span><br><span class="line"><span class="comment">// TLE TLE TLE TLE TLE TLE TLE TLE TLE TLE TTTTTTLLLLLLEEEE</span></span><br><span class="line">judge = (smell1 &amp; smell2).any();</span><br><span class="line"><span class="keyword">if</span> (judge) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果看出了这是棵树的话，是可以用广搜的……可以快不少。</p><p>好了，说正解：就像上面所说的，这是一棵树（啥？你问我怎么看出的？仔细读题！！），所以获取最短距离一定是求两个点的 $LCA$ 了。那如何标记呢？？这是个好问题，一般我们都会去想标记经过的点，然而，如果用倍增 $LCA$ 求，一定会跳过经过的点，如果用朴素算法求的话……那还不如 $BFS$，那么我们就必须使用另外的方法了。</p><p>首先我们画一棵树：</p><div style="align: center"> <img src="T2_1.jpg"> </div><p>通过观察和举例，我们发现，只有当</p><ol><li>$a$ 和 $LCA(c, d)$ 在同一条链上，且 $LCA(a, b)$ 也在这条链上；</li><li>$b$ 和 $LCA(c, d)$ 在同一条链上，且 $LCA(a, b)$ 也在这条链上；</li><li>$c$ 和 $LCA(a, b)$ 在同一条链上，且 $LCA(c, d)$ 也在这条链上；</li><li>$d$ 和 $LCA(a, b)$ 在同一条链上，且 $LCA(c, d)$ 也在这条链上；</li></ol><p>以上四者满足其一时才能够是 YES，否则就是 NO。</p><p>为什么是这样？如何实现呢？<br>首先思考：到达$a$，$b$两点必定经过它们的 $LCA$，那么，只要它们两点与另外两点的 $LCA $在一条链上（这个不是很严谨，这里的链指的是将树看成 $DAG$ 时，即若 $LCA(u, v) = v$ 时，$u$，$v$在一条链上），且它们两个点的 $LCA$ 深度比另外两点的深度小时，两条路径必有重叠的部分（如图，$d$与 $LCA(a, b)$ 在一条链上，且 $LCA(a, b)$ 的深度比 $LCA(c, d)$ 的深度大，所以两者路径必有交集）</p><p>如此分析，代码也就呼之欲出了。</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 110000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOE -1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> vertexTo;</span><br><span class="line"><span class="keyword">int</span> edgeNext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edgeNode edges[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 注意由于是无向边，而前向星只能按照双向边处理，所以要乘二</span></span><br><span class="line"><span class="keyword">int</span> heads[maxn];</span><br><span class="line"><span class="keyword">int</span> numEdges = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">20</span>], dep[maxn];</span><br><span class="line"><span class="keyword">int</span> n, q, u, v, a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(heads, NOE, <span class="keyword">sizeof</span>(heads)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2)</span> </span>&#123;</span><br><span class="line">numEdges++;</span><br><span class="line">edges[numEdges].vertexTo = vertex2;</span><br><span class="line">edges[numEdges].edgeNext = heads[vertex1];</span><br><span class="line">heads[vertex1] = numEdges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDuplexEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2)</span> </span>&#123;</span><br><span class="line">addEdge(vertex1, vertex2);</span><br><span class="line">addEdge(vertex2, vertex1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rDFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = fa;</span><br><span class="line">dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i) </span><br><span class="line">f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[x]; i != NOE; i = edges[i].edgeNext)</span><br><span class="line"><span class="keyword">if</span> (edges[i]. vertexTo != fa)</span><br><span class="line">rDFS(edges[i].vertexTo, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (dep[f[u][i]] &gt;= dep[v])</span><br><span class="line">u = f[u][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (dep[f[v][i]] &gt;= dep[u])</span><br><span class="line">v = f[v][i];</span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (f[u][i] != f[v][i]) &#123;</span><br><span class="line">u = f[u][i];</span><br><span class="line">v = f[v][i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找 LCA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inOneChain</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (LCA(u, w) == w) &amp;&amp; (dep[w] &gt;= dep[v]);</span><br><span class="line"><span class="comment">// 判断链和深度关系</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a0, <span class="keyword">int</span> b0, <span class="keyword">int</span> c0, <span class="keyword">int</span> d0)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lca1 = LCA(a0, b0);</span><br><span class="line"><span class="keyword">int</span> lca2 = LCA(c0, d0);</span><br><span class="line"><span class="keyword">return</span> (inOneChain(a0, lca1, lca2) || inOneChain(b0, lca1, lca2)</span><br><span class="line">|| inOneChain(c0, lca2, lca1) || inOneChain(d0, lca2, lca1));</span><br><span class="line"><span class="comment">// 四者只要满足其一就会有交集，所以取或就行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"inter.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"inter.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="comment">// 我也不知道为什么，fstream 一关掉同步就会崩，无奈只能用 freopen</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">init();</span><br><span class="line"><span class="comment">// 循环时 i 只能到 n - 1，还是提醒仔细读题</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">addDuplexEdge(u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)); <span class="comment">// 别忘记初始化</span></span><br><span class="line">rDFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="keyword">if</span> (judge(a, b, c, d)) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[评价]</strong></p><p>思维难度较大，想到求交集的方法后仍然要画很多图来总结规律，否则规律很有可能是错误的或者是片面的。再次提醒仔细读题，因为题目中包含了很多隐藏条件，这些隐藏条件也尤为重要，不管是对正解还是对<del>暴力</del>朴素算法来说，都可以提高效率。这是一道难题，还是一道坑题。</p><h3 id="T3-聪明格-kenken-cpp-c-pas"><a href="#T3-聪明格-kenken-cpp-c-pas" class="headerlink" title="T3 聪明格(kenken.cpp/c/pas)"></a>T3 聪明格(kenken.cpp/c/pas)</h3><p><strong>[题目描述]</strong><br>聪明格是一种数字游戏，又堪称升级版的数独，诞生日本。它在数学上的要求比数独要高得多，它把数独规则与加减乘除四则运算相结合，使大脑在各种谜题中来回穿梭。</p><p>它的规则是这样的：<br>有一个 $n\times n$ 的棋盘，每个格子里填一个在 1~n 范围内的数，使得每行每列没有重复的数字，(即 1~n 每个数在每行和每列各出现一次)，且满足下列条件:</p><div style="align: center"> <img src="pic3.jpg"> </div><br><div style="align: center"> <img src="pic4.jpg"> </div><p>现在给你一个 $n\times n$ 的棋盘，让你完成它，并输出解的个数和字典序最小的方案。数据保证一定有解。 </p><p><strong>[输入]</strong></p><pre><code>第一行一个正整数 n，表示棋盘的行数和列数。接下来 n 行，每行 n 个正整数。表示：相同数字构成了许多个连通块，假设这个四连通块内每个数字都为 a,那么你在这些格子上填的数的乘积应该等于 a。（具体描述见样例）</code></pre><p><strong>[输出]</strong></p><pre><code>输出共 n+1 行，第一行输出解的个数接下来 n 行，每行 n 个正整数。表示 n*n 的矩阵里每个数字的值（字典序最小的方案）。 </code></pre><p><strong>[输入样例 1]</strong></p><pre><code>46 6 1 1446 2 144 1444 2 144 412 12 4 4注：此样例所对应 4*4 的棋盘即为上图。 </code></pre><p><strong>[输出样例 1]</strong></p><pre><code>12 3 1 41 2 4 34 1 3 23 4 2 1</code></pre><p><strong>[输入样例 2]</strong></p><pre><code>312 12 1812 12 1818 18 18</code></pre><p><strong>[输出样例 2]</strong></p><pre><code>41 2 32 3 13 1 2</code></pre><p><strong>[输入样例 3]</strong></p><pre><code>932353542 4254 54 544322735576 10108108 1084927576576 1040 40 1008 10089270576576 814 14 1008 1008142702705768105 328314426882727 105 32810302688268880 6105 63 631030 2688 12680 8024 3 63966126126 126 24 24 40 40</code></pre><p><strong>[输出样例 3]</strong></p><pre><code>18 1 5 6 7 9 2 3 44 3 7 8 5 6 9 2 11 9 4 3 2 8 5 6 79 5 3 1 8 2 7 4 67 6 9 2 1 5 4 8 32 4 6 9 3 7 8 1 55 7 8 4 6 3 1 9 26 8 2 5 4 1 3 7 93 2 1 7 9 4 6 5 8</code></pre><p><strong>[数据规模]</strong></p><table><thead><tr><th style="text-align:center">测试点</th><th style="text-align:center">n=</th><th style="text-align:center">输入矩阵中不同种类数字个数</th></tr></thead><tbody><tr><td style="text-align:center">1-2</td><td style="text-align:center">3</td><td style="text-align:center">&gt;=3</td></tr><tr><td style="text-align:center">3-4</td><td style="text-align:center">5</td><td style="text-align:center">&gt;=10</td></tr><tr><td style="text-align:center">5-7</td><td style="text-align:center">9</td><td style="text-align:center">&gt;=30</td></tr><tr><td style="text-align:center">8-10</td><td style="text-align:center">9</td><td style="text-align:center">&gt;=20</td></tr></tbody></table><pre><code>100% 的数据满足，矩阵中每个数字&lt;=100,000，合法棋盘个数（解的个数）&lt;=300</code></pre><p><strong>[题解]</strong></p><p>这里先不多说了，关于舞蹈链我在后面的博客中会详细讲解，此处直接贴标程。</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">11</span>,M=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node2</span>&#123;</span> <span class="keyword">int</span> c[N][N]; &#125; ans[M];</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (node2 x,node2 y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;N; j++)</span><br><span class="line"><span class="keyword">if</span>(x.c[i][j] != y.c[i][j])</span><br><span class="line"><span class="keyword">return</span> x.c[i][j] &lt; y.c[i][j];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="keyword">int</span> x, y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; b[N * N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p[N * N]; </span><br><span class="line"><span class="keyword">int</span> a[N][N], c[N][N], h[N][N], h1[N][N], h2[N][N];</span><br><span class="line"><span class="keyword">int</span> n, cnt = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c=getchar()) <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c=getchar()) x = x * <span class="number">10</span> + c - <span class="number">48</span>;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= x; i++)</span><br><span class="line">t += (<span class="keyword">int</span>)(x % i == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;node&gt; x, <span class="built_in">vector</span>&lt;node&gt; y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x.size() == y.size())</span><br><span class="line"><span class="keyword">return</span> factor(x[<span class="number">0</span>].x) &lt;= factor(y[<span class="number">0</span>].x);</span><br><span class="line"><span class="keyword">return</span> x.size() &lt; y.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (x % i == <span class="number">0</span>) p[t].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">h[x][y] = <span class="number">1</span>;</span><br><span class="line">b[cnt].push_back((node)&#123; x, y &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line"><span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line"><span class="keyword">if</span> (tx &gt; <span class="number">0</span> &amp;&amp; tx &lt;= n &amp;&amp; ty &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">ty &lt;= n &amp;&amp; !h[tx][ty] &amp;&amp;</span><br><span class="line">a[tx][ty] == a[x][y])</span><br><span class="line">dfs(tx, ty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> dep)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillp</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> dep, <span class="keyword">int</span> s, <span class="keyword">int</span> tot)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep &gt; tot) work(t + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x=b[t][dep].x, y = b[t][dep].y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p[t].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u=p[t][i];</span><br><span class="line"><span class="keyword">if</span> ((s == u || dep &lt; tot) &amp;&amp; s % u == <span class="number">0</span> &amp;&amp;</span><br><span class="line">!h1[x][u] &amp;&amp; !h2[y][u])&#123;</span><br><span class="line">h1[x][u] = <span class="number">1</span>；</span><br><span class="line">h2[y][u] = <span class="number">1</span>;</span><br><span class="line">c[x][y] = u;</span><br><span class="line">fillp(t, dep + <span class="number">1</span>, s / u, tot);</span><br><span class="line">c[x][y] = <span class="number">0</span>;</span><br><span class="line">h1[x][u] = <span class="number">0</span>；</span><br><span class="line">h2[y][u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep &gt; cnt) &#123;</span><br><span class="line">tot++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">ans[tot].c[i][j] = c[i][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> num=b[dep][<span class="number">0</span>].x；</span><br><span class="line"><span class="keyword">int</span> tot=b[dep].size() - <span class="number">1</span>;</span><br><span class="line">fillp(dep, <span class="number">1</span>, num, tot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"kenken.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"kenken.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>); </span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">a[i][j] = read();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (!h[i][j]) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">b[cnt].push_back((node)&#123; a[i][j], <span class="number">0</span> &#125;);</span><br><span class="line">dfs(i, j);</span><br><span class="line">&#125;</span><br><span class="line">sort(b + <span class="number">1</span>, b + cnt + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">divide(i, b[i][<span class="number">0</span>].x);</span><br><span class="line">work(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">node2 t = ans[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= tot; i++)</span><br><span class="line">t = min(t, ans[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.c[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; t.c[i][n] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本次考试总结"><a href="#本次考试总结" class="headerlink" title="本次考试总结"></a>本次考试总结</h3><p>Too young, too simple, sometimes naive……还是要提高知识水平和编程素养，防止考试时 GG。</p>]]></content>
      
      <categories>
          
          <category> NOIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP 模拟 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 神题 </tag>
            
            <tag> 爆零日 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[数论] 数论基础知识----莫比乌斯函数</title>
      <link href="/2018/08/08/%E6%95%B0%E8%AE%BA-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/"/>
      <url>/2018/08/08/%E6%95%B0%E8%AE%BA-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>最近自己在自学数论，为了保证遇到数论的题的时候能从容不迫地应对，本篇文章主要是对莫比乌斯函数( $\mu{(n)}$ )的初步了解</p><a id="more"></a><h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>莫比乌斯函数 $\mu{(n)}$ 的定义如下：</p><p>$$ \mu(1) = 1; $$</p><p>如果 $n&gt;1$，写 $n=p_1^{a_1}p_2^{a_2}p_3^{a_3}…p_k^{a_k}$，则：</p><p>$$\mu(n)=<br>\begin{cases}<br>(-1)^k &amp; \text{when $a_1=a_2=a_3=…=a_k=1$,}\\<br>0 &amp; \text{otherwise.}<br>\end{cases}$$</p><p><strong>注</strong>     $\mu(n)=1$当且仅当$n$有一个大于$1$的平方因子。</p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>莫比乌斯函数在数论中经常出现（上次就被它狠狠地坑了一次），它的基本性质之一是对约束求和 $\sum_{d|n}\mu{(d)}$ 的一个重要的简明公式，它在$n$的正约数上展开，式子中的 $\left[x\right]$ 表示不大于$x$的最大整数。定理如下：</p><p><strong>[定理描述]</strong><br>如果${n}\geqslant{1}$，我们有<br>$$\sum_{d|n}\mu{(d)}=\left[\frac{1}{n}\right]=<br>\begin{cases}<br>1 &amp;\text{when $n=1$,}\\<br>0 &amp;\text{when $n&gt;1$.}<br>\end{cases}$$</p><p><strong>[定理证明]（运用了二项式定理）</strong><br>对于 $n=1$，等式显然成立。设 $n&gt;1$ 并写 $n=p_1^{a_1}…p_k^{a_k}$ ，在 $\sum_{d|n}\mu{(d)}$ 中非零的项仅来自于 $d=1$ 与 $n$ 的约数是不同素数的乘积，即<br>$$\begin{aligned}<br>\sum_{d|n}\mu{(d)}={}&amp; \mu(1)+\mu(p_1)+…+\mu(p_k)+\mu(p_1p_k)+…+{} \\<br>&amp;\mu(p_{k-1}p_k)+…+\mu(p_1p_2…p_k){}\\<br>={}&amp;1+\binom{k}{1}(-1)+\binom{k}{2}(-1)^2+…+\binom{k}{k}(-1)^k{}\\<br>={}&amp;0<br>\end{aligned}<br>$$</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>莫比乌斯函数本身其实并不难，但是要深刻地理解它还是有一点点困难的，以后会和别的有关函数结合起来进行讲解，加深记忆。</p>]]></content>
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 欧拉函数 </tag>
            
            <tag> 莫比乌斯函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP 模拟] 2018-8-7 题解: 我写了个自己都看不懂的程序</title>
      <link href="/2018/08/07/NOIP-%E6%A8%A1%E6%8B%9F-2018-8-7-%E9%A2%98%E8%A7%A3-%E6%88%91%E5%86%99%E4%BA%86%E4%B8%AA%E8%87%AA%E5%B7%B1%E9%83%BD%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2018/08/07/NOIP-%E6%A8%A1%E6%8B%9F-2018-8-7-%E9%A2%98%E8%A7%A3-%E6%88%91%E5%86%99%E4%BA%86%E4%B8%AA%E8%87%AA%E5%B7%B1%E9%83%BD%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>今天创历史新高$290$分，第三道题考完自己都没看出自己用了啥方法（Orz），感觉自已要去补数据结构……另外第一道题实在是坑……十分啊！！</p><a id="more"></a><h3 id="T1-选举"><a href="#T1-选举" class="headerlink" title="T1 选举"></a>T1 选举</h3><p><strong>[题目描述]</strong></p><p>$C$国的总统选举委员会最近遇到了一些麻烦。</p><p>他们在统计各省对H先生的支持率（百分比）时，把支持率四舍五入到了整数。等他们公布结果后，该国媒体发现这些省份的支持率之和不等于$100$（百分比）！在媒体黑幕声的质疑下，他们不得不找你寻求帮助。</p><p>你将得到各省四舍五入后的支持率，请计算这些省份的支持率在四舍五入前的和是否可能等于100？支持率是以百分比的形式统计的。<br>请注意，各省的支持率可以是一个包含任意多位的有限小数。一个小数在四舍五入到整数时，若小数点后第一位小于5则舍，大于等于5则入。</p><p>例如：<br>$26,17,58$是一种可能的支持率，因为它们可能是$25.8,16.5,57.7$四舍五入后得到的，而$25.8+16.5+57.7=100$。<br>$49,49$是一种不可能的支持率，因为当$9$的个数有限时，无论有多少个$9$，均有$49.499+…+99+49.499+…+99&lt;100$。</p><p><strong>[输入格式]</strong></p><pre><code>输入包含多组数据，第一行是一个整数T，表示数据组数。接下来是T组数据，每组数据的第一行是一个整数N，表示参与选举的省份个数。第二行是N个整数，表示各省四舍五入后的支持率。</code></pre><p><strong>[输出格式]</strong></p><pre><code>对于每组数据，若是一种可能的支持率，输出Yes，否则输出No。</code></pre><p><strong>[样例输入]</strong></p><pre><code>2249 49326 17 58</code></pre><p><strong>[样例输出]</strong></p><pre><code>NoYes</code></pre><p><strong>[数据范围与约定]</strong></p><pre><code>对于30%的数据，1&lt;=n&lt;=3；对于50%的数据，1&lt;=n&lt;=5；对于80%的数据，1&lt;=四舍五入后各省的支持率&lt;=99；对于100%的数据，1&lt;=n&lt;=10000，输入数据中的所有整数均在有符号16位整数范围内。</code></pre><p><strong>[题解]</strong></p><p>简单数值计算题，直接讨论情况并计算即可。<br>具体来讲，可以求出使用给出的$N$个支持率，最终可能的支持率的取值范围，检查该范围是否包含$100$。<br>一般情况下，一个数X在取舍前可能取$[X-0,5,X+0.5)$之间的任意数值。<br>需要注意$0$和$100$等边界问题，因为支持率（百分比）一定是一个$[0,100]$之间的数。<br>求出的取值范围最好使用整数并加以开闭区间判断，避免实数精度误差。</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int64 long long</span></span><br><span class="line"><span class="keyword">int</span> T, n, x;</span><br><span class="line">int64 sum, l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"election.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"election.out"</span>)</span></span>;</span><br><span class="line">in.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">in &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">in &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt100 = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">in &gt;&gt; x;</span><br><span class="line">sum += x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) ++cnt0;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">100</span>) ++cnt100;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">100</span>) flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">l = sum - (n - cnt0) / <span class="number">2</span>;</span><br><span class="line">r = sum + (n + cnt100) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> cond0 = (l &lt;= <span class="number">100</span>);</span><br><span class="line"><span class="keyword">bool</span> cond1;</span><br><span class="line"><span class="keyword">if</span> ((n - cnt100) &amp; <span class="number">1</span> || (n - cnt100) == <span class="number">0</span>)</span><br><span class="line">cond1 = (r &gt;= <span class="number">100</span>);</span><br><span class="line"><span class="keyword">else</span> cond1 = r &gt; <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (cond0 &amp;&amp; cond1) out &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> out &lt;&lt; <span class="string">"No"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：这个其实是标程，连 double 都没有用 （Orz）</span></span><br></pre></td></tr></table></figure><p><strong>[评价]</strong></p><p>考察了基础的数学知识，只要搞清楚开区间和闭区间就好了。</p><h3 id="T2-异象石"><a href="#T2-异象石" class="headerlink" title="T2 异象石"></a>T2 异象石</h3><p><strong>[题目描述]</strong></p><p>Adera 是 Microsoft 应用商店中的一款解谜游戏。<br>异象石是进入 Adera 中异时空的引导物，在 Adera 的异时空中有一张地图。这张地图上有$N$个点，<br>有$N-1$条双向边把它们连通起来。起初地图上没有任何异象石，在接下来的$M$个时刻中，每个时刻<br>会发生以下三种类型的事件之一：</p><ol><li>地图的某个点上出现了异象石（已经出现的不会再次出现）；</li><li>地图某个点上的异象石被摧毁（不会摧毁没有异象石的点）；</li><li>向玩家询问使所有异象石所在的点连通的边集的总长度最小是多少。</li></ol><p>请你作为玩家回答这些问题。</p><p><strong>[输入格式]</strong></p><pre><code>第一行有一个整数N，表示点的个数。接下来N-1行每行三个整数x,y,z，表示点x和y之间有一条长度为z的双向边。第N+1行有一个正整数M。接下来M行每行是一个事件，事件是以下三种格式之一：+ x  表示点x上出现了异象石- x  表示点x上的异象石被摧毁?表示询问使当前所有异象石所在的点连通所需的边集的总长度最小是多少。</code></pre><p><strong>[输出格式]</strong></p><pre><code>对于每个 ?事件，输出一个整数表示答案。</code></pre><p><strong>[样例输入]</strong></p><pre><code>61 2 11 3 54 1 74 5 36 4 210+ 3+ 1?+ 6?+ 5?- 6- 3?</code></pre><p><strong>[样例输出]</strong></p><pre><code>5141710</code></pre><p><strong>[数据范围与约定]</strong></p><pre><code>对于30%的数据，1 ≤ n, m ≤ 1000。对于另20%的数据，地图是一条链，或者一朵菊花。对于100%的数据，1 ≤ n, m ≤ 10^5, 1 ≤ x, y ≤ n, x ≠ y, 1 ≤ z ≤ 10^9。</code></pre><p><strong>[题解]</strong></p><p>如果在$a_1,a_2…a_k$这些点上有异象石，则所需代价就是按照DFS序依次遍历这$k$个点再回到根的总距离。<br>这个距离数还等于$a_1,a_2…a_k$排成一个环形序列，相邻两个点的距离之和。<br>因此用set维护有异象石的点构成的DFS序，用一个全局变量记录答案，插入、删除时更新set的同时利用LCA算法更新答案。</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 110000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int64 long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x, y, z, v;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">int64 ans, dis[maxn], g[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn][<span class="number">20</span>], dep[maxn], dfn[maxn], seq[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edgeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> vertexTo;</span><br><span class="line"><span class="keyword">int</span> edgeNext;</span><br><span class="line"><span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">edgeNode edges[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> heads[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> numEdges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(heads, NOE, <span class="keyword">sizeof</span>(heads)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">numEdges++;</span><br><span class="line">edges[numEdges].vertexTo = vertex2;</span><br><span class="line">edges[numEdges].weight = weight;</span><br><span class="line">edges[numEdges].edgeNext = heads[vertex1];</span><br><span class="line">heads[vertex1] = numEdges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addDuplexEdge</span><span class="params">(<span class="keyword">int</span> vertex1, <span class="keyword">int</span> vertex2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">addEdge(vertex1, vertex2, weight);</span><br><span class="line">addEdge(vertex2, vertex1, weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rDFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">f[x][<span class="number">0</span>] = fa;</span><br><span class="line">dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">dfn[x] = ++cnt;</span><br><span class="line">seq[cnt] = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123;</span><br><span class="line"><span class="keyword">int</span> vt = edges[i].vertexTo;</span><br><span class="line"><span class="keyword">if</span> (vt != fa) &#123;</span><br><span class="line">dis[vt] = dis[x] + edges[i].weight;</span><br><span class="line">rDFS(vt, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">initFa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">f[j][i] = f[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line"><span class="keyword">int</span> t = dep[x] - dep[y];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">16</span>; ++i)</span><br><span class="line"><span class="keyword">if</span> (t &amp; (<span class="number">1</span> &lt;&lt; i)) x = f[x][i];</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">16</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">if</span> (f[x][i] != f[y][i]) &#123;</span><br><span class="line">x = f[x][i];</span><br><span class="line">y = f[y][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> int64 <span class="title">getDist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> dis[x] + dis[y] - dis[LCA(x, y)] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;l, <span class="keyword">int</span> &amp;r)</span> </span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.lower_bound(x);</span><br><span class="line"><span class="keyword">if</span> (it != s.end()) r = *it;</span><br><span class="line"><span class="keyword">else</span> r = *s.begin();</span><br><span class="line"><span class="keyword">if</span> (it == s.begin()) it = s.end();</span><br><span class="line">l = *(--it);</span><br><span class="line">l = seq[l];</span><br><span class="line">r = seq[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!s.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">find(dfn[x], l, r);</span><br><span class="line">ans -= g[r];</span><br><span class="line">g[x] = getDist(l, x);</span><br><span class="line">g[r] = getDist(x, r);</span><br><span class="line">ans += g[x] + g[r];</span><br><span class="line">&#125; <span class="keyword">else</span> g[x] = <span class="number">0</span>;</span><br><span class="line">s.insert(dfn[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line">s.erase(dfn[x]);</span><br><span class="line"><span class="keyword">if</span> (!s.empty()) &#123;</span><br><span class="line">find(dfn[x], l, r);</span><br><span class="line">ans -= g[x] + g[r];</span><br><span class="line">g[r] = getDist(l, r);</span><br><span class="line">&#125;</span><br><span class="line">ans += g[r];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"stone.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"stone.out"</span>)</span></span>;</span><br><span class="line">in.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">in &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">in &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">addDuplexEdge(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rDFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">initFa();</span><br><span class="line"></span><br><span class="line">in &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">in &gt;&gt; op;</span><br><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span> : &#123;</span><br><span class="line">in &gt;&gt; v;</span><br><span class="line">insert(v);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span> : &#123;</span><br><span class="line">in &gt;&gt; v;</span><br><span class="line">erase(v);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'?'</span> : &#123;</span><br><span class="line">out &lt;&lt; ans / <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这道题必须一次操作更新一次答案，否则会 TLE</span></span><br></pre></td></tr></table></figure><p>此处附上 std::set 的<a href="https://zh.cppreference.com/w/cpp/container/set" target="_blank" rel="noopener">用法</a></p><p><strong>[评价]</strong></p><p>对于没有做过的同学来说，思维难度还是比较大的，这种方法就直接记住就行了，要用的时候直接拿出来用。</p><h3 id="T3-序列变换（本次重点！！！）"><a href="#T3-序列变换（本次重点！！！）" class="headerlink" title="T3 序列变换（本次重点！！！）"></a>T3 序列变换（本次重点！！！）</h3><p><strong>[题目描述]</strong></p><p>给定一个长度为$N$的数列$A_i$。<br>你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。<br>求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。</p><p><strong>[输入格式]</strong></p><pre><code>第一行是一个正整数N。第二行是N个正整数Ai。</code></pre><p><strong>[输出格式]</strong></p><pre><code>输出一个整数，表示最少需要的操作次数。</code></pre><p><strong>[样例输入]</strong></p><pre><code>56 3 7 8 6</code></pre><p><strong>[样例输出]</strong></p><pre><code>2</code></pre><p><strong>[数据范围与约定]</strong></p><pre><code>对于30%的数据，满足1≤n≤10。对于60% 的数据，满足1≤n≤1000。对于100% 的数据，满足1≤n≤1000000，1≤Ai≤1000000。</code></pre><p><strong>[题解]</strong></p><p>经过分析可以发现，最优解情况下，需要保持一个子序列不动，这个子序列满足：</p><ol><li>子序列单调递增；</li><li>若子序列中最小数是$L$，最大数是$R$，则子序列必须包含$[L+1,R-1]$中的数列中的所有数。</li></ol><p>用单调队列求出满足这两个条件的子序列的最大长度，用$n$减去就是答案。<br>即这个子序列保持不动，其余数向前或后移动一次。</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为 std 代码，不感兴趣的同学可以跳过</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[SIZE], q[SIZE];</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"change.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"change.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">b[a[i]].push_back(i);</span><br><span class="line">m = max(m, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">reverse(b[i].begin(), b[i].end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">int</span> k = b[i][j];</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r &amp;&amp; q[r] &gt; k) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, r - l + <span class="number">2</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = b[i].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">q[++r] = b[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是考试时瞎打的代码：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, A[maxn], B[maxn];</span><br><span class="line"><span class="keyword">int</span> ans = -INF;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A[x] == A[y]) <span class="keyword">return</span> x &lt; y;</span><br><span class="line"><span class="keyword">return</span> A[x] &lt; A[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"change.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"change.out"</span>)</span></span>;</span><br><span class="line">in.tie(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">in &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">in &gt;&gt; A[i];</span><br><span class="line">B[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">sort(B + <span class="number">1</span>, B + n + <span class="number">1</span>, compare);</span><br><span class="line"><span class="comment">// B 数组记录 A 中元素的 位置，且以 A 中相应的元素大小为优先排序</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i = j + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = i; i &lt; n &amp;&amp; B[j] &lt; B[j + <span class="number">1</span>]; j++);</span><br><span class="line">len = j - i + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 以上这段先找出从 i 开始序号递增的子序列的最大长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k != <span class="number">0</span> &amp;&amp; A[B[k]] == A[B[i - <span class="number">1</span>]]; --k)</span><br><span class="line"><span class="keyword">if</span> (B[k] &lt; B[i]) len++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= n &amp;&amp; A[B[j + <span class="number">1</span>]] == A[B[k]]; ++k)</span><br><span class="line"><span class="keyword">if</span> (B[j] &lt; B[k]) len++;</span><br><span class="line"><span class="comment">// 因为前面 i 直接变为 j + 1，所以可能出现重复的数字忽略的情况</span></span><br><span class="line"><span class="comment">// 故在上面两个循环中：</span></span><br><span class="line"><span class="comment">// 一个向左扫，一个向右扫，同时判断在原数组中的位置是否递增</span></span><br><span class="line"><span class="comment">// 这种方法速度会更快一点。</span></span><br><span class="line">ans = max(ans, len);</span><br><span class="line"><span class="comment">// 获取最大长度</span></span><br><span class="line">&#125;</span><br><span class="line">out &lt;&lt; n - ans;</span><br><span class="line"><span class="comment">// 相减</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考完试后自己都无法记起这是什么神奇的算法，不过仔细想想还是能想起来的。</span></span><br></pre></td></tr></table></figure><p><strong>[评价]</strong></p><p>这道题既考验思维又考验代码能力，好题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先，仍然要记住仔细读题，这次第一题就是因为读题不仔细，思考不充分才出问题的。<br>其次，有些代码还是好好打打草稿，写写流程图比较好，防止像第三题一样想不起来（#滑稽）。</p>]]></content>
      
      <categories>
          
          <category> NOIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP 模拟 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 神题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[NOIP 模拟] 2018-8-6 题解: 一次戏剧性的模拟测试</title>
      <link href="/2018/08/06/NOIP-%E6%A8%A1%E6%8B%9F-2018-8-6-%E9%A2%98%E8%A7%A3-%E4%B8%80%E6%AC%A1%E6%88%8F%E5%89%A7%E6%80%A7%E7%9A%84%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/08/06/NOIP-%E6%A8%A1%E6%8B%9F-2018-8-6-%E9%A2%98%E8%A7%A3-%E4%B8%80%E6%AC%A1%E6%88%8F%E5%89%A7%E6%80%A7%E7%9A%84%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>今天模拟测试一共有三道题，这里先发一下有关这三道题的题解，有关这几类题目的详解会在以后更新。<br><a id="more"></a></p><h3 id="T1-奇数码问题"><a href="#T1-奇数码问题" class="headerlink" title="T1 奇数码问题"></a>T1 奇数码问题</h3><p><strong>[题目描述]</strong></p><p>你一定玩过八数码游戏，它实际上是在一个$3\times 3$的网格中进行的，$1$个空格和$1 \sim 8$这$8$个数字恰好不重不漏地分布在这$3 \times 3$的网格中。</p><p>例如：</p><pre><code>5 2 81 3 _4 6 7</code></pre><p>在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。<br>例如在上例中，空格可与左、上、下面的数字交换，分别变成：</p><pre><code>5 2 8       5 2 _      5 2 81 _ 3       1 3 8      1 3 74 6 7       4 6 7      4 6 _</code></pre><p>奇数码游戏是它的一个扩展，在一个$n \times n$的网格中进行，其中n为奇数，1个空格和$1 \sim n\times n-1$这$n\times n-1$个数恰好不重不漏地分布在$n\times n$的网格中。</p><p>空格移动的规则与八数码游戏相同，实际上，八数码就是一个$n=3$的奇数码游戏。</p><p>现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。</p><p><strong>[输入格式]</strong></p><pre><code>多组数据，对于每组数据：第1行一个奇整数n。接下来n行每行n个整数，表示第一个局面。接下来n行每行n个整数，表示第二个局面。局面中每个整数都是0~n*n-1之一，其中用0代表空格，其余数值与奇数码游戏中的意义相同，保证这些整数的分布不重不漏。</code></pre><p><strong>[输出格式]</strong></p><pre><code>对于每组数据，若两个局面可达，输出TAK，否则输出NIE。</code></pre><p><strong>[样例输入]</strong></p><pre><code>31 2 30 4 67 5 81 2 34 5 67 8 0100</code></pre><p><strong>[样例输出]</strong></p><pre><code>TAKTAK</code></pre><p><strong>[数据范围与约定]</strong></p><pre><code>对于30%的数据，1&lt;=n&lt;=3；对于60%的数据，1&lt;=n&lt;=50；对于100%的数据，1&lt;=n&lt;=500，n为奇数，每个测试点不超过10组。</code></pre><p><strong>[题解]</strong></p><p>通过题目可知，这是一道经典的八数码问题，可以说是模板题。<br>对于这种问题，可以把方阵转为链（忽略输入的$0$），然后统计初始状态和目标状态的逆序对的数量。<br>若逆序对数的奇偶性相同，则可以到达，否则不行。</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, t[<span class="number">300010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += i &amp; -i) ++t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= i &amp; -i)</span><br><span class="line">res += t[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line"><span class="keyword">if</span> (!a) <span class="keyword">continue</span>;</span><br><span class="line">cnt += query(n) - query(a);</span><br><span class="line">modify(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">freopen(<span class="string">"digital.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">"digital.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>; ) &#123;</span><br><span class="line">n *= n;</span><br><span class="line"><span class="keyword">if</span> (work() == work()) <span class="built_in">printf</span>(<span class="string">"TAK\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NIE\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处使用了树状数组做</span></span><br><span class="line"><span class="comment">// 本题还可以使用归并排序做，有兴趣的同学可以试试看用归并排序做。</span></span><br></pre></td></tr></table></figure><p><strong>[评价]</strong></p><p>第一题嘛……水题，模板题，送分题……</p><h3 id="T2-树洞"><a href="#T2-树洞" class="headerlink" title="T2 树洞"></a>T2 树洞</h3><p><strong>[题目描述]</strong></p><p>在一片栖息地上有$N$棵树，每棵树下住着一只兔子，有$M$条路径连接这些树。更特殊地是，只有一棵树有$3$条或更多的路径与它相连，其它的树只有$1$条或$2$条路径与其相连。换句话讲，这些树和树之间的路径构成一张$N$个点、$M$条边的无向连通图，而度数大于$2$的点至多有$1$个。</p><p>近年以来，栖息地频繁收到人类的侵扰。兔子们联合起来召开了一场会议，决定在其中$K$棵树上建造树洞。当危险来临时，每只兔子均会同时前往距离它最近的树洞躲避，路程中花费的时间在数值上等于距离。为了在最短的时间内让所有兔子脱离危险，请你安排一种建造树洞的方式，使最后一只到达树洞的兔子所花费的时间尽量少。</p><p><strong>[输入格式]</strong></p><pre><code>第一行有3个整数N，M，K，分别表示树（兔子）的个数、路径数、计划建造的树洞数。接下来M行每行三个整数x,y，表示第x棵树和第y棵树之间有一条路径相连。1&lt;=x,y&lt;=N，x≠y，任意两棵树之间至多只有1条路径。</code></pre><p><strong>[输出格式]</strong></p><pre><code>一个整数，表示在最优方案下，最后一只到达树洞的兔子所花费的时间。</code></pre><p><strong>[样例输入]</strong></p><pre><code>5 5 21 22 33 11 44 5</code></pre><p><strong>[样例输出]</strong></p><pre><code>1</code></pre><p><strong>[数据范围与约定]</strong></p><pre><code>对于20%的数据，1 ≤  n ≤ 10。对于另外30%的数据，每棵树至多与2条路径相连。对于另外30%的数据，保证存在一种最优解，使与3条或更多路径相连的树上一定建造了树洞。对于100%的数据，1 ≤ n ≤ 2000，n-1&lt;=m&lt;=n*(n-1)/2。</code></pre><p><strong>[题解]</strong></p><p>求最大值最小，而且答案满足单调，很显然可以用二分<br>如何验证？<br>首先考虑一条链的情况，答案必然是$\frac{n - k}{k}$；</p><p>而另外存在一个特殊点有三条及以上的边的情况<br>我们先枚举一个点，可以将特殊点覆盖，覆盖后，<br>原来的图将断成若干条链，然后重复之前链的做法统计答案是否超过k，<br>来判断二分的答案是否正确</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, rt, deep, mi;</span><br><span class="line"><span class="keyword">int</span> deg[<span class="number">2005</span>], dis[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2005</span>], first[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">2005</span>], num;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125; e[<span class="number">4000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">e[++num].nxt = head[x];</span><br><span class="line">e[num].to = y;</span><br><span class="line">head[x] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">deep += <span class="number">1</span>;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!len) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">dis[v] = dis[x] + <span class="number">1</span>;</span><br><span class="line">dfs(v, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">dfs(rt, x);</span><br><span class="line"><span class="built_in">memcpy</span>(first, vis, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (first[i]) &#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">dfs(i, x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; res &lt; k; j++)</span><br><span class="line"><span class="keyword">if</span> (!vis[j]) &#123;</span><br><span class="line">deep = <span class="number">0</span>;</span><br><span class="line">dfs(j, n);</span><br><span class="line">res += (deep + <span class="number">2</span> * x) / (<span class="number">2</span> * x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (res &lt; k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">deg[x]++;</span><br><span class="line">deg[y]++;</span><br><span class="line">add(x, y);</span><br><span class="line">add(y, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (deg[i] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">rt=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!rt) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (n + k - <span class="number">1</span>) / k / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = n - <span class="number">1</span>, ans = n;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (check(mid)) &#123;</span><br><span class="line">ans = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>[评价]</strong></p><p>之所以标题称这次模拟为“戏剧性的模拟测试”，是因为这道题一开始不会，用了个随机数骗了个 10 分（逃）。</p><p>虽然这种骗分方法不值得提倡，但也是没有办法的办法，毕竟信奥有时就是这么玄。</p><p>对于这种二分答案的题要记住题目所满足的条件：单调性，一般遇到最大值求最小，最小值求最大的这种坑题可以考虑二分答案的方法了。</p><h3 id="T3-まんふは函数"><a href="#T3-まんふは函数" class="headerlink" title="T3 まんふは函数"></a>T3 まんふは函数</h3><p><strong>[吐槽]</strong></p><p>为什么这道题一上来就吐槽呢？首先，这道题的思维难度比较大，其次，这道题的思维难度比较小（WTF!!??）。</p><div style="align: center"> <img src="黑人问号.jpg"> </div><br>首先来看一下题目中日语的发音：<br><div style="align: center"> <img src="翻译1.jpg"> </div><br>重新排列之后：<br><div style="align: center"> <img src="翻译2.jpg"> </div><br>经过 Google 的提醒：<br><div style="align: center"> <img src="翻译3.jpg"> </div><p>这不就是 Huffman 的意思吗……<br>明摆着让我们用霍夫曼树……</p><p>（当然，从题中所给的公式也可以看出来，比如考试的时候我就看出来了（逃）。）</p><p><strong>[题目描述]</strong></p><p>有n个正整数 $A[1], A[2]…A[n]$，满足 ${A[i]}\geqslant{A[i+1]}$。<br>它们可以产生$n$个正整数 $B[1], B[2]…B[n]$，其中 $B[i]=\sum_{j=i}^n A[j]$</p><p>まんふは函数（マンフハ函数）$f:(Z,Z) \rightarrow Z$定义为：</p><p>$$f(i,j)=<br>\begin{cases}<br>0, &amp; \text{($i$,$j$) = (1,1)}\\<br>\min\lbrace f(i-1,j+1), f(i,\lceil\frac{j}{2}\rceil)+B[i]\rbrace, &amp; i,j \in [1,n], \text{ } i,j \neq{(1,1)}\\<br>10^{11037}, &amp; \text{otherwise}<br>\end{cases}$$</p><p>试求$f(n,1)$。</p><p><strong>[输入格式]</strong></p><pre><code>输入包含多组数据，不超过10组。每组数据的第一行是一个正整数，第二行n个正整数A[i]。</code></pre><p><strong>[输出格式]</strong></p><pre><code>对于每组数据，输出一个整数表示f(n,1)。</code></pre><p><strong>[样例输入]</strong></p><pre><code>31 1 1528 26 25 24 110996 901 413 331 259 241 226 209 139 49</code></pre><p><strong>[样例输出]</strong></p><pre><code>523311037</code></pre><p><strong>[样例解释]</strong></p><pre><code>对于第一组数据：f(1, 1) = 0f(1, 2) = f(1, 1) + 3 = 3f(1, 3) = f(1, 2) + 3 = 6f(2, 1) = min(f(2, 1) + 2, f(1, 2)) = 3f(2, 2) = min(f(2, 1) + 2, f(1, 3)) = 5f(2, 3) = f(2, 2) + 2 = 7f(3, 1) = min(f(3, 1) + 1, f(2, 2)) = 5</code></pre><p><strong>[数据范围与约定]</strong></p><pre><code>对于30%的数据，满足1 ≤ n ≤ 20。对于60% 的数据，满足1 ≤ n ≤ 1000。对于 100% 的数据，满足1 ≤ n ≤ 100000，1 ≤ A[i] ≤ 10000。</code></pre><p><strong>[题解]</strong></p><p>对于会日语的同学，直接看吐槽就行了，如果不会日语呢？<br>先仔细读题，研究题中所给的表达式，有两个边界条件，这是不是很像状态转移方程？<br>那么我们就可以从动态规划的角度来解决题目的意思。$B$ 数组其实是 $A$ 的一个后缀和，<br>而 $min$ 中的两个 $f(i,j)$, 一个减一，一个除以二，自然而然地联想到这是树的合并，<br>记 $f(i,j)$ 为合并了 $i$ 个点，产生 $j$ 棵树的状态，<br>那么我们要么合并到树中，要么合并两棵子树，为了使合并的总量最小，<br>我们就可以用霍夫曼树来解了，题目的思路就开朗了。</p><p><strong>[参考代码]</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 110000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int64 long long</span></span><br><span class="line"></span><br><span class="line">int64 node[maxn], u[maxn];</span><br><span class="line">int64 tot, n, len, ans;</span><br><span class="line">int64 x, y;</span><br><span class="line"></span><br><span class="line"><span class="function">int64 <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= n &amp;&amp; (y &gt; len || node[x] &lt; u[y]))</span><br><span class="line"><span class="keyword">return</span> node[x++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> u[y++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line">y = <span class="number">1</span>;</span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="keyword">sizeof</span>(node));</span><br><span class="line"><span class="built_in">memset</span>(u, <span class="number">0</span>, <span class="keyword">sizeof</span>(u));</span><br><span class="line">tot = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tmp);</span><br><span class="line">node[tot--] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">u[len + <span class="number">1</span>] = top() + top();</span><br><span class="line">ans += u[++len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提醒注意多组数据读入问题</span></span><br><span class="line"><span class="comment">// ++i 和 i++ 的区别要清楚</span></span><br></pre></td></tr></table></figure><p><strong>[评价]</strong></p><p>好题，由类状态转移方程推出题目的原意，再进行解答，思维难度比较大，好题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天三道题，除了第三道题，另外两道题都不是很考验思维，只要还是技巧。<br>看来我还是需要提升自己的知识水平，防止再出现第二题做不出，只能随机数的情况。</p>]]></content>
      
      <categories>
          
          <category> NOIP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP 模拟 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 神题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello world!</title>
      <link href="/2018/08/05/Hello-world/"/>
      <url>/2018/08/05/Hello-world/</url>
      <content type="html"><![CDATA[<p>重新弄了一个 Github 账号，因为高中决定搞信息竞赛了，所以以后会在这个新的博客里不定期地更新一些有关信息竞赛的内容，当然也可能会更新其他的内容。<br><a id="more"></a></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>TO BE CONTINUED……</p>]]></content>
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
