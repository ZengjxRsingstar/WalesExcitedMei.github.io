<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[图论] Dijkstra 最短路计数]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%9B%BE%E8%AE%BA-Dijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面最短路计数是一个很经典的问题，今天刚好做到了这样一道题，就来总结一下。 最短路计数题目：洛谷 P1144 最短路计数最短路计数本质上还是求最短路，只不过在迭代的同时来更新最短路数量。首先来回忆一下 Dijkstra 求最短路的更新条件，对于一条有向边 $(u,v,w)$，我们更新到 $v$ 的最短路的条件是：$$dist[v] &gt; dist[u] + w$$在最短路计数的时候我们可以用动态规划的思想，记 $num[x]$ 表示到 $x$ 的最短路的数量，那么： 若 $dist[v] = dist[u] + w$ 我们更新 $num[v] = num[v] + num[u]$，即有另外一条路径。 若 $dist[v] &gt; dist[u] + w$ 我们更新 $num[v] = num[u]$，即有更短的路径，前面的全部作废。 所以这道题的代码就呼之欲出了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define maxm 2000010#define maxn 1000010#define modn 100003#define INF 0x7f7f7f7fstruct heapNode &#123; int u, d; bool operator&lt;(const heapNode &amp;b) const &#123; return d &gt; b.d; &#125; // 这里似乎是一定要加 const，否则会 CE&#125;;struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125; edges[maxm &lt;&lt; 1];int numEdges = 0, heads[maxn];priority_queue&lt;heapNode&gt; Q;int dist[maxn], num[maxn];int n, m, x, y;void init() &#123; numEdges = 0; memset(heads, -1, sizeof(heads)); memset(dist, INF, sizeof(dist)); memset(num, 0, sizeof(num)); while (!Q.empty()) Q.pop();&#125;void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125;void Dijkstra(int x) &#123; dist[x] = 0; num[x] = 1; Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int d = f.d; if (d != dist[u]) continue; for (int i = heads[u]; i != -1; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] == dist[u] + w) &#123; num[j] += num[u]; // 更新情况一 num[j] %= modn; // 题目要求取模 &#125; else if (dist[j] &gt; dist[u] + w) &#123; num[j] = num[u]; // 更新情况二 dist[j] = dist[u] + w; Q.push((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; if (x == y) continue; addDuplexEdge(x, y, 1); &#125; Dijkstra(1); for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; num[i] &lt;&lt; endl; &#125; return 0;&#125; 总结由这个最短路计数我们可以看出动态规划实在是实用啊！]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>最短路计数</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[平衡树] Treap 总结]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%B9%B3%E8%A1%A1%E6%A0%91-Treap-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[写在前面为了继续完善自己的数据结构有关的知识，决定先总结一波 Treap。Treap 是我学的第一个平衡树结构，花了很长时间才把板子背下来把它真正理解了，不禁感叹数据结构真的是神奇啊！ BST 二叉查找树的性质因为想重点总结的是 Treap 而不是普通 BST，所以这里只稍微提一下它的性质： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 BST 是 Treap 学习的基础，更多内容可以看这篇博客。上面这些性质，可以使得在 BST 上查找前驱 / 后继更为方便。这些性质是构建 BST 的基础，但是也使得 BST 不能很好地保持树的平衡，即左右子树的大小相差太大，最极端的情况就是一条链，为了保持 BST 的平衡，诞生了各种平衡树。 TreapZig 和 Zag保持 Treap 平衡的方式就是改变 Treap 的形态，同时又必须保证 Treap 仍然具备 BST 的性质，于是 Zig 和 Zag 操作就诞生了 可见这并不是简单的旋转，它还将某个节点向根节点移动，这个过程只可意会不可言传，还是好好理解上图。旋转的代码实现如下：12345678910111213void zig(int &amp;p) &#123; int q = treap[p].lChild; treap[p].lChild = treap[q].rChild; treap[q].rChild = p; p = q;&#125;void zag(int &amp;p) &#123; int q = treap[p].rChild; treap[p].rChild = treap[q].lChild; treap[q].lChild = p; p = q;&#125; 保证 Treap 的平衡什么样的旋转才能保证它的平衡呢？Treap 是 Tree 和 Heap 的复合名词，所以它还满足堆性质。它利用“随机”来创造平衡的条件，每一个节点都有一个随机生成的额外权值，Treap 在满足 BST 性质的同时还通过旋转使得权值满足大根堆的性质。特别的，在删除 Treap 的节点时，可以直接把这个节点旋转到叶节点来直接删除，这样就免去了很多复杂的操作。 从一道例题看代码实现题目在这：洛谷 P3369 【模板】普通平衡树 因为题目中同一个节点可能有多个，所以可以为每个节点增加一个“副本数”，同时在获取 Rank 的时候别忘了减一，因为初始化的时候有一个正无穷，一个负无穷，它们只是为了保证 BST 性质，并不是实际的节点。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define INF 0x7fffffffstruct treapNode &#123; int lChild, rChild; // 左右子节点下标 int value, weight; // 节点关键码及权值 int count, size; // 副本数及子树大小&#125; treap[maxn];int numNodes, root, n;int newNode(int val) &#123; numNodes++; treap[numNodes].value = val; treap[numNodes].weight = rand(); // 随机权值 treap[numNodes].count = treap[numNodes].size = 1; return numNodes;&#125; // 建立一个新的节点void update(int p) &#123; treap[p].size = treap[treap[p].lChild].size + treap[treap[p].rChild].size + treap[p].count;&#125; // 更新某一个点的 size 方便获取排名void build() &#123; newNode(-INF); // 保证 BST 性质的两个点 newNode(INF); root = 1; treap[root].rChild = 2; update(root);&#125; // 初始化int getRankByVal(int p, int val) &#123; if (p == 0) return 0; if (val == treap[p].value) return treap[treap[p].lChild].size + 1; if (val &lt; treap[p].value) return getRankByVal(treap[p].lChild, val); return getRankByVal(treap[p].rChild, val) + treap[treap[p].lChild].size + treap[p].count;&#125;// 上下两个函数很好理解，不作赘述// 一切从 BST 性质出发int getValByRank(int p, int rnk) &#123; if (p == 0) return INF; if (treap[treap[p].lChild].size &gt;= rnk) return getValByRank(treap[p].lChild, rnk); if (treap[treap[p].lChild].size + treap[p].count &gt;= rnk) return treap[p].value; return getValByRank(treap[p].rChild, rnk - treap[treap[p].lChild].size - treap[p].count);&#125;void zig(int &amp;p) &#123; int q = treap[p].lChild; treap[p].lChild = treap[q].rChild; treap[q].rChild = p; p = q; update(treap[p].rChild); update(p); // 别忘记更新&#125;void zag(int &amp;p) &#123; int q = treap[p].rChild; treap[p].rChild = treap[q].lChild; treap[q].lChild = p; p = q; update(treap[p].lChild); update(p);&#125;void insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == treap[p].value) &#123; treap[p].count++; update(p); return; &#125; if (val &lt; treap[p].value) &#123; insert(treap[p].lChild, val); if (treap[p].weight &lt; treap[treap[p].lChild].weight) zig(p); &#125; else &#123; insert(treap[p].rChild, val); if (treap[p].weight &lt; treap[treap[p].rChild].weight) zag(p); &#125; // zig 和 zag 操作，保证满足大根堆性质 update(p);&#125; // 插入一个点int getPre(int val) &#123; int ans = 1; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].lChild &gt; 0) &#123; p = treap[p].lChild; // 左子树上不断向右走，获取最大的前驱 while (treap[p].rChild &gt; 0) p = treap[p].rChild; ans = p; &#125; break; &#125; if (treap[p].value &lt; val &amp;&amp; treap[p].value &gt; treap[ans].value) ans = p; // 尝试更新答案 p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125; // 获取前驱int getNext(int val) &#123; int ans = 2; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].rChild &gt; 0) &#123; p = treap[p].rChild; // 右子树上不断向左走，获取最小的后继 while (treap[p].lChild &gt; 0) p = treap[p].lChild; ans = p; &#125; break; &#125; if (treap[p].value &gt; val &amp;&amp; treap[p].value &lt; treap[ans].value) ans = p; // 尝试更新答案 p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125;void remove(int &amp;p, int val) &#123; if (p == 0) return; if (val == treap[p].value) &#123; if (treap[p].count &gt; 1) &#123; treap[p].count--; update(p); &#125; else if (treap[p].lChild != 0 || treap[p].rChild != 0) &#123; if (treap[p].rChild == 0 || treap[treap[p].lChild].weight &gt; treap[treap[p].rChild].weight) &#123; zig(p); remove(treap[p].rChild, val); &#125; else &#123; zag(p); remove(treap[p].lChild, val); &#125; // 通过旋转来删除节点 update(p); &#125; else p = 0; return; &#125; if (val &lt; treap[p].value) remove(treap[p].lChild, val); else remove(treap[p].rChild, val); update(p);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); numNodes = 0; build(); cin &gt;&gt; n; int opt, x; while (n--) &#123; cin &gt;&gt; opt &gt;&gt; x; switch (opt) &#123; case 1: &#123; insert(root, x); break; &#125; case 2: &#123; remove(root, x); break; &#125; case 3: &#123; cout &lt;&lt; getRankByVal(root, x) - 1 &lt;&lt; endl; break; &#125; // 减一 case 4: &#123; cout &lt;&lt; getValByRank(root, x + 1) &lt;&lt; endl; break; &#125; // 加一 case 5: &#123; cout &lt;&lt; getPre(x) &lt;&lt; endl; break; &#125; case 6: &#123; cout &lt;&lt; getNext(x) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; 总结班里的某个大佬和我说 Treap 没有 ZigZag，这让我很懵逼。但是 Zig 和 Zag 操作的确是很重要的，似乎在学 Splay 的时候也会用到，多学无害。Treap 还是很有用的，关键时候可以救命。]]></content>
      <categories>
        <category>平衡树</category>
      </categories>
      <tags>
        <tag>树形结构</tag>
        <tag>Treap</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论] OI 中素数有关的算法整理]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%95%B0%E8%AE%BA-OI-%E4%B8%AD%E7%B4%A0%E6%95%B0%E6%9C%89%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[写在前面本来是想总结一道数论神题的，但是怎么证明似乎都不是很完美，而且代码的实现涉及到很多数论有关的算法，于是想现总结一下与素数有关的算法。 素数的判定Brute-Force 朴素算法额，这个就不多说了吧，最无脑的，$2\thicksim n$ 枚举所有小于 $n$ 的数来进行判定。 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;bool isPrime(int n) &#123; if (n == 2) return true; for (int i = 2; i &lt; n; ++i) if (n % i == 0) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (isPrime(n) ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; Optimized-Brute-Force 优化过的朴素算法如果一个数不是素数是合数， 那么一定可以由两个大于 $1$ 自然数相乘得到， 其中一个大于或等于它的平方根，一个小于或等于它的平方根。并且成对出现。所以可以优化朴素算法 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;bool isPrime(int n) &#123; if (n == 2) return true; for (int i = 2; i * i &lt; n; ++i) if (n % i == 0) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (isPrime(n) ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; 筛法求素数上面两个菜鸡方法只能针对数很小的情况，这些情况在 OI 中出现的话出卷老师会死得很惨变成广大 OIer 的恩人，然而这种情况是不可能的。于是又有了更高效的方法——筛法。它的思想就是将一个范围内的素数全部筛出来，预处理之后方便查找和判定。最朴素的筛法莫过于 Eratosthenes 筛法了（不要纠结这个名字怎么读，因为我也不会），它是将所有素数的倍数都给筛掉，剩下的就是素数了。时间复杂度为 $O(N\log\log N)$ 接近线性 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1000010bool prime[maxn];void Eratosthenes() &#123; memset(prime, true, sizeof(prime)); prime[1] = false; for (int i = 2; i &lt;= maxn; ++i) &#123; if (!prime[i]) continue; for (int j = i; j &lt;= maxn / i; ++j) &#123; // 这里是一个小优化，因为小于 i^2 的数在前面肯定已经筛过了 // 所以 j 从 i 开始取 prime[j * i] = false; &#125; &#125;&#125;int main() &#123; int n; Eratosthenes(); cin &gt;&gt; n; cout &lt;&lt; (prime[n] ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; 然而，Eratosthenes 筛会重复标记素数，造成时间复杂度冗余，如果对于每个数有唯一的方法确定它，那么就可以解决这个问题。由此引出了线性筛这个方法，它通过从大到小累计质因子的方法标记每一个合数，即让 $12$ 只有 $2\times 2\times 3$ 这种产生方式。设数组 $fac$ 记录每个数的最小质因子，我们按照下面的步骤来维护 $fac$： 依次考虑 $1\thicksim n$ 之见的每一个数 $i$ 若 $fac[i]=i$ 说明 $i$ 是质数，将它保存下来 扫描不大于 $fac[i]$ 的每个质数 $p$，令 $fac[i\times p]=p$，即在 $i$ 的基础上累积一个质因子 $p$，因为 $p\leqslant fac[i]$，所以 $p$ 为合数 $i\times p$ 的最小质因子。 这样子，每个合数只会被它的最小质因子 $p$ 筛一次，时间复杂度为线性。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1000010int fac[maxn], prime[maxn];void LinearSieve(int n) &#123; memset(fac, 0, sizeof(fac)); int m = 0; for (int i = 2; i &lt;= n; ++i) &#123; if (fac[i] == 0) &#123; fac[i] = i; prime[++m] = i; &#125; for (int j = 1; j &lt;= m; ++j) &#123; // 跳出循环的条件 if (prime[j] &gt; fac[i] || prime[j] &gt; n / i) break; fac[i * prime[j]] = prime[j]; &#125; &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; prime[i] &lt;&lt; " ";&#125;int main() &#123; int n; LinearSieve(100000); return 0;&#125; 线性筛又名欧拉筛。 伪素数测试在开始 Miller-Rabin 算法之前我们先来看一下伪素数测试，首先要了解费马小定理： $a^{p-1}\equiv1(\bmod p)$ 当 $p$ 为素数时且 $gcd(a,p)=1$ 时。费马小定理的逆命题虽然不是真命题，但是几乎成立，而不成立的时候，即如果 $n$ 是一个合数且 $a^{n-1}\equiv 1(\bmod n)$，那么称 $n$ 为基为 $a$ 的伪素数。如果我们找到一个 $a$ 使得 $n$ 不满足上述等式，那么 $n$ 必定为合数，那如果满足呢？$n$ 不一定是素数，这样的数被称作 Carmicheal 数，但是这种数十分稀少，前 $10000$ 个 $n$ 中只有 $22​$ 个数为 Carmicheal 数，所以这种方法还是比较可靠的。附上算法导论中的伪代码： 因为 Carmicheal 数的存在，人们寻求更好的，更准确的素数判定方法，于是就有了 Miller-Rabin 算法 Miller-Rabin 算法通过费马小定理我们可以得出一个推论，若 $p$ 为一个奇素数，那么有：$$a^p\equiv a\pmod p,1\leqslant a\leqslant p$$ 我们记$$p-1=2^kq,2\nmid q$$设 $a$ 是不被 $p$ 整除的数，那么下面两个条件之一必然成立： $a^q \equiv 1 \pmod p$ $a^q, a^{2q}, a^{2^2q}, \dots, a^{2^{k-1}q} \equiv -1 \pmod p$ 之中有一个等式成立 根据如下命题：$$a^2 \equiv 1 \pmod p \Rightarrow a \equiv \pm 1 \pmod p$$又因为上面第二个条件中的数，每一个都是前一个的平方，且最后一个数的平方是 $1$，所以如果表中一个数它模 $p$ 不余 $1$，但是它的平方模 $p$ 余 $1$，那么那个数一定是 $-1$，所以在这种情况下表中包含 $ -1$，又或者表中全是 $1$，那么第一个条件就会成立。 所以我们得到了 Miller-Rabin 素性测试的方法，也就是说，如果一个数不满足上面的性质，那么它就是和数，这个 $a$ 就成为证据。而 Miller-Rabin 的证据和上面提到的方法的证据不同，它能够保证每一个奇合数 $p$ 都会有不少于 $\frac{(p−1)}{2}$个证据（具体证明详见算法导论）。 我们只要随机 $50$ 个数来测试，那么测试失败的概率一定小于 $2^{−50}$，大约是 $8.9⋅10^{−16}$，如果你觉得不够，还可以找更多的数来测试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;inline int64 rand64() &#123; return abs((int64)rand() &lt;&lt; 32 | rand()); &#125;inline int64 random(int64 x, int64 y) &#123; return x + rand64() % (y - x + 1); &#125;// 随机数生成函数int64 montgomery(int64 a, int64 b, int64 c) &#123; int64 result = 1; int64 temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;bool witness(int64 a, int64 p) &#123; int k = 0; int64 q = p - 1; while ((q &amp; 1) == 0) &#123; k++; q &gt;&gt;=1; &#125; int64 v = montgomery(a, q, p); // 判断一 if (v == 1 || v == p - 1) return false; while (k--) &#123; v = v * v % p; if (v == p - 1) return false; // 判断二 &#125; return true;&#125;bool MillerRabin(int64 p) &#123; if (p == 1) return false; if (p == 2) return true; if (p % 2 == 0) return false; // 这里其实可以加更多的特判来节约时间 for (int i = 1; i &lt;= 50; ++i) if (witness(random(1, p - 1), p)) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) if (MillerRabin(i)) cout &lt;&lt; i &lt;&lt; " "; // 输出 1 ~ n 之间的所有素数 return 0;&#125; 对于大的素数，为了节约判定的时间，我们只能退而求其次选择非完美算法来进行验证，不过不得不说，Miller-Rabin 其实已经很完备了。 总结事实上，对于素数的判定还有很多算法，例如 Solovay-Strassen 算法和 AKS 算法，然而这两个似乎都超出了 OI 的范围，一般不会用得到，这里也就不再赘述。 质因数分解试除法结合素数判定的“试除法”和“Eratosthenes 筛法”，我们可以扫描 $2\thicksim\lfloor\sqrt{n}\rfloor$ 中的每个数 $d$，若 $d$ 能整除 $n$，则从 $n$ 中除掉所有的因子 $d$，同时累计个数。 12345678910111213int p[maxn], c[maxn];void divide(int n) &#123; int m = 0; for (int i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; p[++m] = i; c[m] = 0; while (n % i == 0) &#123; n /= i; c[m]++; &#125; &#125; &#125; if (n &gt; 1) &#123; p[++m] = n; c[m] = 1 &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; p[i] &lt;&lt; '^' &lt;&lt; c[i] &lt;&lt; endl;&#125; Pollard-Rho 算法Pollard-Rho 也是一个不完美算法，不完美之处在时间复杂度上体现。Pollard-Rho算法分解一个数 $n$ 的过程大体上是这样子的： 找到一个数 $p$，使得 $p|n$，将 $n$ 分解为 $p$ 与 $\frac{n}{p}$ 如果 $p$ 或 $\frac{n}{p}$ 不为质数，将其带入递归上述过程 如果其是质数，将其记录并退出 那有人就会问了：这跟暴力分解有什么区别？好像时间复杂度比暴力还高啊！！？？所以，下面的优化才是关键。第一个优化，使用 Miller-Rabin 判定其是否为质数。第二个优化才是最关键的：对于一个大整数n，我们要找到一个 $p$ 满足 $p|n$，这如同大海捞针。但是如果我们要找出 $p_1$、$p_2$，使得 $(|p_1−p_2|)|n$，这看起来似乎要容易一些。实际上我们只需要找出 $\gcd((|p1−p2|),n)&gt;1$的 $p_1$、$p_2$，则其 $\gcd$ 值肯定为n的约数。这看起来又容易了一些。实际上，这让整个算法容易许多。根据生日悖论，这种两两比较的方式，在加入比较的数越来越多的时候，其效率会大大提升，比找一个数的效率快很多。于是，找 $p$ 的过程变成了这个样子： 找到一个数 $p_1$ 通过某种玄学推导手段找出一个与 $p_1$ 对应的 $p_2$ 判断 $\gcd((|p1−p2|),n)$ 是否大于 $1$，不大于则将 $p_2$作为新的 $p_1$，重复过程，否则就找到了 为什么要用玄学手段？因为只有通过推导手段，才能保证不做重复判断。理论上的推导手段可以有很多，但实际使用中一般使用如下公式推导：$$p_2=(p_1^2+c)\bmod n$$其中 $c$ 为随机常数。这个公式的好处: 推导出来的 $p_2-p_1$ 差值基本不会相等。 可以证明，该推导结果会出现循环。也就是说，在出现循环之前，结果不会重复，少做了许多无用的判断。 出现循环了怎么办？换一个随机常数再搞。这就是该算法“非完美”的地方，时间复杂度要看脸的。那么如何判环呢？这里介绍一个算法：Floyd 判圈。 需要注意的是，之所以不能一个标记定在原地，是因为循环节不一定在开头就产生，可能走着走着才遇到循环。这条路径就类似于 $\rho$，Pollard-Rho 算法也是因此得名的。顺便附上算法导论中的一张玄学图： 注意，在小数分解的时候就别用这个了，老老实实用试除法吧。 未完待续……]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论] OI 中的模运算计算方法]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%95%B0%E8%AE%BA-OI-%E4%B8%AD%E7%9A%84%E6%A8%A1%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面模运算在 OI 中是非常神奇的存在，有时候题目会非常好（m）心（m）地（p）让我们将答案取模，然而计算模的方法随着题目的变化而变化，网上很多博客又太零散，这里痛下决心总结一下。 预备知识 恒等式： $(a\bmod n)\bmod n=a\bmod n$ 对于所有的正数 $x$ 有：$n^x\bmod n = 0$ 如果 p 是一个质数，且不为 b 的因数，此时由费马小定理有：$ab^{p−1}\bmod p=a\bmod p$ 分配律 $(a-b)\bmod n=(a\bmod n-b\bmod n)\bmod n$ $(a+b)\bmod n=(a\bmod n+b\bmod n)\bmod n$ $ab\bmod n=(a\bmod n)(b\bmod n)\bmod n$ 高次幂函数的取模暴力取模法由于我们的高次幂函数往往拥有很高的幂，而我们在计算机中只有int、float、double、long long这几种变量类型，远远不能满足我们对于大数字运算的要求，从而导致数据溢出无法完成运算。所以这里我们需要在每次迭代取模的过程中进行取模运算，从而保证数据不会溢出。代码如下：1234567long long pow(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; while (b--) result = result * a % c; return result;&#125;// 计算 a^b % c 这种算法的正确性毋庸置疑，但是如果幂指数太大的话，需要耗费的时间就更非常多，直接导致运算效率低下，所以只适用于指数不大的情况下使用。 二分幂要求 $a^n$，如果知道了 $a^{\frac{n}{2}}$ 那么再平方就行了。令 $A=a^{\lfloor\frac{n}{2}\rfloor}$若 $n$ 为偶数，那么 $Result=A^2$若 $n$ 为奇数，那么 $Result=a\times A^2$这样子复杂度从 $O(n)$ 降到了 $O(\log n)$ 12345678long long pow(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; if (b == 0) return 1; long long x = pow(a, b / 2, c); long long ans = (long long)x * x % m; if (b % 2 == 1) ans = ans * a % m; return (long long)ans;&#125; 蒙哥马利算法具体详细介绍见维基百科，这里直接上代码： 1234567891011long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125; 组合数取模方法一：杨辉三角递推使用递推公式：$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$写成数组：$C[n][m]=C[n-1][m]+C[n-1][m-1]$这也是杨辉三角的递推公式，所以边界为 $C[0][0]=1$。下面给出求一个组合数的方法：123456789101112131415161718#include &lt;iostream&gt;using namespace std;int n, m;long long c[10010];int main() &#123; cin &gt;&gt; n &gt;&gt; m; m = min(m, n - m); // 因为 c[n][m] == c[n][n - m] // 所以取最小值减少运算。 c[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 1; --j) c[j] = c[j] + c[j - 1]; cout &lt;&lt; c[m]; return 0;&#125;// 因为只求一个组合数，所以使用了滚动数组的方式 由于递推时间复杂度为 $O(n^2)$，所以只适用于小数据的情况。 方法二：乘法逆元在数据很大的时候，我们对组合数取模就会比较麻烦，因为数据不一定能存下，而且通过观察组合数的公式：$$C_n^m=\frac{n!}{m!(n-m)!}=\frac{n\times (n-1)\times…\times(n-m+1)}{m!}$$我们发现组合数是带有除法的，不能走一步取一次模，为了解决除法取模的问题，人们发明了逆元这个东西。若 $a\times b\equiv1\pmod p$ 则称 $b$ 为 $a$ 在模 $p$ 下的乘法逆元，一般认为，$b &lt; p$，$b$ 记为 $a^{-1}$。注意，此处 $a$ 与 $p$ 必须互质，否则乘法逆元不存在。那么逆元该怎么用呢？当然是借助它将除法转为乘法，再用分配律来计算了。我们来看一个式子：$$\frac{a}{b}\equiv\frac{a}{b}\times b\times b^{-1}\equiv a\times b^{-1}\pmod p$$这样就可以把问题转化为求一个数的逆元，再转化为乘法运算。 递推求逆元求 $i​$ 在模 $p​$ 下的乘法逆元，满足 $gcd(i, p)=1, i&lt; p​$使用欧几里得除法的形式，令 $p=k\times i+r​$，则 $k=\lfloor\frac{p}{i}\rfloor,r=p\bmod i​$显然，$k\times i+r\equiv 0(\bmod p)​$两边同乘 $i^{-1}\times r^{-1}​$，得 $k\times r^{-1}+i^{-1}\equiv 0\pmod p​$移项，整理：$i^{-1}\equiv -k\times r^{-1}\equiv (p-k)\times r^{-1}\pmod p​$将 $k​$ 和 $r​$ 用 $p​$ 来替换：$i^{-1}\equiv (p-\lfloor\frac{p}{i}\rfloor)\times (p\bmod i)^{-1}\pmod p​$使用 inv[i] 来表示 i 的逆元，有 inv[i] = (p - p / i) * inv[p % i]时间复杂的为线性，代码如下： 123456long long inv[10000010];long long getInverse(long long x, long long p) &#123; if (inv[x] != 0) return inv[x]; inv[x] = (p - p / i) * getInverse(p % x, p) % p; return inv[x];&#125; 费马小定理求逆元费马小定理：如此可爱的定理名称 $a^{p-1}\equiv1\pmod p$ 当 $p$ 为素数时且 $gcd(a,p)=1$ 时。所以求 $a$ 的逆元时，只要求出 $a^{p-2}$ 的值就可以了。 1234567891011121314long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getinverse(long long x, long long p) &#123; return Montgomery(x, p - 2, p);&#125; 逆元求组合数从组合数原公式出发$$C_n^m=\frac{n!}{m!(n-m)!}=\frac{n\times (n-1)\times…\times(n-m+1)}{m!}$$ 对于分子，我们可以用传统方法，边乘边模，对于分母，我们可以求逆元再乘分子。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getInverse(long long x, long long p) &#123; return Montgomery(x, p - 2, p);&#125;long long c(long long n, long long m, long long p) &#123; long long x = 1, y = 1; for (long long i = n; i &gt;= n - m + 1; --i) x = x * i % p; for (long long i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; long long n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; 注：$p$ 一定要是大质数，起码得大于 $m$。若要求 $a$ 在模 $p$ 下的乘法逆元，必须要保证 $a$ 与 $p$ 互质。在此题中，要求 $m!$ 的乘法逆元，那么 $p$ 必须与 $m!$ 互质，所以 $p$ 要大于 $m$，且是个质数。我一开始忘记了这点，导致调了一年 方法三：卢卡斯定理适用于对答案模一个质数的情况。与逆元不同的是，这个方法不要求 $p$ 是个很大的素数，因此，适用范围更广（也许吧）。卢卡斯定理：对于非负整数 $m$ 和 $n$ 及素数 $p$，有同余式：$$\binom{n}{m}\equiv\prod_{i=0}^k\binom{n_i}{m_i} \pmod p$$成立。其中：$$n=n_kp^k+n_{k-1}p^{k-1}+…+n_1p+n_0$$并且$$m=m_kp^k+m_{k-1}p^{k-1}+…+m_1p+m_0$$以上两个式子是 $n$ 和 $m$ 的 $p$ 进制展开。当 $m &lt; n$ 时，二项式系数 $\binom{n}{m}=0$。可以通过一系列的推导得出下面这个结论：$$\binom{n}{m}\equiv\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{m}{p}\rfloor}\times \binom{n\bmod p}{m\bmod p} \pmod p$$由这个公式我们可以得出结论：在 $n$ 和 $m$ 都小于 $p$ 时，公式一点用都没有。（啥？你问我为什么？$\binom{0}{0}=1$ 啊！）所以这个公式是在 $n\geqslant p$ 或 $m\geqslant p$ 的情况下使用的。这样可以减小 $n$ 和 $m$，使之小于 $p$，再用乘法逆元去求组合数。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getInverse(long long a, long long b) &#123; return Montgomery(a, b - 2, b);&#125;long long c(int n, int m, int p) &#123; if (m == 0) return 1 % p; if (n == 0) return 0; if (n &gt;= p || m &gt;= p) return c(n / p, m / p, p) * c(n % p, m % p, p) % p; // 核心语句 long long x = 1, y = 1; for (int i = n; i &gt;= n - m + 1; --i) x = x * i % p; for (int i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; long long n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; 未完待续……]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>模运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++ 奇技淫巧] 流迭代器使用]]></title>
    <url>%2F2018%2F08%2F17%2FC-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写在前面自从熟知了 STL 库这个东西，我就再也离不开它了，以前一直以为只有容器才会有迭代器可以用，然而这是因为自己的知识水平还不够高，今天就介绍一下流迭代器这种神奇的存在。 流迭代器iostream 迭代器（iostream iterator）：与输入或输出流绑定在一起，用于迭代遍历所关联的 IO 流。 虽然 iostream 类型不是容器，但标准库同样提供了在 iostream 对象上使用的迭代器：istream_iterator 用于读取输入流，而 ostream_iterator 则用于写输出流。这些迭代器将它们所对应的流视为特定类型的元素序列。 下面列出流迭代器的使用方法： iostream 迭代器的构造函数 对应的意义 istream_iterator&lt;T&gt; in(strm) 创建从输入流 strm 中读取T类型对象的 istream_iterator 对象 istream_terator&lt;T&gt; in istream_iterator 对象的超出末端迭代器 ostream_iterator&lt;T&gt; out(strm) 创建将T类型的对象写到输出流 strm 的 ostream_iterator 对象 ostream_iterator&lt;T&gt; out(str, delim) 创建将 T 类型的对象写到输出流 strm 的 ostream_iterator 对象，在写入过程中使用 delim 作为元素的分隔符。delim 是以空字符结束的字符数组（C风格字符串）。 istream_iterator 的操作 对应的意义 it1 == it2; it1 != it2 比较两上 istream_iterator 对象是否相等（不等）。迭代器读取的必须是相同的类型。如果两个迭代器都是 end 值，则它们相等。对于两个都不指向流结束位置的迭代器，如果它们使用同一个输入流构造，则它们也相等 *it 返回从流中读取的值 it-&gt;mem 是 (*it).mem 的同义词。返回从流中读取的对象的 mem 成员 ++it; it++ 通过使用元素类型提供的 &gt;&gt; 操作从输入流中读取下一个元素值，使迭代器向前移动。通常，前缀版本使用迭代器在流中向前移动，并返回对加 $1$ 后的迭代器的引用。而后缀版本使迭代器在流中向前移动后，返回原值 注：流迭代器都是类模板：任何已定义输入操作符（&gt;&gt; 操作符）的类型都可以定义istream_iterator。任何已定义输出操作符（&lt;&lt; 操作符）的类型可定义 ostream_iterator。 流迭代器使用注：迭代器的头文件别忘记引入。 #include &lt;iterator&gt; 1234567891011121314151617#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;iterator&gt;using namespace std;int main() &#123; istream_iterator&lt;int&gt; cinIter(cin); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec; while (cinIter != endOfStream) //注意++先引用后增值，不能写出前缀 vec.push_back(*cinIter++); //也可以写成 vector&lt;int&gt; vec(cinIter, endOfStream); for (int i = 0; i != vec.size(); ++i) cout &lt;&lt; vec[i]; return 0;&#125; 注：其中 end_of_stream 定义为空的迭代器对象，用作结束迭代器。绑定流上的迭代器在遇到文件结束或某个错误时，将等于结束迭代器的值。 1234567int main(int argc, char **argv) &#123; ostream_iterator&lt;string&gt; outIter(cout, "\n"); istream_iterator&lt;string&gt; inIter(cin), endOfStream; while(endOfStream != inIter) *outIter++ = *inIter++; return 0;&#125; 注：执行顺序是先 iter++，返回 iter，最后 *iter。注意输出，输入 1 2 3 4 5，按 enter 输出 1\n2\n3\n4\n，按 ctrl+z 输出 5。 12345678910111213141516#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;using namespace std; int main(int argc, char **argv) &#123; ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); sort(vec.begin(), vec.end()); ostream_iterator&lt;int&gt; output(cout, " "); unique_copy(vec.begin(), vec.end(), output); return 0;&#125; 示例输入/输出： INPUT(in.txt): 1 2 2 2 5 5 6 6 7 8 9 10 9 100 OUTPUT: 1 2 5 6 7 8 9 10 100 流迭代器的限制 不可能从 ostream_iterator 对象读入，也不可能写到 istream_iterator 对象中。 一旦给 ostream_iterator对象赋了一个值，写入就提交了。赋值后，没有办法再改变这个值。此外，ostream_iterator 对象中每个不同的值都只能正好输出一次。 ostream_iterator 没有 -&gt; 操作符。 流迭代器的速度为了测试流迭代器的速度，我先随机生成了 $10000000$ 个数据，生成代码如下： 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ofstream test("in.txt"); srand((unsigned)time(NULL) * 19260817); // +1s for (int i = 1; i &lt;= 10000000; ++i) test &lt;&lt; rand() &lt;&lt; " "; return 0;&#125; 迭代器测试12345678910111213141516171819202122#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono; int main(int argc, char **argv) &#123; auto start = system_clock::now(); ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; 结果： cost: 10.7543 seconds 注：为了测试时间尽量精准，这里引入了 chrono 库，使用了支持 C++ 11 的 gcc 7.3.0，并且是在 Linux(Ubuntu) 上编译运行的，鉴于编译器的优化能力一个版本比一个版本强，此处没有开优化但结果仍可能有误差，与 OI 中使用迭代器的速度不一样，读者可以使用别的库再进行实验。 开了 $O_2$ 优化的流迭代器123456789101112131415161718192021222324#pragma GCC optimize(2)#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono; int main(int argc, char **argv) &#123; auto start = system_clock::now(); ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; 结果： cost: 2.31234 seconds 注：开了优化的结果，读者自行判断 OI 中快读的时间测试1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;using namespace std::chrono;inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;int main(int argc, char **argv) &#123; auto start = system_clock::now(); freopen("in.txt", "r", stdin); int x; vector&lt;int&gt; a; for (int i = 0; i &lt; 10000000; ++i) &#123; read(x); a.push_back(x); &#125; auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; 结果 cost: 2.61905 seconds 注：快读的写法也许不是最优，读者可以自行实验。 总结事实上，抛开 OI 比赛不说，STL 的库使用优化还是很强的，但是 OI 中嘛，如果作大死用这个也许真的会崩。至于有关 STL 速度的讨论可以看这里。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>C++ 奇技淫巧</tag>
        <tag>迭代器</tag>
        <tag>iostream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[算法] Manacher 算法求最长回文子串]]></title>
    <url>%2F2018%2F08%2F14%2F%E7%AE%97%E6%B3%95-Manacher-%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[写在前面最近几次考试都涉及到了字符串处理这个话题，所以自己打算恶补字符串有关的算法，同时又刚好做到了 LeetCode 上这么一道题，所以干脆一同解决掉。 最长回文字串问题最长回文子串问题：给定一个字符串，求它的最长回文子串长度。如果一个字符串正着读和反着读是一样的，那它就是回文串。下面是一些回文串的实例： 12321 a aba abba aaaa tattarrattat（牛津英语词典中最长的回文单词 那么如何解决这个问题呢？有很多种方法： Brute-Force 暴力求解：找到所有字串，一一验证，时间复杂度为 $O(n^3)$ 改进版 Brute-Force：遍历整个字符串的中间字符及空隙，然后向两端扫描，时间复杂度为 $O(n^2)$。 动态规划，此处暂时不介绍 下面将要介绍的 Manacher 算法，又名马拉车。 Manacher 算法暴力解法的缺陷所在 回文串奇偶性不定，使用上述方法二需要分类讨论，降低效率。 字串重复访问，时间复杂度冗余。 举个例子： char: a b a b a i: 0 1 2 3 4 在 $i=1$ 和 $i=2$ 时，字串 aba 被分别遍历了一次。Manacher 算法正式针对这些算法进行改进的算法，可以大大提高算法的运行效率。 解决长度奇偶性问题Manacher 算法通过一种预处理方式来解决第一个问题，它在字符串首尾及中间空隙插入一个字符，并且满足这个符号不在字符串中出现，这样就可以让所有的字符串长度变为奇数。以插入#为例： aba --&gt; #a#b#a# abba --&gt; #a#b#b#a# 插入的是同样的符号，且符号不存在于原串，因此子串的回文性不受影响，原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文 解决重复访问问题我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher定义了一个回文半径数组 $RL$，用 $RL[i]$ 表示以第 $i$ 个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义 $RL[i]$ 为第 $i$ 个字符为对称轴的回文串的最右一个字符与字符 $i$ 的距离。对于上面插入分隔符之后的两个串，可以得到 $RL$ 数组： $char$ # $a$ # $b$ # $a$ # $RL$ $1$ $2$ $1$ $4$ $1$ $2$ $1$ $RL-1$ $0$ $1$ $0$ $3$ $0$ $1$ $0$ $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ 上面我们还求了一下 $RL[i]-1$。通过观察可以发现，$RL[i]-1$的值，正是在原本那个没有插入过分隔符的串中，以位置i为对称轴的最长回文串的长度。那么只要我们求出了 $RL$ 数组，就能得到最长回文子串的长度。 于是问题变成了，如何高效地求的 $RL$ 数组。基本思路是利用回文串的对称性，扩展回文串。 我们再引入一个辅助变量 $MaxRight$，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下 $MaxRight$ 对应的回文串的对称轴所在的位置，记为 $pos$，它们的位置关系如下： 我们从左往右地访问字符串来求 $RL$，假设当前访问到的位置为 $i$，即要求 $RL[i]$，在对应上图，$i$ 必然是在 $pos$ 右边的。但我们更关注的是，$i$ 是在 $MaxRight$ 的左边还是右边。我们分情况来讨论： 情况一：$i$ 在 $MaxRight$ 左边如下图所示： 我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以 $i$ 为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到 $i$ 关于 $pos$ 的对称位置 $j$，这个 $j$ 对应的 $RL[j]$ 我们是已经算过的。根据回文串的对称性，以i为对称轴的回文串和以j为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况: 以 $j$ 为对称轴的回文串较短如下图： 这时我们知道 $RL[i]$ 至少不会小于 $RL[j]$，并且已经知道了部分的以i为中心的回文串，于是可以令 $RL[i]=RL[j]$。但是以i为对称轴的回文串可能实际上更长，因此我们试着以 $i$ 为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。 以 $j$ 为对称轴的回文串较长如下图： 这时，我们只能确定，两条蓝线之间的部分（即不超过 $MaxRight$ 的部分）是回文的，于是从这个长度开始，尝试以i为中心向左右两边扩展，，直到左右两边字符不同，或者到达边界。 小结不论以上哪种情况，之后都要尝试更新MaxRight和pos，因为有可能得到更大的MaxRight。 具体操作如下： 令 $RL[i]=min\lbrace RL[2\times pos-i], MaxRight-i\rbrace$ 以 $i$ 为中心扩展回文串，直到左右两边字符不同，或者到达边界 更新 $MaxRight$ 和 $pos$ 情况二：$i$ 在 $MaxRight$ 右边如下图： 遇到这种情况，说明以 $i$ 为对称轴的回文串还没有任何一个部分被访问过，于是只能从 $i$ 的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新 $MaxRight$ 和 $pos$。 代码实现此处以 LeetCode 上的题为例： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); if (len &lt;= 1) return s; string str = preProcess(s); int n = str.size(), pos = 0, MaxRight = 0; vector&lt;int&gt; RL(n, 0); for (int i = 1; i &lt; n - 1; ++i) &#123; RL[i] = MaxRight &gt; i ? min(RL[2 * pos - i], MaxRight - i) : 1; while (str[i + RL[i]] == str[i - RL[i]]) ++RL[i]; if (i + RL[i] &gt; MaxRight) &#123; MaxRight = i + RL[i]; pos = i; &#125; &#125; int maxLen = 0, index = 0; for(int i = 1; i &lt; n - 1; ++i) &#123; if(RL[i] &gt; maxLen) &#123; maxLen = RL[i]; index = i; &#125; &#125; // 这里可以和上面并在一起 return s.substr((index - maxLen) / 2, maxLen - 1); &#125; //预处理字符串，abc预处理后变成$#a#b#c#^ string preProcess(const string &amp;s) &#123; int n = s.size(); string res; res.push_back('$'); res.push_back('#'); for(int i = 0; i &lt; n; i++) &#123; res.push_back(s[i]); res.push_back('#'); &#125; res.push_back('^'); return res; &#125; // 注：此处字符串预处理在头上加入 '$' 是为了方便处理 // 如果是空间瘤患者，直接在有关的地方减一就行了&#125;; 总结Manacher 算法其实可以算奇技淫巧吧，主要还是掌握它的思路，充分利用待求解问题的性质，从而降低求解的复杂度。这个也是在竞赛中会用到的技巧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode 刷题日志] LeetCode-3 无重复字符的最长子串]]></title>
    <url>%2F2018%2F08%2F12%2FLeetCode-%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97-LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[写在前面今天开始刷 LeetCode，虽然说里面都是大公司的面试题，但是作为一个 OIer，刷刷也无妨，还能够提高自己的代码能力。本来希望花个 3 天刷完 LeetCode，结果发现这是完全不可能的，今天就被很基础的第三题给卡住了…… LeetCode-3 题解——坑人的大水题 题目描述： 给定一个字符串，找出不含有重复字符的最长子串的长度。 示例： 给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。 给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。 给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 [题解] 直接上代码，具体说明看注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; int maxLen = 0; int currLen = 0; // table 用于记录字符出现的次数，之所以设为 128 是为了适配 ASCII 码 int table[128], start = 0; // 全部初始化为 0 memset(table, 0, sizeof(table)); for (int i = 0; i &lt; s.length(); ++i) &#123; // 如果 ++table[s[i]] 为 2，则说明这个数在所选的子串中已经出现过了 // 当然这里还有好多写法 if (++table[s[i]] == 2) &#123; // 因为遇到重复的字符了，所以要先更新 maxLen if (currLen &gt; maxLen) maxLen = currLen; // 接下来查找重复的数字出现的地方，并且更新字串起始位置 // 这里可以优化：使用一个 map&lt;char, int&gt; // 或 table0[128] 来记录字符的出现位置 // 同时也可以与前面的 table 数组合并，既加快速度又减少空间 // 这里因为不需要（懒），所以就打了这个未优化的算法 // 有兴趣的读者可以去试一试优化算法。 for (int j = start; j &lt; i; ++j) &#123; if (s[j] == s[i]) &#123; table[s[j]] = 1; start = j + 1; break; // 因为最多出现一次，所以直接 break &#125; else &#123; // 没找到的话必须减小答案 --currLen; // 重置 table[s[j]] = 0; &#125; &#125; &#125; else ++currLen; // 没有重复就直接自加一 &#125; // 最后的判断必不可少 if (currLen &gt; maxLen) maxLen = currLen; return maxLen; &#125;&#125;;// 由于本人是一个 OIer，还是 Google 资深老粉丝，所以代码风格比较混搭（逃）。 那么，是什么卡了我那么长时间呢？一开始的代码遇到重复的字符，直接更新起始位置到当前字符，殊不知会有 abcdaefg 这种情况，于是一直 WA。论充分思考的重要性….. 总结LeetCode 的题目难度并不是很大的，很多题差不多是提高-的难度，但是细节太多，同时对代码能力的要求比较高，某些数据结构也与 OI 中所写地不太一样。但是当作算法训练场来做也没什么坏处。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[算法] RMQ 问题与 ST 算法]]></title>
    <url>%2F2018%2F08%2F11%2F%E7%AE%97%E6%B3%95-RMQ-%E9%97%AE%E9%A2%98%E4%B8%8E-ST-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写在前面因为很多次模拟测试都败在区间最值问题（RMQ）上，所以决定开一篇博客好好总结一下。本篇文章着重介绍 RMQ 问题中最著名的 ST 算法。 RMQ 问题给定一个长度为 $N$ 的数列 $A$，然后进行若干次询问，每次给定一个区间 $[l_i,r_i]$ 求这个区间中的最大或最小值，这就是区间最值问题，也就是 RMQ 问题。一般来说，这样的问题都要求区间的查询是在线的，也就是提出一个查询回答一次，不能全部收到后统一回答。对于某些确定区间求最值的问题，通常采用倍增的方法来求解。而 ST 算法其实就是倍增的产物，同时加入了动态规划的思想。 ST 算法在 RMQ 问题中，ST 算法可以在 $O(NlogN)$ 的时间预处理数据后，以 $O(1)$ 的时间在线回答查询。一个序列的子空间个数显然有 $O(N^2)$ 个，我们首先在这个规模为 $O(N^2)$ 的状态空间中选择一些 $2$ 的整数次幂的位置作为代表值。 设 $F[i,j]$ 表示子空间 $A$ 中下标在在子区间 $[i,i+2^j-1]$ 里数的最大值，即从 $i$ 开始的 $2^j$ 个数的最大值。显然 $F[i,0]=A[i]$，即数列 $A$ 在子区间 $[i,i]$ 中的最大值。 递推时，我们将子区间长度成倍增长，公式如下： $$F[i,j]=max\lbrace F[i,j-1],F[i+2^{j-1},j-1] \rbrace$$ 即长度为 $2^j$ 的子区间的最大值是左右两半长度为 $2^{j-1}$ 的子区间的最大值中较大的那一个。所以我们先预处理我们要用到的数组： 1234567void STprework() &#123; for (int i = 1; i &lt;= n; ++i) f[i][0] = a[i]; int t = log(n) / log(2) + 1; for (int j = 1; j &lt; t; ++j) for (int i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; ++i) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125; 当我们要查询区间 $[l,r]$ 的最值时，我们先计算出一个 $k$，满足 $2^k &lt; r-l+1 \leqslant 2^{k+1}$，也就是使二的 $k$ 次幂小于区间长度的前提下最大的 $k$。那么“从 $l$ 开始的 $2^k$ 个数”和“以 $r$ 结尾的 $2^k$ 个数” 这两段一定覆盖了原来的整个区间，这两段的最大值分别为 $F[l,k]$ 和 $F[r-2^k+1,k]$，二者中较大的就是整个区间的最值。因为求的是最大值，所以只要覆盖区间就行，重叠是没有关系的。 1234int STquery(int l, int r) &#123; int k = log(r - l + 1) / log(2); return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);&#125; 如果要进一步提高执行效率，可以将 $f$ 数组的两个维度交换，这样对缓存更加友好。并且可以预处理出 $1 \thicksim n$ 中 $log_2 n$ 的值，甚至是各个区间对应的 $k$ 的值，具体方法视情况而定。 总结 为什么使用 log() 函数而不是 log2() 呢，原因是前者效率更快，而且众所周知，对数是有换底公式的（啥？你不知道？赶紧补一下高中数学必修一吧！），所以这里效率会高一点 ST 表的模板题地址——洛谷 p3865 附上完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define max(a, b) (a &gt; b ? a : b)#define G(a) putchar(a + 48)int n, m, A[maxn];int li, ri;int f[21][maxn];int logn[maxn];inline int read() &#123; int ans = 0; char c; bool sign = false; while (!isdigit(c = getchar()) &amp;&amp; c != '-'); if (c == '-') &#123; sign = true; c = getchar(); &#125; do &#123; ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + (c - '0'); &#125; while (isdigit(c = getchar())); return sign ? -ans : ans;&#125;inline void write(int s)&#123; if (s &lt; 0) &#123; G(-3); s = -s; &#125; if (s &gt; 9) write(s / 10); G(s % 10);&#125;void STprework() &#123; for (int i = 1; i &lt;= n; ++i) f[0][i] = A[i]; int t = logn[n] + 1; for (int j = 1; j &lt; t; ++j) for (int i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; ++i) f[j][i] = max(f[j - 1][i], f[j - 1][i + (1 &lt;&lt; (j - 1))]);&#125;int STquery(int l, int r) &#123; int k = logn[r - l + 1]; return max(f[k][l], f[k][r - (1 &lt;&lt; k) + 1]);&#125;void pre() &#123; logn[1] = 0; logn[2] = 1; for (int i = 3; i &lt;= n; ++i) logn[i] = logn[i / 2] + 1;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) A[i] = read(); pre(); STprework(); for (int i = 1; i &lt;= m; ++i) &#123; li = read(); ri = read(); write(STquery(li, ri)); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>RMQ 问题</tag>
        <tag>ST 算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[图论] 图论基础知识]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%9B%BE%E8%AE%BA-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[写在前面因为自己的图论其实掌握得不怎么样，所以开一篇博客，来加深一下自己图论的基础。注意，本文只是基础，主要普及图的存储，最短路和遍历（$DFS$ 和 $BFS$）。 定义在图论中，我们定义一张图为由顶点集（Vertices）和边集（Edges）组成的二元组，即 $G = (V, E)$。此处 $V$ 和 $E$ 也可写为 $V(G)$ 和 $E(G)$。 基本术语阶（Order）：图 $G$ 中顶集 $V$ 的大小称作图 $G$ 的阶。 子图（Sub-Graph）：图 $G’$ 称作图 $G$ 的子图如果 $V(G’)\subseteq V(G)$ 以及 $E(G’)\subseteq E(G)$。 生成子图（Spanning Sub-Graph）：指满足条件 $V(G’)=V(G)$ 的 $G$ 的子图 $G’$。 度（Degree）是一个顶点的度是指与该顶点相关联的总边数，顶点 $v$ 的度记作 $d(v)$。度和边有如下关系：$\sum_{v\in V} d(v)=2\left|E\right|$。 出度（Out-degree）和入度（In-degree）：对有向图而言，顶点的度还可分为出度和入度。一个顶点的出度为 $d_o$ ，是指有 $d_o$ 条边以该顶点为起点，或说与该点关联的出边共有 $d_o$ 条。入度的概念也类似。 自环（Loop）：若一条边的两个顶点相同，则此边称作自环。 路径（Path）：从顶点u到顶点v的一条路径是指一个序列 $v_0,e_1,v_1,e_2,v_2,…e_k,v_k$，$e_i$ 的起点终点为 $v_{i-1}$ 及 $v_i$； $k$ 称作路径的长度； $v_0=u$，称为路径的起点；$v_k=v$，称为路径的终点。如果 $u=v$，称该路径是闭的，反之则称为开的；如果 $v_1,…,v_k$ 两两不等，则称之为简单路径（Simple path，注意， $u=v$ 是允许的）。 行迹（Trace）：如果路径 $P(u,v)$ 中边各不相同，则该路径称为 $u$ 到 $v$ 的一条行迹。 轨道（Track）：即简单路径。 闭的行迹称作回路（Circuit），闭的轨道称作圈（Cycle）。（现存文献中的命名法并无统一标准。比如在另一种定义中，walk 对应上述的 path，path 对应上述的 track，trail对应上述的 trace。） 距离（Distance）：从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称作从 $u$ 到 $v$ 的距离。若从 $u$ 到 $v$ 根本不存在路径，则记该距离为无穷（$\infty$）。 桥（Bridge）：若去掉一条边，便会使得整个图不连通，该边称为桥。 编程实现图的存储邻接矩阵存图12345678910111213#define maxn 100#define INF 0x3fint g[maxn][maxn];void init() &#123; memset(g, INF, sizeof(g)); &#125; // 初始化void addEdge(int vertex1, int vertex2, int wieght) &#123; g[vertex1][vertex2] = weight;&#125; // 添加一条单向边void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // 添加一条双向边 / 无向边 其中 $g[i][j]$ 表示从 $i$ 到 $j$ 的边的权。注意邻接矩阵方便使用，但空间复杂度为 $O(n^2)$，在点比较多的时候不太实用，极有可能会爆。 邻接表存图先上代码： 1234567891011121314151617181920212223242526272829#define maxn 11000#define maxm 21000#define NOE -1int v[maxm], e[maxm], heads[maxn], nxt[maxm]int tot = 0;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;// 初始化void addEdge(int vertex1, int vertex2, int weight) &#123; tot++; v[tot] = vertex2; e[tot] = weight; nxt[tot] = heads[vertex1]; heads[vertex1] = tot;&#125; // 加边void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // 加双向边void travel(int x) &#123; for (int i = heads[x]; i != NOE; i = nxt[i]) &#123; int y = v[i]; int x = e[i]; // 找到一条有向边 (x, y) 边权为 z // do something here &#125; // 遍历从 x 出发的边&#125; $v[]$ 和 $e[]$ 记录了每条边的终点和边权，$nxt[]$模拟指针，表示从想同节点出发的下一条边在 $v[]$ 和 $e[]$ 中的存储位置，$heads[i]$ 表示从 $i$ 出发的第一条边。信息奥赛中使用数组模拟指针足够了，如果想知道具体的邻接表的相关知识看这里：Wikipedia 链式前向星个人认为最好的存图方式，虽然与邻接表没有太大区别，但是好写多了（与真正的邻接表对比，不是 OI 中的阉割版）。 12345678910111213141516171819202122232425262728293031323334#define maxn 11000#define maxm 21000#define NOE -1struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125;;edgeNode edges[maxm];int heads[maxn];int numEdges = 0;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125; // 加边void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // 加双向边void travel(int x) &#123; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; int z = edges[i].weight; // 找到一条有向边 (x, y) 边权为 z // do something here &#125; // 遍历从 x 出发的边&#125; 多写写就会熟悉了。 图的遍历深度优先遍历 DFS深度优先搜索法是树的先序遍历的推广，它的基本思想是：从图 $G$ 的某个顶点 $v_0$ 出发，访问 $v_0$，然后选择一个与 $v_0$ 相邻且没被访问过的顶点 $v_i$ 访问，再从 $v_i$ 出发选择一个与 $v_i$ 相邻且未被访问的顶点 $v_j$ 进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点 $w$，从 $w$ 出发按同样的方法向前遍历，直到图中所有顶点都被访问。具体实现如下： 12345678910bool visited[maxn];void initDFS() &#123; memset(visited, false, sizeof(visited)); &#125;void rDFS(int x) &#123; visited[x] = true; visit(); // 根据具体情况定义 visit() for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) if (!visited[edges[i].vertexTo]) rDFS(edges[i].vertexTo); return; // 最好加上 return&#125; // 因为这是递归实现的，故命名为 rDfS $DFS$ 全称为 $Depth$ $First$ $Search$，其实是一个搜索算法，有关搜索的算法，未来会开个专题详细讲解，通俗的语言概括就是不顾一切向前冲，撞墙了再回头。 对于下面这么一张图： 它的遍历方式如下： 遍历顺序：$$v_1 \rightarrow v_2 \rightarrow v_4 \rightarrow v_8 \rightarrow v_5 \rightarrow v_3 \rightarrow v_6 \rightarrow v_7$$ $DFS$ 还是很常用的，属于必备知识。 广度优先遍历 BFS图的广度优先搜索是树的按层次遍历的推广，它的基本思想是：首先访问初始点 $v_i$，并将其标记为已访问过，接着访问 $v_i$ 的所有未被访问过的邻接点 $v_{i1},v_{i2},…,v_{it}$，并均标记已访问过，然后再按照 $v_{i1},v_{i2},…,v_{it}$的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点 $v_i$ 有路径相通的顶点都被访问过为止。非递归实现如下： 123456789101112131415161718192021222324queue&lt;int&gt; Q;int dep[maxn];void initBFS() &#123; memset(dep, 0, sizeof(dep)); while (!Q.empty()) Q.pop();&#125;void BFS() &#123; Q.push(1); dep[1] = 1; // dep[i] 表示节点 i 的深度，即从 1 到 i 需要走过的最少点数 while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; if (dep[y]) continue; // 这里直接使用 dep[] 来替代 visited[]，顺便求出点的深度 dep[y] = dep[x] + 1; Q.push(y); &#125; &#125;&#125; 对于下面这么一张图： 它的遍历方式如下： 遍历顺序：$$v_1\rightarrow v_2\rightarrow v_3\rightarrow v_4\rightarrow v_5\rightarrow v_6\rightarrow v_7\rightarrow v_8$$ 最短路径算法Floyd 求多源最短路Floyd 的本质是动态规划，我们令 $D[i,j,k]$ 表示经过若干个编号不超过 $k$ 的节点，从 $i$ 到 $j$ 的最短路径的长度。该问题可以划分成两个子问题，经过编号不超过 $k-1$ 的节点从 $i$ 到 $j$，或者从 $i$ 先到 $k$ 再到 $j$，于是我们写出动态规划方程： $$D[i,j,k]=min\lbrace D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]\rbrace$$ 注意，$k$ 是阶段，所以必须置于外层循环中，$i$ 和 $j$ 是附加状态，所以置于内层循环。 与背包问题类似，我们可以忽略 $k$ 这一维，于是我们有： $$D[i,j]=min\lbrace D[i,j],D[i,k]+D[k,j]\rbrace$$ $D[i,j]$ 保存了从 $i$ 到 $j$ 的最短路的长度 实现代码如下： 12345678910111213141516171819202122232425#define maxn 310#define INF 0x3fint d[maxn][maxn], n, m;int x, y, x;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(d, INF, sizeof(d)); for (int i = 1; i &lt;= n; ++i) d[i][i] = 0; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; d[x][y] = min(d[x][y], z); &#125; // 初始化 &amp; 输入 for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); // Floyd 求最短路 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cout &lt;&lt; d[i][j] &lt;&lt; " "; // 输出&#125; 一般来说，在数据小的时候可以使用 Floyd 算法，数据大的时候尽量去思考别的方法。 Dijkstra 求单源最短路Dijkstra 算法流程如下： 初始化 $dist[1] = 0$，其余节点初始化为一个极大值。 找出一个未被标记的，$dist[x]$ 最小的节点 $x$，然后标记节点 $x$。 扫描节点 $x$ 的所有出边 $(u, v, w)$，若 $dist[v] &gt; dist[u] + w$，则使用 $dist[u] + w$ 更新 $dist[v]$ 重复 $2 \thicksim 3$ 两个步骤，直到节点全部被标记。 Dijkstra 算法基于贪心，只适用于边权非负的图。优化：使用二叉堆对 $dist$ 进行维护，$O(\log n)$ 的时间获取最小值并删除，$O(\log n)$ 的时间执行一条边的扩展和更新，最终在 $O((m+n) \log n)$ 的时间内完成 Dijkstra。 实现代码如下： 12345678910111213141516171819202122232425262728293031// 关于图的定义部分这里省略struct heapNode &#123; int u, d; bool operator&lt;(const heapNode&amp; b) const &#123; return d &gt; b.d; &#125;&#125;// 注意，为了建立小根堆，此处重载的运算符有一点不同。// 可以通俗地理解为：如果到 b 的距离比到 u 的距离小，那么 b 的优先级比 u 高。priority_queue&lt;heapNode&gt; Q; // 使用优先队列建立小根堆。int dist[maxn]; // 记录从 x 到 各点的最短距离void Dijkstra(int x) &#123; while (!Q.empty()) Q.pop(); for (int i = 1; i &lt;= n; ++i) dist[i] = INF; dist[x] = 0; // 到自己的距离为 0 Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int d = f.d; if (d != dist[u]) continue; for (int i = heads[u]; i != NOE; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[u] + w) &#123; dist[j] = dist[u] + w; Q.push()((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125; Bellman-Ford 及 SPFA 算法给定一张有向图，若对于图中的某一条边 $(x,y,z)$，有 $dist[y] \leqslant dist[x]+z$ 成立，则称该边满足三角形不等式。若所有的边都满足三角形不等式，则 $dist$ 数组就是所求的最短路。 首先介绍基于迭代思想的 Bellman-Ford 算法。它的流程如下： 扫描所有的边 $(x,y,z)$，若 $dist[y] &gt; dist[x]+z$，则用后者更新它。 重复上述步骤，直到没有操作发生。 Bellman-Ford 的时间复杂度为 $O(nm)$。 而 SPFA 实际上是队列优化的 Bellman-Ford 算法，这是国际上的通称。SPFA 的算法流程大致如下： 建立一个队列，最初队列中只含有起点 $1$。 取出队头结点 $x$，扫描它的所有出边 $(x, y, x)$，若 $dist[y] &gt; dist[x]+z$，则用后者更新前者，同时若 $y$ 不在队列中，则把 $y$ 入队。 重复上述步骤，直到队列为空。 SPFA 中的队列避免了 Bellman-Ford 中对不需要扩展的节点的冗余扫描，在稀疏图上的运行效率较高，为 $O(km)$ 级别，$k$ 是一个较小的常数，而在稠密图或特殊构造的网格图上，算法仍可能退化为 $O(nm)$，这也是很多人说 SPFA 算法玄学的原因。但是在遇到负边权的时候，只能够使用 SPFA。 SPFA 的实现： 12345678910111213141516171819202122232425262728int dist[maxn];bitset&lt;maxn&gt; inq; // 记录是否在队列中queue&lt;int&gt; Q;void SPFA(int x) &#123; memset(dist, INF, sizeof(dist)); dist[x] = 0; Q.push(x); inq[x] = true; int k; while (!Q.empty()) &#123; k = Q.front(); Q.pop(); inq[k] = false; if (dist[k] == INF) continue; for (int i = heads[k]; i != NOE; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[k] + w) &#123; dist[j] = dist[k] + w; if (!inq[j]) &#123; Q.push(j); inq[j] = true; &#125; &#125; &#125; &#125;&#125; 如果不是处理负边权的图的话， SPFA 尽量不要用，原因嘛……它太玄了。 完结撒花！！]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Dijkstra</tag>
        <tag>图的遍历</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Floyd</tag>
        <tag>Bellman-Ford</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 2018-8-8 题解: 爆零日，我该何去何从...]]></title>
    <url>%2F2018%2F08%2F08%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-8-%E9%A2%98%E8%A7%A3-%E7%88%86%E9%9B%B6%E6%97%A5%EF%BC%8C%E6%88%91%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%2F</url>
    <content type="text"><![CDATA[写在前面今天的题似乎是 Day1 的题，然而却是压力山大，从第一题开始就崩，第二题考场上无脑 Dijkstra 求最短路，第三题更是懵逼（考后听说用 Dancing Link 做的时候彻底崩溃），总之，今天四十分，与爆零相差无几，所以这次在写题解的同时，还是会写一点考试技巧的，尤其是第一题和第二题（原谅我知识水平实在不够，对第三题仍然懵逼）。 T1 动态仙人掌(dinosaur.cpp/c/pas)——玩了这么多次小恐龙，没想到它还会报复我 [题目描述] 由于 Beny 做的烧网线实验，Fife 家断网了。Fife 照常打开了 Google Chrome，由于断网，他看到了以下内容： 看 到 这 个 简 单 而 又 有 趣 的 游 戏 ， 他 玩 了 起 来 。 然 后 ： Fife 永远没有 gameover，他觉得这个游戏太简单了，现在他想考考你。小恐龙在数轴上原点出发向右运动，速度为$1$个单位每秒。现在你知道每一个仙人掌的位置$p[i]$和高度$h[i]$，且没有怪鸟突袭，请你控制小恐龙跳跃，使它能跳过最后一个仙人掌且跳跃的最大高度最小。为了送温暖简化问题，跳跃满足以下规则：它的跳跃路线为严格的与地面夹角为$45$度的直线，它在平地上能随时起跳，它能在起点和落地时刻瞬间起跳。你能控制它起跳的时刻和下落的时刻，下落时它会沿与地面夹角为$45$度的直线下降。小恐龙能跳过一个仙人掌当且仅当它在这个仙人掌的位置时的高度大于等于仙人掌的高度。 [输入] 第 1 行 1 个正整数 n 接下来 n 行每行两个正整数 p[i]和 h[i],为第 i 个仙人掌的位置和高度， 不保证 p[i]单调递增， 可能会有两个仙人掌在同一位置。 [输出] 你需要控制小恐龙跳跃，使它能跳过所有仙人掌，且跳跃的最大高度最小， 输出这个高度， 保留 1 位小数，如果无解，输出-1 [样例输入] 5 5 2 9 3 13 2 19 3 20 1 [样例输出] 6.0 [数据规模] 对于 30%的数据：n&lt;=200, p[i] &lt;= 1000, h[i] &lt;= 100 对于 60%的数据：n&lt;= 50000, p[i] &lt;= 3000000, h[i] &lt;= 500 对于 100%的数据：n &lt;= 300000, p[i] &lt; 2^31, h[i] &lt;=40000, 数据保证无需使用 longlong 或 int64 [题解] 看到这是第一道题，心想，这一定很简单，只要贪心就行了，一堆判断，然后信心满满地提交……最后只对了一个点……此处附上 WA 代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 310000#define max(a, b) (a &gt; b ? a : b)#define INF 0x3f3f3f3fint n, p[maxn], h[maxn];bitset&lt;maxn&gt; goDown;double ans = -INF;void init() &#123; goDown.set(); memset(h, 0, sizeof(h)); p[0] = 0;&#125;void judgeDown(int i) &#123; if (h[i] &gt;= h[i + 1] + p[i + 1] - p[i]) goDown[i] = 1; else if (h[i] + h[i + 1] &lt;= p[i + 1] - p[i]) goDown[i] = 1; else goDown[i] = 0;&#125;bool judgeCan(int i) &#123; if (p[i] - p[i - 1] + h[i - 1] &lt; h[i]) return false; else return true;&#125;// 以上两个 judge 函数是 WA 之精髓所在（雾）// 只考虑了相邻两个仙人掌的关系，如果在下降的时候撞到另外一个仙人掌// 那么小恐龙就 GG 了double calh(int x, int y) &#123; if (h[x] &gt; h[y] + p[y] - p[x] &amp;&amp; x + 1 == y) return (double)h[x]; else return (double)(p[y] - p[x] + h[x] + h[y]) / 2.0;&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("dinosaur.in"); ofstream out("dinosaur.out"); in.tie(NULL); in &gt;&gt; n; init(); for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; p[i] &gt;&gt; h[i]; if (!judgeCan(i)) &#123; out &lt;&lt; -1; return 0; &#125; else continue; &#125; for (int i = 1; i &lt; n; ++i) judgeDown(i); int key = 1; double tmp; for (int i = 1; i &lt;= n &amp;&amp; key &lt;= n; ++i) &#123; if (goDown[i]) &#123; double tmp = calh(key, i); ans = max(ans, tmp); key = i + 1; if (p[i] + h[i] &gt; p[i + 1]) key += 1; &#125; &#125; out &lt;&lt; setprecision(1) &lt;&lt; fixed &lt;&lt; ans; return 0;&#125;// 这个实例告诉大家，贪心前先做好分析准备工作，否则就会像我这样...... 那么到底该怎么做呢？ 由于这是一只理（bian）想（tai）化过的小恐龙，它只会与地面呈$45$度跳跃，而且可以无限升天，法力无边，所以我们可以从每一个仙人掌的跳跃边界来考虑： 考虑两种不同的仙人掌情况： 那么就有两种做法了，第一种，删去所有像绿色仙人掌那样的仙人掌，然后直接计算；第二种，也是标程的方法，逐个进行判断，维护 first 和 last 这两个值，分别表示一组跳跃（一次上和一次下）的左右边界，然后计算。 [参考代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 注：本代码使用的是第二种方法// 使用第一种方法的同学可以使用类链表的方式来存储数据，加快效率#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 310000struct segment &#123; int l; int r; &#125;;int n, p, h;double ans = 0;segment a[maxn];bool compare(segment a, segment b) &#123; return a.l &lt; b.l || (a.l == b.l &amp;&amp; a.r &lt; b.r);&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("dinosaur.in"); ofstream out("dinosaur.out"); in.tie(NULL); in &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; p &gt;&gt; h; a[i].l = p - h; a[i].r = p + h; &#125; sort(a + 1, a + n + 1, compare); if (a[1].l &lt; 0) &#123; cout &lt;&lt; -1; return 0; &#125; int last = a[1].r; int first = a[1].l; for (int i = 2; i &lt;= n; ++i) &#123; if (a[i].l &lt; last) last = max(last, a[i].r); else &#123; ans = max(ans, (last - first) * 1.0 / 2.0); first = a[i].l; last = a[i].r; &#125; &#125; ans = max(ans, (last - first) * 1.0 / 2.0); out &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; ans; return 0;&#125; [评价] 其实思维难度并不大，主要是考验对算法是否掌握到位，譬如用贪心，这道题并不能从头贪到尾，那样会出问题，必须考虑所有可能情况，这也是本题样例的坑人之处所在，以后考试时，如果只有一个样例，那必须得小心出题老师出阴招，最好是自己脑滚键盘来出几个数据手算测试一下。 T2 相交(inter.cpp/c/pas)——旧时 Dijkstra 堂前 O(mlog n)，飞入寻常 NOIER 家。 [题目描述] 一棵大树下有$n$个巢穴，由$n-1$条双向道路连接，任意两个城市均可互相到达。大树附近有两群蚂蚁，每天早上，第一群蚂蚁会派一只蚂蚁到这棵树下，并在第$a$个巢穴到第$b$ 个巢穴间的最短路径上的每个巢穴留下气味。每天傍晚，第二群蚂蚁会派一只蚂蚁到这棵树下，并侦查第$c$个巢穴到第$d$个巢穴间的最短路径上是否有蚂蚁留下的气味。每天蚂蚁留下的气味会在当天深夜消失。 [输入] 第一行一个正整数 n，含义如题所示。 接下来 n-1 行，每行两个正整数 u,v，表示第 u 个巢穴和第 v 个巢穴间有一条双向道路。 接下来一行一个正整数 q，表示天数。 接下来 q 行，每行四个正整数 a,b,c,d，含义如题所示。 [输出] q 行，每行一个字符串。 若第二群派出的蚂蚁侦查到蚂蚁留下的气味，则输出”YES”,否则输出”NO” [样例输入] 样例输入 1 8 1 2 1 3 2 4 2 5 5 6 5 7 3 8 4 2 5 4 3 5 3 8 8 5 4 6 7 4 8 6 7 样例输入 2 15 2 1 3 1 4 2 5 3 6 2 7 2 8 5 9 3 10 6 11 5 12 7 13 11 14 1 15 1 5 1 2 3 4 4 7 1 9 2 3 7 9 2 6 7 8 2 1 6 8 [样例输出] 样例输出 1 YES NO YES NO 样例输出 2 YES NO YES YES YES [数据规模] 对于 30%的数据 1&lt;=n,q&lt;=3000 对于另外 20%的数据 第 i 条边连接第 i 个巢穴和第 i+个巢穴 对于 100%的数据 1&lt;=n,q&lt;=100000 [题解] 首先讲一下我考试的时候是怎么想的，我想既然是最短路径，还是个图（当时没看出是树），那么 Dijkstra 无疑了，潇潇洒洒一百行打完，用了两个 bitset 再用了一个神奇的方法记录路径。好！就是这样，一定 AC 了！结果：TLE……附上 Dijkstra 暴力代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define maxq 110000#define NOE -1#define INF 0x3f3f3f3fstruct edgeNode &#123; int vertexFrom; int vertexTo; int edgeNext; bool weight;&#125;;struct heapNode &#123; int u, d; bool operator&lt;(const heapNode&amp; b) const &#123; return d &gt; b.d; &#125;&#125;;edgeNode edges[maxn];int heads[maxn];int numEdges = 0;int n, q, u, v, a, b, c, d;bool judge = true;bitset&lt;maxn&gt; smell1;bitset&lt;maxn&gt; smell2;int path[maxn];int dist[maxn];priority_queue&lt;heapNode&gt; Q;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexFrom = vertex1; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = true; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1);&#125;void Dijkstra(int x) &#123; while (!Q.empty()) Q.pop(); for (int i = 1; i &lt;= n; ++i) dist[i] = INF; for (int i = 1; i &lt;= n; ++i) path[i] = i; dist[x] = 0; Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int dis = f.d; if (dis != dist[u]) continue; for (int i = heads[u]; i != NOE; i= edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[u] + w) &#123; dist[j] = dist[u] + w; path[j] = u; // 记录路径 Q.push((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125;void updateSmell1(int a, int b) &#123; int tmp = b; while (tmp != a) &#123; smell1[tmp] = 1; tmp = path[tmp]; &#125;&#125;void updateSmell2(int c, int d) &#123; int tmp = d; while (tmp != c) &#123; smell2[tmp] = 1; tmp = path[tmp]; &#125;&#125;int main() &#123; freopen("inter.in", "r", stdin); freopen("inter.out", "w", stdout); // fstream 不知怎么就不能取消 sync_with_stdio，为了加快速度只能使用 freopen init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n - 1; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addDuplexEdge(u, v); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; smell1.reset(); smell2.reset(); scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); if ((a == c &amp;&amp; b == d) || (a == d &amp;&amp; b == c)) &#123; printf("YES\n"); continue; &#125; smell1[a] = 1; smell2[c] = 1; // TLE TLE TLE TLE TLE TLE TLE TLE TLE TLE TTTTTTLLLLLLEEEE Dijkstra(a); updateSmell1(a, b); Dijkstra(c); updateSmell2(c, d); // TLE TLE TLE TLE TLE TLE TLE TLE TLE TLE TTTTTTLLLLLLEEEE judge = (smell1 &amp; smell2).any(); if (judge) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 其实如果看出了这是棵树的话，是可以用广搜的……可以快不少。 好了，说正解：就像上面所说的，这是一棵树（啥？你问我怎么看出的？仔细读题！！），所以获取最短距离一定是求两个点的 $LCA$ 了。那如何标记呢？？这是个好问题，一般我们都会去想标记经过的点，然而，如果用倍增 $LCA$ 求，一定会跳过经过的点，如果用朴素算法求的话……那还不如 $BFS$，那么我们就必须使用另外的方法了。 首先我们画一棵树： 通过观察和举例，我们发现，只有当 $a$ 和 $LCA(c, d)$ 在同一条链上，且 $LCA(a, b)$ 也在这条链上； $b$ 和 $LCA(c, d)$ 在同一条链上，且 $LCA(a, b)$ 也在这条链上； $c$ 和 $LCA(a, b)$ 在同一条链上，且 $LCA(c, d)$ 也在这条链上； $d$ 和 $LCA(a, b)$ 在同一条链上，且 $LCA(c, d)$ 也在这条链上； 以上四者满足其一时才能够是 YES，否则就是 NO。 为什么是这样？如何实现呢？首先思考：到达$a$，$b$两点必定经过它们的 $LCA$，那么，只要它们两点与另外两点的 $LCA $在一条链上（这个不是很严谨，这里的链指的是将树看成 $DAG$ 时，即若 $LCA(u, v) = v$ 时，$u$，$v$在一条链上），且它们两个点的 $LCA$ 深度比另外两点的深度小时，两条路径必有重叠的部分（如图，$d$与 $LCA(a, b)$ 在一条链上，且 $LCA(a, b)$ 的深度比 $LCA(c, d)$ 的深度大，所以两者路径必有交集） 如此分析，代码也就呼之欲出了。 [参考代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define NOE -1struct edgeNode &#123; int vertexTo; int edgeNext;&#125;;edgeNode edges[maxn &lt;&lt; 1];// 注意由于是无向边，而前向星只能按照双向边处理，所以要乘二int heads[maxn];int numEdges = 0;int f[maxn][20], dep[maxn];int n, q, u, v, a, b, c, d;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1);&#125;void rDFS(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 18; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) if (edges[i]. vertexTo != fa) rDFS(edges[i].vertexTo, x);&#125;int LCA(int u, int v) &#123; for (int i = 18; i &gt;= 0; --i) if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; for (int i = 18; i &gt;= 0; --i) if (dep[f[v][i]] &gt;= dep[u]) v = f[v][i]; if (u == v) return u; for (int i = 18; i &gt;= 0; --i) if (f[u][i] != f[v][i]) &#123; u = f[u][i]; v = f[v][i]; &#125; return f[u][0];&#125;// 找 LCAbool inOneChain(int u, int v, int w) &#123; return (LCA(u, w) == w) &amp;&amp; (dep[w] &gt;= dep[v]); // 判断链和深度关系&#125;bool judge(int a0, int b0, int c0, int d0) &#123; int lca1 = LCA(a0, b0); int lca2 = LCA(c0, d0); return (inOneChain(a0, lca1, lca2) || inOneChain(b0, lca1, lca2) || inOneChain(c0, lca2, lca1) || inOneChain(d0, lca2, lca1)); // 四者只要满足其一就会有交集，所以取或就行&#125;int main() &#123; freopen("inter.in", "r", stdin); freopen("inter.out", "w", stdout); // 我也不知道为什么，fstream 一关掉同步就会崩，无奈只能用 freopen scanf("%d", &amp;n); init(); // 循环时 i 只能到 n - 1，还是提醒仔细读题 for (int i = 1; i &lt; n; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addDuplexEdge(u, v); &#125; memset(f, 0, sizeof(f)); // 别忘记初始化 rDFS(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); if (judge(a, b, c, d)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; [评价] 思维难度较大，想到求交集的方法后仍然要画很多图来总结规律，否则规律很有可能是错误的或者是片面的。再次提醒仔细读题，因为题目中包含了很多隐藏条件，这些隐藏条件也尤为重要，不管是对正解还是对暴力朴素算法来说，都可以提高效率。这是一道难题，还是一道坑题。 T3 聪明格(kenken.cpp/c/pas)[题目描述]聪明格是一种数字游戏，又堪称升级版的数独，诞生日本。它在数学上的要求比数独要高得多，它把数独规则与加减乘除四则运算相结合，使大脑在各种谜题中来回穿梭。 它的规则是这样的：有一个 $n\times n$ 的棋盘，每个格子里填一个在 1~n 范围内的数，使得每行每列没有重复的数字，(即 1~n 每个数在每行和每列各出现一次)，且满足下列条件: 现在给你一个 $n\times n$ 的棋盘，让你完成它，并输出解的个数和字典序最小的方案。数据保证一定有解。 [输入] 第一行一个正整数 n，表示棋盘的行数和列数。 接下来 n 行，每行 n 个正整数。表示：相同数字构成了许多个连通块， 假设这个四连通块内每个数字都为 a,那么你在这些格子上填的数的乘积 应该等于 a。（具体描述见样例） [输出] 输出共 n+1 行，第一行输出解的个数 接下来 n 行，每行 n 个正整数。表示 n*n 的矩阵里每个数字的值 （字典序最小的方案）。 [输入样例 1] 4 6 6 1 144 6 2 144 144 4 2 144 4 12 12 4 4 注：此样例所对应 4*4 的棋盘即为上图。 [输出样例 1] 1 2 3 1 4 1 2 4 3 4 1 3 2 3 4 2 1 [输入样例 2] 3 12 12 18 12 12 18 18 18 18 [输出样例 2] 4 1 2 3 2 3 1 3 1 2 [输入样例 3] 9 32353542 4254 54 544 322735576 10108108 1084 927576576 1040 40 1008 1008 9270576576 814 14 1008 1008 142702705768105 3283 14426882727 105 32810 302688268880 6105 63 6310 30 2688 12680 8024 3 639 66126126 126 24 24 40 40 [输出样例 3] 1 8 1 5 6 7 9 2 3 4 4 3 7 8 5 6 9 2 1 1 9 4 3 2 8 5 6 7 9 5 3 1 8 2 7 4 6 7 6 9 2 1 5 4 8 3 2 4 6 9 3 7 8 1 5 5 7 8 4 6 3 1 9 2 6 8 2 5 4 1 3 7 9 3 2 1 7 9 4 6 5 8 [数据规模] 测试点 n= 输入矩阵中不同种类数字个数 1-2 3 &gt;=3 3-4 5 &gt;=10 5-7 9 &gt;=30 8-10 9 &gt;=20 100% 的数据满足，矩阵中每个数字&lt;=100,000，合法棋盘个数（解的个数）&lt;=300 [题解] 这里先不多说了，关于舞蹈链我在后面的博客中会详细讲解，此处直接贴标程。 [参考代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std; const int N=11,M=510;const int dx[4]=&#123;1,0,-1,0&#125;;const int dy[4]=&#123;0,1,0,-1&#125;;struct node2&#123; int c[N][N]; &#125; ans[M];bool operator&lt; (node2 x,node2 y)&#123; for(int i = 1; i &lt; N; i++) for(int j = 1; j&lt;N; j++) if(x.c[i][j] != y.c[i][j]) return x.c[i][j] &lt; y.c[i][j]; return 0;&#125;struct node&#123; int x, y; &#125;;vector&lt;node&gt; b[N * N];vector&lt;int&gt; p[N * N]; int a[N][N], c[N][N], h[N][N], h1[N][N], h2[N][N];int n, cnt = 0, tot = 0;int read() &#123; int x = 0, f = 1; char c = 0; for (; !isdigit(c); c=getchar()) if(c == '-') f = -1; for (; isdigit(c); c=getchar()) x = x * 10 + c - 48; return x * f;&#125;int factor(int x) &#123; int t = 0; for (int i = 1; i * i &lt;= x; i++) t += (int)(x % i == 0); return t;&#125;bool cmp(vector&lt;node&gt; x, vector&lt;node&gt; y) &#123; if (x.size() == y.size()) return factor(x[0].x) &lt;= factor(y[0].x); return x.size() &lt; y.size();&#125;void divide(int t, int x)&#123; for (int i = 1; i &lt;= n; i++) if (x % i == 0) p[t].push_back(i);&#125;void dfs(int x, int y) &#123; h[x][y] = 1; b[cnt].push_back((node)&#123; x, y &#125;); for (int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i]; int ty = y + dy[i]; if (tx &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= n &amp;&amp; !h[tx][ty] &amp;&amp; a[tx][ty] == a[x][y]) dfs(tx, ty); &#125;&#125;void work(int dep);void fillp(int t, int dep, int s, int tot) &#123; if (dep &gt; tot) work(t + 1); else &#123; int x=b[t][dep].x, y = b[t][dep].y; for (int i = 0; i &lt; p[t].size(); i++) &#123; int u=p[t][i]; if ((s == u || dep &lt; tot) &amp;&amp; s % u == 0 &amp;&amp; !h1[x][u] &amp;&amp; !h2[y][u])&#123; h1[x][u] = 1； h2[y][u] = 1; c[x][y] = u; fillp(t, dep + 1, s / u, tot); c[x][y] = 0; h1[x][u] = 0； h2[y][u]=0; &#125; &#125; &#125;&#125;void work(int dep) &#123; if (dep &gt; cnt) &#123; tot++; for (int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) ans[tot].c[i][j] = c[i][j]; &#125; else &#123; int num=b[dep][0].x； int tot=b[dep].size() - 1; fillp(dep, 1, num, tot); &#125;&#125;int main() &#123; freopen("kenken.in", "r", stdin); freopen("kenken.out", "w", stdout); n = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (!h[i][j]) &#123; cnt++; b[cnt].push_back((node)&#123; a[i][j], 0 &#125;); dfs(i, j); &#125; sort(b + 1, b + cnt + 1, cmp); for (int i = 1; i &lt;= cnt; i++) divide(i, b[i][0].x); work(1); cout &lt;&lt; tot &lt;&lt; "\n"; node2 t = ans[1]; for (int i = 2; i &lt;= tot; i++) t = min(t, ans[i]); for (int i = 1;i &lt;= n; i++)&#123; for (int j = 1; j &lt; n; j++) cout &lt;&lt; t.c[i][j] &lt;&lt; " "; cout &lt;&lt; t.c[i][n] &lt;&lt; "\n"; &#125; return 0;&#125; 本次考试总结Too young, too simple, sometimes naive……还是要提高知识水平和编程素养，防止考试时 GG。]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
        <tag>题解</tag>
        <tag>神题</tag>
        <tag>爆零日</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[数论] 数论基础知识----莫比乌斯函数]]></title>
    <url>%2F2018%2F08%2F08%2F%E6%95%B0%E8%AE%BA-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[写在前面最近自己在自学数论，为了保证遇到数论的题的时候能从容不迫地应对，本篇文章主要是对莫比乌斯函数( $\mu{(n)}$ )的初步了解 莫比乌斯函数定义莫比乌斯函数 $\mu{(n)}$ 的定义如下： $$ \mu(1) = 1; $$ 如果 $n&gt;1$，写 $n=p_1^{a_1}p_2^{a_2}p_3^{a_3}…p_k^{a_k}$，则： $$\mu(n)=\begin{cases}(-1)^k &amp; \text{when $a_1=a_2=a_3=…=a_k=1$,}\\0 &amp; \text{otherwise.}\end{cases}$$ 注 $\mu(n)=1$当且仅当$n$有一个大于$1$的平方因子。 定理莫比乌斯函数在数论中经常出现（上次就被它狠狠地坑了一次），它的基本性质之一是对约束求和 $\sum_{d|n}\mu{(d)}$ 的一个重要的简明公式，它在$n$的正约数上展开，式子中的 $\left[x\right]$ 表示不大于$x$的最大整数。定理如下： [定理描述]如果${n}\geqslant{1}$，我们有$$\sum_{d|n}\mu{(d)}=\left[\frac{1}{n}\right]=\begin{cases}1 &amp;\text{when $n=1$,}\\0 &amp;\text{when $n&gt;1$.}\end{cases}$$ [定理证明]（运用了二项式定理）对于 $n=1$，等式显然成立。设 $n&gt;1$ 并写 $n=p_1^{a_1}…p_k^{a_k}$ ，在 $\sum_{d|n}\mu{(d)}$ 中非零的项仅来自于 $d=1$ 与 $n$ 的约数是不同素数的乘积，即$$\begin{aligned}\sum_{d|n}\mu{(d)}={}&amp; \mu(1)+\mu(p_1)+…+\mu(p_k)+\mu(p_1p_k)+…+{} \\&amp;\mu(p_{k-1}p_k)+…+\mu(p_1p_2…p_k){}\\={}&amp;1+\binom{k}{1}(-1)+\binom{k}{2}(-1)^2+…+\binom{k}{k}(-1)^k{}\\={}&amp;0\end{aligned}$$ 总结莫比乌斯函数本身其实并不难，但是要深刻地理解它还是有一点点困难的，以后会和别的有关函数结合起来进行讲解，加深记忆。]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>莫比乌斯函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 2018-8-7 题解: 我写了个自己都看不懂的程序]]></title>
    <url>%2F2018%2F08%2F07%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-7-%E9%A2%98%E8%A7%A3-%E6%88%91%E5%86%99%E4%BA%86%E4%B8%AA%E8%87%AA%E5%B7%B1%E9%83%BD%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[写在前面今天创历史新高$290$分，第三道题考完自己都没看出自己用了啥方法（Orz），感觉自已要去补数据结构……另外第一道题实在是坑……十分啊！！ T1 选举[题目描述] $C$国的总统选举委员会最近遇到了一些麻烦。 他们在统计各省对H先生的支持率（百分比）时，把支持率四舍五入到了整数。等他们公布结果后，该国媒体发现这些省份的支持率之和不等于$100$（百分比）！在媒体黑幕声的质疑下，他们不得不找你寻求帮助。 你将得到各省四舍五入后的支持率，请计算这些省份的支持率在四舍五入前的和是否可能等于100？支持率是以百分比的形式统计的。请注意，各省的支持率可以是一个包含任意多位的有限小数。一个小数在四舍五入到整数时，若小数点后第一位小于5则舍，大于等于5则入。 例如：$26,17,58$是一种可能的支持率，因为它们可能是$25.8,16.5,57.7$四舍五入后得到的，而$25.8+16.5+57.7=100$。$49,49$是一种不可能的支持率，因为当$9$的个数有限时，无论有多少个$9$，均有$49.499+…+99+49.499+…+99&lt;100$。 [输入格式] 输入包含多组数据，第一行是一个整数T，表示数据组数。 接下来是T组数据，每组数据的第一行是一个整数N，表示参与选举的省份个数。 第二行是N个整数，表示各省四舍五入后的支持率。 [输出格式] 对于每组数据，若是一种可能的支持率，输出Yes，否则输出No。 [样例输入] 2 2 49 49 3 26 17 58 [样例输出] No Yes [数据范围与约定] 对于30%的数据，1&lt;=n&lt;=3； 对于50%的数据，1&lt;=n&lt;=5； 对于80%的数据，1&lt;=四舍五入后各省的支持率&lt;=99； 对于100%的数据，1&lt;=n&lt;=10000，输入数据中的所有整数均在有符号16位整数范围内。 [题解] 简单数值计算题，直接讨论情况并计算即可。具体来讲，可以求出使用给出的$N$个支持率，最终可能的支持率的取值范围，检查该范围是否包含$100$。一般情况下，一个数X在取舍前可能取$[X-0,5,X+0.5)$之间的任意数值。需要注意$0$和$100$等边界问题，因为支持率（百分比）一定是一个$[0,100]$之间的数。求出的取值范围最好使用整数并加以开闭区间判断，避免实数精度误差。 [参考代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define int64 long longint T, n, x;int64 sum, l, r;int main() &#123; ios::sync_with_stdio(false); ifstream in("election.in"); ofstream out("election.out"); in.tie(NULL); in &gt;&gt; T; while (T--) &#123; in &gt;&gt; n; int cnt0 = 0, cnt100 = 0, flag = 0; sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; x; sum += x; if (x == 0) ++cnt0; if (x == 100) ++cnt100; if (x &gt; 100) flag = 1; &#125; if (flag) &#123; out &lt;&lt; "No" &lt;&lt; endl; continue; &#125; l = sum - (n - cnt0) / 2; r = sum + (n + cnt100) / 2; bool cond0 = (l &lt;= 100); bool cond1; if ((n - cnt100) &amp; 1 || (n - cnt100) == 0) cond1 = (r &gt;= 100); else cond1 = r &gt; 100; if (cond0 &amp;&amp; cond1) out &lt;&lt; "Yes" &lt;&lt; endl; else out &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125;// 注：这个其实是标程，连 double 都没有用 （Orz） [评价] 考察了基础的数学知识，只要搞清楚开区间和闭区间就好了。 T2 异象石[题目描述] Adera 是 Microsoft 应用商店中的一款解谜游戏。异象石是进入 Adera 中异时空的引导物，在 Adera 的异时空中有一张地图。这张地图上有$N$个点，有$N-1$条双向边把它们连通起来。起初地图上没有任何异象石，在接下来的$M$个时刻中，每个时刻会发生以下三种类型的事件之一： 地图的某个点上出现了异象石（已经出现的不会再次出现）； 地图某个点上的异象石被摧毁（不会摧毁没有异象石的点）； 向玩家询问使所有异象石所在的点连通的边集的总长度最小是多少。 请你作为玩家回答这些问题。 [输入格式] 第一行有一个整数N，表示点的个数。 接下来N-1行每行三个整数x,y,z，表示点x和y之间有一条长度为z的双向边。 第N+1行有一个正整数M。 接下来M行每行是一个事件，事件是以下三种格式之一： + x 表示点x上出现了异象石 - x 表示点x上的异象石被摧毁 ?表示询问使当前所有异象石所在的点连通所需的边集的总长度最小是多少。 [输出格式] 对于每个 ?事件，输出一个整数表示答案。 [样例输入] 6 1 2 1 1 3 5 4 1 7 4 5 3 6 4 2 10 + 3 + 1 ? + 6 ? + 5 ? - 6 - 3 ? [样例输出] 5 14 17 10 [数据范围与约定] 对于30%的数据，1 ≤ n, m ≤ 1000。 对于另20%的数据，地图是一条链，或者一朵菊花。 对于100%的数据，1 ≤ n, m ≤ 10^5, 1 ≤ x, y ≤ n, x ≠ y, 1 ≤ z ≤ 10^9。 [题解] 如果在$a_1,a_2…a_k$这些点上有异象石，则所需代价就是按照DFS序依次遍历这$k$个点再回到根的总距离。这个距离数还等于$a_1,a_2…a_k$排成一个环形序列，相邻两个点的距离之和。因此用set维护有异象石的点构成的DFS序，用一个全局变量记录答案，插入、删除时更新set的同时利用LCA算法更新答案。 [参考代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define NOE -1#define int64 long longint n, m, x, y, z, v;char op;set&lt;int&gt; s;int64 ans, dis[maxn], g[maxn];int cnt = 0;int f[maxn][20], dep[maxn], dfn[maxn], seq[maxn];struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125;;edgeNode edges[maxn &lt;&lt; 1];int heads[maxn &lt;&lt; 1];int numEdges = 0;inline void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;inline void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;inline void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125;inline void rDFS(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; dfn[x] = ++cnt; seq[cnt] = x; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int vt = edges[i].vertexTo; if (vt != fa) &#123; dis[vt] = dis[x] + edges[i].weight; rDFS(vt, x); &#125; &#125;&#125;inline void initFa() &#123; for (int i = 1; i &lt;= 19; ++i) for (int j = 1; j &lt;= n; ++j) f[j][i] = f[f[j][i - 1]][i - 1];&#125;inline int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); int t = dep[x] - dep[y]; for (int i = 0; i &lt;= 16; ++i) if (t &amp; (1 &lt;&lt; i)) x = f[x][i]; if (x == y) return x; for (int i = 16; i &gt;= 0; --i) &#123; if (f[x][i] != f[y][i]) &#123; x = f[x][i]; y = f[y][i]; &#125; &#125; return f[x][0];&#125;inline int64 getDist(int x, int y) &#123; return dis[x] + dis[y] - dis[LCA(x, y)] * 2;&#125;inline void find(int x, int &amp;l, int &amp;r) &#123; set&lt;int&gt;::iterator it = s.lower_bound(x); if (it != s.end()) r = *it; else r = *s.begin(); if (it == s.begin()) it = s.end(); l = *(--it); l = seq[l]; r = seq[r];&#125;inline void insert(int x) &#123; if (!s.empty()) &#123; int l, r; find(dfn[x], l, r); ans -= g[r]; g[x] = getDist(l, x); g[r] = getDist(x, r); ans += g[x] + g[r]; &#125; else g[x] = 0; s.insert(dfn[x]);&#125;inline void erase(int x) &#123; int l, r; s.erase(dfn[x]); if (!s.empty()) &#123; find(dfn[x], l, r); ans -= g[x] + g[r]; g[r] = getDist(l, r); &#125; ans += g[r];&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("stone.in"); ofstream out("stone.out"); in.tie(NULL); init(); in &gt;&gt; n; for (int i = 1; i &lt; n; ++i) &#123; in &gt;&gt; x &gt;&gt; y &gt;&gt; z; addDuplexEdge(x, y, z); &#125; rDFS(1, 0); initFa(); in &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; in &gt;&gt; op; switch (op) &#123; case '+' : &#123; in &gt;&gt; v; insert(v); break; &#125; case '-' : &#123; in &gt;&gt; v; erase(v); break; &#125; case '?' : &#123; out &lt;&lt; ans / 2 &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;// 这道题必须一次操作更新一次答案，否则会 TLE 此处附上 std::set 的用法 [评价] 对于没有做过的同学来说，思维难度还是比较大的，这种方法就直接记住就行了，要用的时候直接拿出来用。 T3 序列变换（本次重点！！！）[题目描述] 给定一个长度为$N$的数列$A_i$。你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。 [输入格式] 第一行是一个正整数N。 第二行是N个正整数Ai。 [输出格式] 输出一个整数，表示最少需要的操作次数。 [样例输入] 5 6 3 7 8 6 [样例输出] 2 [数据范围与约定] 对于30%的数据，满足1≤n≤10。 对于60% 的数据，满足1≤n≤1000。 对于100% 的数据，满足1≤n≤1000000，1≤Ai≤1000000。 [题解] 经过分析可以发现，最优解情况下，需要保持一个子序列不动，这个子序列满足： 子序列单调递增； 若子序列中最小数是$L$，最大数是$R$，则子序列必须包含$[L+1,R-1]$中的数列中的所有数。 用单调队列求出满足这两个条件的子序列的最大长度，用$n$减去就是答案。即这个子序列保持不动，其余数向前或后移动一次。 [参考代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 以下为 std 代码，不感兴趣的同学可以跳过#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;set&gt;using namespace std;const int SIZE = 1000010;int a[SIZE], q[SIZE];int n, m, ans;vector&lt;int&gt; b[SIZE];int main() &#123; freopen("change.in","r",stdin); freopen("change.out","w",stdout); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[a[i]].push_back(i); m = max(m, a[i]); &#125; int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) &#123; reverse(b[i].begin(), b[i].end()); for (int j = 0; j &lt; b[i].size(); j++) &#123; int k = b[i][j]; while (l &lt;= r &amp;&amp; q[r] &gt; k) &#123; while (l &lt; r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++; r--; &#125; ans = max(ans, r - l + 2 + j); &#125; for (int j = b[i].size() - 1; j &gt;= 0; j--) &#123; q[++r] = b[i][j]; &#125; //cout &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; n - ans &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 以下是考试时瞎打的代码：#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1100000#define INF 0x3f3f3f3fint n, A[maxn], B[maxn];int ans = -INF;int len = 0;inline bool compare(int x, int y) &#123; if (A[x] == A[y]) return x &lt; y; return A[x] &lt; A[y];&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("change.in"); ofstream out("change.out"); in.tie(NULL); in &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; A[i]; B[i] = i; &#125; sort(B + 1, B + n + 1, compare); // B 数组记录 A 中元素的 位置，且以 A 中相应的元素大小为优先排序 int j; for (int i = 1; i &lt;= n; i = j + 1) &#123; for (j = i; i &lt; n &amp;&amp; B[j] &lt; B[j + 1]; j++); len = j - i + 1; // 以上这段先找出从 i 开始序号递增的子序列的最大长度 for (int k = i - 1; k != 0 &amp;&amp; A[B[k]] == A[B[i - 1]]; --k) if (B[k] &lt; B[i]) len++; for (int k = j + 1; k &lt;= n &amp;&amp; A[B[j + 1]] == A[B[k]]; ++k) if (B[j] &lt; B[k]) len++; // 因为前面 i 直接变为 j + 1，所以可能出现重复的数字忽略的情况 // 故在上面两个循环中： // 一个向左扫，一个向右扫，同时判断在原数组中的位置是否递增 // 这种方法速度会更快一点。 ans = max(ans, len); // 获取最大长度 &#125; out &lt;&lt; n - ans; // 相减 return 0;&#125;// 考完试后自己都无法记起这是什么神奇的算法，不过仔细想想还是能想起来的。 [评价] 这道题既考验思维又考验代码能力，好题。 总结首先，仍然要记住仔细读题，这次第一题就是因为读题不仔细，思考不充分才出问题的。其次，有些代码还是好好打打草稿，写写流程图比较好，防止像第三题一样想不起来（#滑稽）。]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
        <tag>题解</tag>
        <tag>神题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP 模拟] 2018-8-6 题解: 一次戏剧性的模拟测试]]></title>
    <url>%2F2018%2F08%2F06%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-6-%E9%A2%98%E8%A7%A3-%E4%B8%80%E6%AC%A1%E6%88%8F%E5%89%A7%E6%80%A7%E7%9A%84%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[今天模拟测试一共有三道题，这里先发一下有关这三道题的题解，有关这几类题目的详解会在以后更新。 T1 奇数码问题[题目描述] 你一定玩过八数码游戏，它实际上是在一个$3\times 3$的网格中进行的，$1$个空格和$1 \sim 8$这$8$个数字恰好不重不漏地分布在这$3 \times 3$的网格中。 例如： 5 2 8 1 3 _ 4 6 7 在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。例如在上例中，空格可与左、上、下面的数字交换，分别变成： 5 2 8 5 2 _ 5 2 8 1 _ 3 1 3 8 1 3 7 4 6 7 4 6 7 4 6 _ 奇数码游戏是它的一个扩展，在一个$n \times n$的网格中进行，其中n为奇数，1个空格和$1 \sim n\times n-1$这$n\times n-1$个数恰好不重不漏地分布在$n\times n$的网格中。 空格移动的规则与八数码游戏相同，实际上，八数码就是一个$n=3$的奇数码游戏。 现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。 [输入格式] 多组数据，对于每组数据： 第1行一个奇整数n。 接下来n行每行n个整数，表示第一个局面。 接下来n行每行n个整数，表示第二个局面。 局面中每个整数都是0~n*n-1之一，其中用0代表空格，其余数值与奇数码游戏中的意 义相同，保证这些整数的分布不重不漏。 [输出格式] 对于每组数据，若两个局面可达，输出TAK，否则输出NIE。 [样例输入] 3 1 2 3 0 4 6 7 5 8 1 2 3 4 5 6 7 8 0 1 0 0 [样例输出] TAK TAK [数据范围与约定] 对于30%的数据，1&lt;=n&lt;=3； 对于60%的数据，1&lt;=n&lt;=50； 对于100%的数据，1&lt;=n&lt;=500，n为奇数，每个测试点不超过10组。 [题解] 通过题目可知，这是一道经典的八数码问题，可以说是模板题。对于这种问题，可以把方阵转为链（忽略输入的$0$），然后统计初始状态和目标状态的逆序对的数量。若逆序对数的奇偶性相同，则可以到达，否则不行。 [参考代码] 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int n, a, t[300010];inline void modify(int x) &#123; for (int i = x; i &lt;= n; i += i &amp; -i) ++t[i];&#125;inline int query(int x) &#123; int res = 0; for (int i = x; i; i -= i &amp; -i) res += t[i]; return res;&#125;inline int work() &#123; memset(t, 0, sizeof(t)); int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;a); if (!a) continue; cnt += query(n) - query(a); modify(a); &#125; return cnt &amp; 1;&#125;int main() &#123; freopen("digital.in", "r", stdin); freopen("digital.out", "w", stdout); for (; scanf("%d", &amp;n) == 1; ) &#123; n *= n; if (work() == work()) printf("TAK\n"); else printf("NIE\n"); &#125; return 0;&#125;// 此处使用了树状数组做// 本题还可以使用归并排序做，有兴趣的同学可以试试看用归并排序做。 [评价] 第一题嘛……水题，模板题，送分题…… T2 树洞[题目描述] 在一片栖息地上有$N$棵树，每棵树下住着一只兔子，有$M$条路径连接这些树。更特殊地是，只有一棵树有$3$条或更多的路径与它相连，其它的树只有$1$条或$2$条路径与其相连。换句话讲，这些树和树之间的路径构成一张$N$个点、$M$条边的无向连通图，而度数大于$2$的点至多有$1$个。 近年以来，栖息地频繁收到人类的侵扰。兔子们联合起来召开了一场会议，决定在其中$K$棵树上建造树洞。当危险来临时，每只兔子均会同时前往距离它最近的树洞躲避，路程中花费的时间在数值上等于距离。为了在最短的时间内让所有兔子脱离危险，请你安排一种建造树洞的方式，使最后一只到达树洞的兔子所花费的时间尽量少。 [输入格式] 第一行有3个整数N，M，K，分别表示树（兔子）的个数、路径数、计划建造的树洞数。 接下来M行每行三个整数x,y，表示第x棵树和第y棵树之间有一条路径相连。 1&lt;=x,y&lt;=N，x≠y，任意两棵树之间至多只有1条路径。 [输出格式] 一个整数，表示在最优方案下，最后一只到达树洞的兔子所花费的时间。 [样例输入] 5 5 2 1 2 2 3 3 1 1 4 4 5 [样例输出] 1 [数据范围与约定] 对于20%的数据，1 ≤ n ≤ 10。 对于另外30%的数据，每棵树至多与2条路径相连。 对于另外30%的数据，保证存在一种最优解，使与3条或更多路径相连的树上一定建造了树洞。 对于100%的数据，1 ≤ n ≤ 2000，n-1&lt;=m&lt;=n*(n-1)/2。 [题解] 求最大值最小，而且答案满足单调，很显然可以用二分如何验证？首先考虑一条链的情况，答案必然是$\frac{n - k}{k}$； 而另外存在一个特殊点有三条及以上的边的情况我们先枚举一个点，可以将特殊点覆盖，覆盖后，原来的图将断成若干条链，然后重复之前链的做法统计答案是否超过k，来判断二分的答案是否正确 [参考代码] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;int n, m, k, rt, deep, mi;int deg[2005], dis[2005];bool vis[2005], first[2005];int head[2005], num;struct edge &#123; int nxt, to;&#125; e[4000005];void add(int x, int y) &#123; e[++num].nxt = head[x]; e[num].to = y; head[x] = num;&#125;void dfs(int x, int len) &#123; deep += 1; vis[x] = 1; if (!len) return; for (int i = head[x]; i; i = e[i].nxt) &#123; int v = e[i].to; if (!vis[v]) &#123; dis[v] = dis[x] + 1; dfs(v, len - 1); &#125; &#125;&#125;bool check(int x) &#123; memset(vis, 0, sizeof(vis)); dfs(rt, x); memcpy(first, vis, sizeof(vis)); for (int i = 1; i &lt;= n; i++) &#123; if (first[i]) &#123; int res = 0; memset(vis, 0, sizeof(vis)); dfs(i, x); for (int j = 1; j &lt;= n &amp;&amp; res &lt; k; j++) if (!vis[j]) &#123; deep = 0; dfs(j, n); res += (deep + 2 * x) / (2 * x + 1); &#125; if (res &lt; k) return 1; &#125; &#125; return 0;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); deg[x]++; deg[y]++; add(x, y); add(y, x); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt; 2) &#123; rt=i; break; &#125; &#125; if (!rt) &#123; printf("%d", (n + k - 1) / k / 2); return 0; &#125; int l = 1, r = n - 1, ans = n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; printf("%d", ans);&#125; [评价] 之所以标题称这次模拟为“戏剧性的模拟测试”，是因为这道题一开始不会，用了个随机数骗了个 10 分（逃）。 虽然这种骗分方法不值得提倡，但也是没有办法的办法，毕竟信奥有时就是这么玄。 对于这种二分答案的题要记住题目所满足的条件：单调性，一般遇到最大值求最小，最小值求最大的这种坑题可以考虑二分答案的方法了。 T3 まんふは函数[吐槽] 为什么这道题一上来就吐槽呢？首先，这道题的思维难度比较大，其次，这道题的思维难度比较小（WTF!!??）。 首先来看一下题目中日语的发音： 重新排列之后： 经过 Google 的提醒： 这不就是 Huffman 的意思吗……明摆着让我们用霍夫曼树…… （当然，从题中所给的公式也可以看出来，比如考试的时候我就看出来了（逃）。） [题目描述] 有n个正整数 $A[1], A[2]…A[n]$，满足 ${A[i]}\geqslant{A[i+1]}$。它们可以产生$n$个正整数 $B[1], B[2]…B[n]$，其中 $B[i]=\sum_{j=i}^n A[j]$ まんふは函数（マンフハ函数）$f:(Z,Z) \rightarrow Z$定义为： $$f(i,j)=\begin{cases}0, &amp; \text{($i$,$j$) = (1,1)}\\\min\lbrace f(i-1,j+1), f(i,\lceil\frac{j}{2}\rceil)+B[i]\rbrace, &amp; i,j \in [1,n], \text{ } i,j \neq{(1,1)}\\10^{11037}, &amp; \text{otherwise}\end{cases}$$ 试求$f(n,1)$。 [输入格式] 输入包含多组数据，不超过10组。 每组数据的第一行是一个正整数，第二行n个正整数A[i]。 [输出格式] 对于每组数据，输出一个整数表示f(n,1)。 [样例输入] 3 1 1 1 5 28 26 25 24 1 10 996 901 413 331 259 241 226 209 139 49 [样例输出] 5 233 11037 [样例解释] 对于第一组数据： f(1, 1) = 0 f(1, 2) = f(1, 1) + 3 = 3 f(1, 3) = f(1, 2) + 3 = 6 f(2, 1) = min(f(2, 1) + 2, f(1, 2)) = 3 f(2, 2) = min(f(2, 1) + 2, f(1, 3)) = 5 f(2, 3) = f(2, 2) + 2 = 7 f(3, 1) = min(f(3, 1) + 1, f(2, 2)) = 5 [数据范围与约定] 对于30%的数据，满足1 ≤ n ≤ 20。 对于60% 的数据，满足1 ≤ n ≤ 1000。 对于 100% 的数据，满足1 ≤ n ≤ 100000，1 ≤ A[i] ≤ 10000。 [题解] 对于会日语的同学，直接看吐槽就行了，如果不会日语呢？先仔细读题，研究题中所给的表达式，有两个边界条件，这是不是很像状态转移方程？那么我们就可以从动态规划的角度来解决题目的意思。$B$ 数组其实是 $A$ 的一个后缀和，而 $min$ 中的两个 $f(i,j)$, 一个减一，一个除以二，自然而然地联想到这是树的合并，记 $f(i,j)$ 为合并了 $i$ 个点，产生 $j$ 棵树的状态，那么我们要么合并到树中，要么合并两棵子树，为了使合并的总量最小，我们就可以用霍夫曼树来解了，题目的思路就开朗了。 [参考代码] 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define int64 long longint64 node[maxn], u[maxn];int64 tot, n, len, ans;int64 x, y;int64 top() &#123; if (x &lt;= n &amp;&amp; (y &gt; len || node[x] &lt; u[y])) return node[x++]; else return u[y++];&#125;int main() &#123; while (~scanf("%d",&amp;n)) &#123; ans = 0; len = 0; x = 1; y = 1; tot = 0; memset(node, 0, sizeof(node)); memset(u, 0, sizeof(u)); tot = n; for (int i = 1; i &lt;= n; ++i) &#123; int tmp; scanf("%d",&amp;tmp); node[tot--] = tmp; &#125; for (int i = 1; i &lt; n; ++i) &#123; u[len + 1] = top() + top(); ans += u[++len]; &#125; printf("%lld\n",ans); &#125; return 0;&#125;// 提醒注意多组数据读入问题// ++i 和 i++ 的区别要清楚 [评价] 好题，由类状态转移方程推出题目的原意，再进行解答，思维难度比较大，好题。 总结今天三道题，除了第三道题，另外两道题都不是很考验思维，只要还是技巧。看来我还是需要提升自己的知识水平，防止再出现第二题做不出，只能随机数的情况。]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP 模拟</tag>
        <tag>题解</tag>
        <tag>神题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world!]]></title>
    <url>%2F2018%2F08%2F05%2FHello-world%2F</url>
    <content type="text"><![CDATA[重新弄了一个 Github 账号，因为高中决定搞信息竞赛了，所以以后会在这个新的博客里不定期地更新一些有关信息竞赛的内容，当然也可能会更新其他的内容。 目录TO BE CONTINUED……]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
