<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[C++ å¥‡æŠ€æ·«å·§] å­—ç¬¦ä¸²ç±»çš„ä½¿ç”¨æ€»ç»“]]></title>
    <url>%2F2018%2F12%2F27%2FC-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[å­—ç¬¦ä¸²ç±»æ˜¯ä¸ªå¥½ä¸œè¥¿ï¼Œä¸è®ºæ˜¯åœ¨ OI ç«žèµ›ä¸­è¿˜æ˜¯åœ¨å®žé™…çš„åº”ç”¨å½“ä¸­ï¼ŒC++ ä¸­çš„å­—ç¬¦ä¸²éƒ½æä¾›äº†å®Œå¤‡çš„å‡½æ•°ã€‚è™½ç„¶åœ¨å®žçŽ°ä¸Šå¯èƒ½å¹¶ä¸å¦‚åˆ«çš„è¯­è¨€çš„å­—ç¬¦ä¸²çš„å®žçŽ°ï¼Œä½†æ˜¯å®ƒä»ç„¶æ˜¯ä¸ªå¥½ä¸œè¥¿ã€‚ å­—ç¬¦ä¸²ç±»ç®€ä»‹ç›´æŽ¥çœ‹è¿™é‡Œå§ï¼Œè¯´å¾—å¾ˆæ¸…æ¥šã€‚C++ çš„ string ç±»åž‹æœ‰å¾ˆå¤šï¼Œéƒ½æ˜¯ä¸ºäº†ä¸åŒçš„ç›®çš„è®¾è®¡çš„ï¼Œè¿™ç¯‡æ–‡ç« å°†ä¼šè¯¦ç»†ä»‹ç» std::string çš„ç”¨æ³•ï¼Œå…¶å®ƒçš„å°†ä¼šä¸€ç¬”å¸¦è¿‡ã€‚ std::string ç±»è¿ç®—ç¬¦é‡è½½ + å’Œ +=ï¼šè¿žæŽ¥å­—ç¬¦ä¸² =ï¼šå­—ç¬¦ä¸²èµ‹å€¼ &gt;ã€&gt;=ã€&lt; å’Œ &lt;=ï¼šå­—ç¬¦ä¸²æ¯”è¾ƒï¼ˆä¾‹å¦‚a &lt; b, aa &lt; abï¼‰ ==ã€!=ï¼šæ¯”è¾ƒå­—ç¬¦ä¸² &lt;&lt;ã€&gt;&gt;ï¼šè¾“å‡ºã€è¾“å…¥å­—ç¬¦ä¸² æ³¨æ„ï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²å¸¸é‡å¿…é¡»å…ˆå£°æ˜Žå†ç›¸åŠ ï¼Œä¸èƒ½åƒä¸‹é¢é‚£æ ·ï¼š 123456789#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; string str = "cat"; cout &lt;&lt; "apple" + "boy" // illegal! return 0;&#125;// å› ä¸º "apple" å’Œ "boy" é»˜è®¤ä¸º const char* ç±»åž‹ï¼Œæ²¡æœ‰é‡è½½ + è¿ç®—ç¬¦ æŸ¥æ‰¾æ–¹æ³•1234567891011121314151617181920212223242526272829// è¿”å›žå­—ç¬¦ä¸² ab åœ¨ str çš„ä½ç½®str.find("ab");// åœ¨ str[2]~str[n-1] èŒƒå›´å†…æŸ¥æ‰¾å¹¶è¿”å›žå­—ç¬¦ä¸² ab åœ¨ str çš„ä½ç½®str.find("ab", 2);// åœ¨ str[0]~str[2] èŒƒå›´å†…æŸ¥æ‰¾å¹¶è¿”å›žå­—ç¬¦ä¸² ab åœ¨ str çš„ä½ç½®str.rfind("ab", 2);// first ç³»åˆ—å‡½æ•°// è¿”å›ž apple ä¸­ä»»ä½•ä¸€ä¸ªå­—ç¬¦é¦–æ¬¡åœ¨ str ä¸­å‡ºçŽ°çš„ä½ç½®str.find_first_of("apple");// è¿”å›ž apple ä¸­ä»»ä½•ä¸€ä¸ªå­—ç¬¦é¦–æ¬¡åœ¨ str[2]~str[n-1] èŒƒå›´ä¸­å‡ºçŽ°çš„ä½ç½®str.find_first_of("apple", 2);// è¿”å›žé™¤ apple ä»¥å¤–çš„ä»»ä½•ä¸€ä¸ªå­—ç¬¦åœ¨ str ä¸­é¦–æ¬¡å‡ºçŽ°çš„ä½ç½®str.find_first_not_of("apple");// è¿”å›žé™¤ apple ä»¥å¤–çš„ä»»ä½•ä¸€ä¸ªå­—ç¬¦åœ¨ str[2]~str[n-1] èŒƒå›´ä¸­é¦–æ¬¡å‡ºçŽ°çš„ä½ç½®str.find_first_not_of("apple", 2);// last ç³»åˆ—å‡½æ•°// è¿”å›ž apple ä¸­ä»»ä½•ä¸€ä¸ªå­—ç¬¦æœ€åŽä¸€æ¬¡åœ¨ str ä¸­å‡ºçŽ°çš„ä½ç½®str.find_last_of("apple");// è¿”å›ž apple ä¸­ä»»ä½•ä¸€ä¸ªå­—ç¬¦æœ€åŽä¸€æ¬¡åœ¨ str[0]~str[2] èŒƒå›´ä¸­å‡ºçŽ°çš„ä½ç½®str.find_last_of("apple", 2);// è¿”å›žé™¤ apple ä»¥å¤–çš„ä»»ä½•ä¸€ä¸ªå­—ç¬¦åœ¨ str ä¸­æœ€åŽä¸€æ¬¡å‡ºçŽ°çš„ä½ç½®str.find_last_not_of("apple");// è¿”å›žé™¤ apple ä»¥å¤–çš„ä»»ä½•ä¸€ä¸ªå­—ç¬¦åœ¨ str[0]~str[2] èŒƒå›´ä¸­æœ€åŽä¸€æ¬¡å‡ºçŽ°çš„ä½ç½®str.find_last_not_of("apple", 2);// ä»¥ä¸Šå‡½æ•°å¦‚æžœæ²¡æœ‰æ‰¾åˆ°ï¼Œå‡è¿”å›žstring::nposcout &lt;&lt; string::npos; å­ä¸²1234// è¿”å›ž [3] åŠä»¥åŽçš„å­ä¸²str.substr(3);// è¿”å›ž str[2]~str[2+(4-1)] å­ä¸²(å³ä»Ž[2]å¼€å§‹4ä¸ªå­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²)str.substr(2, 4); æ›¿æ¢1234// è¿”å›žæŠŠ [2]~[2+(4-1)] çš„å†…å®¹æ›¿æ¢ä¸º "sz" åŽçš„æ–°å­—ç¬¦ä¸²str.replace(2, 4, "sz");// è¿”å›žæŠŠ [2]~[2+(4-1)] çš„å†…å®¹æ›¿æ¢ä¸º "abcd" çš„å‰3ä¸ªå­—ç¬¦åŽçš„æ–°å­—ç¬¦ä¸²str.replace(2, 4, "abcd", 3); æ’å…¥123456// ä»Ž [2] ä½ç½®å¼€å§‹æ·»åŠ å­—ç¬¦ä¸² "sz"ï¼Œå¹¶è¿”å›žå½¢æˆçš„æ–°å­—ç¬¦ä¸²str.insert(2, "sz");// ä»Ž [2] ä½ç½®å¼€å§‹æ·»åŠ å­—ç¬¦ä¸² "abcd" çš„å‰ 3 ä¸ªå­—ç¬¦ï¼Œå¹¶è¿”å›žå½¢æˆçš„æ–°å­—ç¬¦ä¸²str.insert(2, "abcd", 3);// ä»Ž [2] ä½ç½®å¼€å§‹æ·»åŠ å­—ç¬¦ä¸² "abcd" çš„å‰ [2]~[2+(3-1)] ä¸ªå­—ç¬¦ï¼Œå¹¶è¿”å›žå½¢æˆçš„æ–°å­—ç¬¦ä¸²str.insert(2, "abcd", 1, 3); è¿½åŠ é™¤äº†ç”¨é‡è½½çš„ + æ“ä½œç¬¦ï¼Œè¿˜å¯ä»¥ä½¿ç”¨å‡½æ•°æ¥å®Œæˆã€‚12str.push_back('a'); // åœ¨ str æœ«å°¾æ·»åŠ å­—ç¬¦ 'a'str.append("abc"); // åœ¨ str æœ«å°¾æ·»åŠ å­—ç¬¦ä¸² "abc" åˆ é™¤12str.erase(3); // åˆ é™¤ [3] åŠä»¥åŽçš„å­—ç¬¦ï¼Œå¹¶è¿”å›žæ–°å­—ç¬¦ä¸²str.erase(3, 5); // åˆ é™¤ä»Ž [3] å¼€å§‹çš„ 5 ä¸ªå­—ç¬¦ï¼Œå¹¶è¿”å›žæ–°å­—ç¬¦ä¸² äº¤æ¢1str1.swap(str2); // æŠŠ str1 ä¸Ž str2 äº¤æ¢ å…¶å®ƒçš„ basic_string&lt;&gt; ç±» ç±»åž‹ å®šä¹‰ std::wstring std::basic_string&lt;wchar_t&gt; std::u8string std::basic_string&lt;char8_t&gt; std::u16string std::basic_string&lt;char16_t&gt; std::u32string std::basic_string&lt;char32_t&gt; ä¸»è¦è¿˜æ˜¯è¯´ä¸€ä¸‹ std::wstring å§ï¼Œå…¶å®žå°±æ˜¯å®½å­—ç¬¦çš„ string ï¼ŒWindows å’Œ Linux ä¸Šå¹¶ä¸ç›¸åŒï¼š åœ¨ Windows å¹³å°ä¸‹ sizeof(wchar_t) ä¸º 2ï¼Œè€Œåœ¨ Linux å¹³å°ä¸‹ sizeof(wchar_t) ä¸º 4ï¼› åœ¨ Windows å¹³å°ä¸‹å®½å­—ç¬¦(æˆ–å­—ç¬¦ä¸²)å­—é¢é‡ä½¿ç”¨ UTF-16 ç¼–ç ï¼ŒLinuxå¹³å°ä¸‹ä½¿ç”¨ UTF-32 ç¼–ç ã€‚]]></content>
      <categories>
        <category>å¥‡æŠ€æ·«å·§</category>
      </categories>
      <tags>
        <tag>C++ å¥‡æŠ€æ·«å·§</tag>
        <tag>è¿­ä»£å™¨</tag>
        <tag>iostream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SSR] ShadowsocksR é…ç½®åŠä½¿ç”¨]]></title>
    <url>%2F2018%2F11%2F26%2FSSR-ShadowsocksR-%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[æœ‰åŒå­¦é—®æˆ‘å¦‚ä½•ä½¿ç”¨ ShadowsocksR æ¥åŠ å¯†ä»¥ä¿è¯è‡ªå·±çš„ç½‘ç»œå®‰å…¨ï¼Œè¿™ä¸ªå£å¤´è®²èµ·æ¥çœŸçš„æ˜¯æŒºçƒ¦çš„ï¼Œæ‰€ä»¥è¿™é‡Œå°±å†™ä¸€ç¯‡æ•™ç¨‹ã€‚æœ¬ç¯‡è¯´æ˜Žä»…ä¾›äº¤æµä¸Žå­¦ä¹ ä½¿ç”¨ï¼Œè¯·å‹¿ä½œå‡ºä»»ä½•è¿åå›½å®¶æ³•å¾‹çš„è¡Œä¸ºï¼ ä½•ä¸º ShadowsocksRæƒ³è¦çŸ¥é“ ShadowsocksR ä¸ºä½•ç‰©ï¼Œé¦–å…ˆè¦çŸ¥é“ Shadowsocks æ˜¯ä»€ä¹ˆã€‚å®ƒæ˜¯æ—¢å¯ä»¥æŒ‡ä¸€ç§åŸºäºŽ Socks5 ä»£ç†æ–¹å¼çš„åŠ å¯†ä¼ è¾“åè®®ï¼Œä¹Ÿå¯ä»¥æŒ‡å®žçŽ°è¿™ä¸ªåè®®çš„å„ç§å¼€å‘åŒ…ã€‚ç›®å‰åŒ…ä½¿ç”¨ Pythonã€Cã€C++ã€C#ã€Go ç­‰ç¼–ç¨‹è¯­è¨€å¼€å‘ï¼Œå¤§éƒ¨åˆ†ä¸»è¦å®žçŽ°ï¼ˆiOS å¹³å°çš„é™¤å¤–ï¼‰é‡‡ç”¨ Apache è®¸å¯è¯ã€GPLã€MIT è®¸å¯è¯ç­‰å¤šç§è‡ªç”±è½¯ä»¶è®¸å¯åè®®å¼€æ”¾æºä»£ç ã€‚Shadowsocks åˆ†ä¸ºæœåŠ¡å™¨ç«¯å’Œå®¢æˆ·ç«¯ï¼Œåœ¨ä½¿ç”¨ä¹‹å‰ï¼Œéœ€è¦å…ˆå°†æœåŠ¡å™¨ç«¯éƒ¨ç½²åˆ°æœåŠ¡å™¨ä¸Šé¢ï¼Œç„¶åŽé€šè¿‡å®¢æˆ·ç«¯è¿žæŽ¥å¹¶åˆ›å»ºæœ¬åœ°ä»£ç†ã€‚ShadowsocksR æ˜¯ breakwa11 å‘èµ·çš„ Shadowsocks åˆ†æ”¯ï¼Œåœ¨ Shadowsocks çš„åŸºç¡€ä¸Šå¢žåŠ äº†ä¸€äº›æ•°æ®æ··æ·†æ–¹å¼ï¼Œç§°ä¿®å¤äº†éƒ¨åˆ†å®‰å…¨é—®é¢˜å¹¶å¯ä»¥æé«˜ QoS ä¼˜å…ˆçº§ã€‚åŽæ¥è´¡çŒ®è€… Librehat ä¹Ÿä¸º Shadowsocks è¡¥ä¸Šäº†ä¸€äº›æ­¤ç±»ç‰¹æ€§ï¼Œç”šè‡³å¢žåŠ äº†ç±»ä¼¼ Tor çš„å¯æ’æ‹”ä¼ è¾“å±‚åŠŸèƒ½ã€‚ å®‰è£… ShadowsocksRå®¢æˆ·ç«¯ä¸‹è½½ Windows macOS Linux Android iOS é…ç½®æœåŠ¡ç«¯ ShadowsocksR é¦–å…ˆä½ è¦æœ‰ä¸€ä¸ª VPSï¼ŒæŽ¨èä½¿ç”¨ Vultr è¿™ä¸ª VPS æœåŠ¡å•† ä½¿ç”¨ ssh ç™»é™†åˆ° root ç”¨æˆ·åŽè¿è¡Œä¸€ä¸‹å‘½ä»¤ï¼ˆè¿™æ˜¯ä¸€ä½å¤§ä½¬çš„ä¸€é”®é…ç½®æ–‡ä»¶ï¼Œä»–çš„ç½‘ç«™ï¼‰ï¼š 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log æŽ¥ä¸‹æ¥è®¾ç½®å¯†ç ç«¯å£ï¼ŒåŠ å¯†æ–¹å¼ï¼Œåè®®ï¼Œæ··æ·†ï¼ˆobfsï¼‰å°±å¯ä»¥äº†ã€‚ å®‰è£…å®ŒæˆåŽï¼Œä¼šæœ‰è„šæœ¬æç¤ºå¦‚ä¸‹ï¼š 12345678910Congratulations, ShadowsocksR server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Protocol :your_protocolYour obfs :your_obfsYour Encryption Method:your_encryption_methodWelcome to visit:https://shadowsocks.be/9.htmlEnjoy it! å°†ä½ çš„é…ç½®ä¿¡æ¯è¾“å…¥åˆ°å®¢æˆ·ç«¯ä¸­å°±å¯ä»¥ä½¿ç”¨äº† ç®¡ç†ä½ çš„ ShadowsocksRå¸è½½1./shadowsocksR.sh uninstall æŸ¥çœ‹çŠ¶æ€1/etc/init.d/shadowsocks status å¯åŠ¨1/etc/init.d/shadowsocks start åœæ­¢1/etc/init.d/shadowsocks stop é‡å¯1/etc/init.d/shadowsocks restart æ–‡ä»¶ç›®å½• é…ç½®æ–‡ä»¶è·¯å¾„ï¼š/etc/shadowsocks.json æ—¥å¿—æ–‡ä»¶è·¯å¾„ï¼š/var/log/shadowsocks.log ä»£ç å®‰è£…ç›®å½•ï¼š/usr/local/shadowsocks é…ç½®å¤šç”¨æˆ·ç¤ºä¾‹ï¼š 123456789101112131415161718192021&#123; "server":"0.0.0.0", "server_ipv6": "[::]", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "8989":"password1", "8990":"password2", "8991":"password3" &#125;, "timeout":300, "method":"aes-256-cfb", "protocol": "origin", "protocol_param": "", "obfs": "plain", "obfs_param": "", "redirect": "", "dns_ipv6": false, "fast_open": false, "workers": 1&#125; å…¶ä¸­æŠŠ &quot;server&quot; æ›¿æ¢æˆè‡ªå·±çš„åœ°å€å°±å¯ä»¥äº†ï¼Œ&quot;port_password&quot; è‡ªå·±è®¾ç½®ï¼Œå…¶å®ƒçš„è§†è‡ªå·±æƒ…å†µæ›´æ”¹ã€‚ä¿®æ”¹é…ç½®æ–‡ä»¶å‚è€ƒï¼š https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/Server-Setup https://github.com/shadowsocksr-backup/shadowsocks-rss/blob/master/ssr.md https://github.com/shadowsocksr-backup/shadowsocks-rss/wiki/config.json (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>Crypto</category>
      </categories>
      <tags>
        <tag>ShadowsocksR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[æµ…æµ…æµ…è°ˆ] æ¨¡æ‹Ÿé€€ç«]]></title>
    <url>%2F2018%2F11%2F10%2F%E6%B5%85%E6%B5%85%E6%B5%85%E8%B0%88-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%2F</url>
    <content type="text"><![CDATA[å—¯ï¼ŒDay1 å…ˆ GG äº†ï¼Œå‰ä¸¤é¢˜æš´åŠ›ï¼Œæœ€åŽä¸€é¢˜éª—åˆ†æµæ°“æ‰“æ³•ï¼Œæ˜Žå¤©è‚¯å®šæ›´åŠ æ¶å¿ƒï¼Œä»Šå¤©å…ˆæ¥æ€»ç»“ä¸€ä¸ªçŽ„å­¦ç®—æ³•â€”â€”æ¨¡æ‹Ÿé€€ç« æ¨¡æ‹Ÿé€€ç«ç®€ä»‹ä¸å¤šè¯´ï¼Œå°±ä¸€ä¸ªçƒ­åŠ›å­¦å…¬å¼ï¼š $$\operatorname{P}(dE) = \exp(\frac{dE}{kT})$$ å…¶ä¸­ $k$ æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œ$\exp$ è¡¨ç¤ºè‡ªç„¶æŒ‡æ•°ï¼Œä¸” $dE&lt;0$ã€‚è¿™æ¡å…¬å¼è¯´ç™½äº†å°±æ˜¯ï¼šæ¸©åº¦è¶Šé«˜ï¼Œå‡ºçŽ°ä¸€æ¬¡èƒ½é‡å·®ä¸º $dE$ çš„é™æ¸©çš„æ¦‚çŽ‡å°±è¶Šå¤§ï¼›æ¸©åº¦è¶Šä½Žï¼Œåˆ™å‡ºçŽ°é™æ¸©çš„æ¦‚çŽ‡å°±è¶Šå°ã€‚åˆç”±äºŽ $dE$ æ€»æ˜¯å°äºŽ $0$ï¼ˆå¦åˆ™å°±ä¸å«é€€ç«äº†ï¼‰ï¼Œå› æ­¤ $\frac{dE}{kT} &lt; 0$ ï¼Œæ‰€ä»¥ $\operatorname{P}(dE)$ çš„å‡½æ•°å–å€¼èŒƒå›´æ˜¯ $(0,1)$ ã€‚éšç€æ¸©åº¦ $T$ çš„é™ä½Žï¼Œ$\operatorname{P}(dE)$ä¼šé€æ¸é™ä½Žã€‚æˆ‘ä»¬å°†ä¸€æ¬¡å‘è¾ƒå·®è§£çš„ç§»åŠ¨çœ‹åšä¸€æ¬¡æ¸©åº¦è·³å˜è¿‡ç¨‹ï¼Œæˆ‘ä»¬ä»¥æ¦‚çŽ‡ $\operatorname{P}(dE)$ æ¥æŽ¥å—è¿™æ ·çš„ç§»åŠ¨ã€‚ æ‰€ä»¥æ¨¡æ‹Ÿé€€ç«ä¸­å¯¹ç­”æ¡ˆçš„æ›´æ–°å°±æ˜¯ï¼š å¦‚æžœæ–°è§£æ›´ä¼˜ï¼ŒæŽ¥å— å¦åˆ™ä»¥ä¸€å®šæ¦‚çŽ‡æŽ¥å— é‚£ä¹ˆï¼Œ é€€ç«å‘¢ï¼Ÿï¼Ÿ å°±æ˜¯è¿™ä¸ªå¸¸æ•° $k$ äº†ï¼Œå®ƒæ˜¯ä»‹äºŽ $(0, 1)$ é—´çš„ä¸€ä¸ªå¸¸æ•°ï¼Œç”¨æ¥æŽ§åˆ¶æ¸©åº¦çš„å˜åŒ–ï¼Œå½“æ¸©åº¦å°äºŽä¸€ä¸ªæžå°å€¼ $\epsilon$ æ—¶æˆ‘ä»¬å°±å¯ä»¥åœæ­¢é€€ç«äº†ã€‚ åšé¢˜æ´›è°·P1337 [JSOI2004] å¹³è¡¡ç‚¹ / åŠæ‰“XXXè¿™é“é¢˜æ˜¯å¯ä»¥ç”¨æ­£äº¤åˆ†è§£çš„ï¼Œä½†æ˜¯ä¸ºäº†å­¦ä¹ æ¨¡æ‹Ÿé€€ç«ï¼Œå°±æŠŠå®ƒå½“ä½œä¸€é“æ¨¡æ¿é¢˜å§ï¼Œå…·ä½“å®žçŽ°å°±æ˜¯å’Œä¸Šé¢æ‰€è¯´çš„ä¸€æ ·ï¼Œå°±æ˜¯è¦æ³¨æ„è°ƒå‚ä»¥åŠ SA çš„æ¬¡æ•°ï¼ˆä¸€æ¬¡å¯èƒ½æ‰¾ä¸åˆ°æ­£ç¡®ç­”æ¡ˆï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10010struct instance &#123; double x, y, w; &#125;;instance dat[N]; int n;double potentialEnergy(double x, double y) &#123; double sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; double deltaX = x - dat[i].x; double deltaY = y - dat[i].y; sum += (sqrt(deltaX * deltaX + deltaY * deltaY)) * dat[i].w; &#125; return sum;&#125;const double delta = 0.817;double x, y, ans = 1e18 + 7, t;inline void simulateAnneal() &#123; double xx = x, yy = y; t = 1926; while (t &gt; 1e-14) &#123; double xtmp = x + (rand() * 2 - RAND_MAX) * t; double ytmp = y + (rand() * 2 - RAND_MAX) * t; double newAns = potentialEnergy(xtmp, ytmp); double dE = newAns - ans; if (dE &lt; 0) &#123; xx = xtmp; yy = ytmp; x = xx; y = yy; ans = newAns; &#125; else if (exp(-dE / t) * RAND_MAX &gt; rand()) &#123; xx = xtmp; yy = ytmp; &#125; t *= delta; &#125;&#125;inline void solve() &#123; for (int i = 1; i &lt;= rand() % 300; ++i) simulateAnneal();&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n; srand((unsigned)time(NULL)); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; dat[i].x &gt;&gt; dat[i].y &gt;&gt; dat[i].w; solve(); cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl; return 0;&#125; æ€»ç»“æ¨¡æ‹Ÿé€€ç«å…¶å®žæ˜¯çœŸçš„çŽ„å­¦ï¼Œå¤§å®¶å¯ä»¥æŠŠå®ƒå½“ä½œæ­£ç¡®çŽ‡æ¯”è¾ƒé«˜çš„çŒ´å­ç®—æ³•ï¼Œæœ‰æ—¶å€™å¯èƒ½ä¼šä¸å¦‚ä¸€èˆ¬çš„ random_shufle åŠ ä¸€ä¸ªå¡æ—¶ã€‚è¿™é‡Œé¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œæ¨¡æ‹Ÿé€€ç«åªæ˜¯ä¸€ä¸ª OI ç•Œæ¯”è¾ƒæœ‰åçš„éšæœºç®—æ³•ï¼Œéšæœºç®—æ³•è¿˜æœ‰å¾ˆå¤šï¼Œæ¯”å¦‚é—ä¼ ç®—æ³•ä¹‹ç±»çš„ï¼Œè¿™äº›ä¸œè¥¿ä¹ŸçœŸçš„æ˜¯çŽ„å­¦å¾—ä¸€æ¯”ï¼Œå¦‚æžœä¸æ˜¯åƒæˆ‘è¿™æ ·é—²çš„è›‹ç–¼å°±åˆ«åŽ»å­¦ä¹ äº†ðŸ˜‚ðŸ˜‚ (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>çŽ„å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[æ¨¡æ¿] æ¿å­æ±‡æ€»]]></title>
    <url>%2F2018%2F10%2F31%2F%E6%A8%A1%E6%9D%BF-%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[æ±‡æ€»ä¸€äº›æ¯”èµ›ä¸­å¸¸ç”¨çš„æ¨¡æ¿ï¼Œæƒå½“å¤ä¹ åŠå‚è€ƒç”¨ã€‚ å¿«è¯»å¿«è¾“1234567891011121314151617181920212223inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; // è¿™ä¸¤ä¸ªå±€éƒ¨å˜é‡åƒä¸‡åˆ«å¼€ static è¿˜ä¸é‡æ–°èµ‹å€¼ï¼Œå¦åˆ™ä¼š GG while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x == 0) &#123; putchar('0'); return; &#125; static int stk[100], top = 0; // è¿™ä¸ªå¼€ static é—®é¢˜ä¸å¤§ if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125; Dijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x7f7f7f7f#define N 500010struct edgeNode &#123; int vertexTo; int weight; int edgeNext;&#125; edges[N &lt;&lt; 1];int heads[N], numEdges, n, m, x, y, z, s, e;inline void initGraph() &#123; memset(heads, -1, sizeof(heads)); numEdges = 0;&#125;inline void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].weight = weight; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;struct heapNode &#123; int u, d; bool operator&lt;(const heapNode&amp; b) const &#123; return b.d &lt; d; &#125;&#125;;priority_queue&lt;heapNode&gt; Q;int dist[N];inline void Dijkstra(int x) &#123; while (!Q.empty()) Q.pop(); for (int i = 1; i &lt;= n; ++i) dist[i] = INF; dist[x] = 0; Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int d = f.d; if (d != dist[u]) continue; for (int i = heads[u]; i != -1; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; int w = edges[i].weight; if (dist[y] &gt; dist[u] + w) &#123; dist[y] = dist[u] + w; Q.push((heapNode)&#123; y, dist[y] &#125;); &#125; &#125; &#125;&#125; int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; initGraph(); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; addEdge(x, y, z); &#125; Dijkstra(s); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; dist[i] &lt;&lt; " "; return 0;&#125; å€å¢ž LCA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// lca.cpp// get the lca(Lowest Common Ancestor)#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500010#define M 500010inline void read(int &amp;x) &#123; x = 0; char ch = 0; bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125;struct edgeNode &#123; int vertexTo; int edgeNext;&#125; edges[M &lt;&lt; 1];int heads[N], numEdges = 0;int n, m, s, x, y, a, b, t;int dep[N], f[N][20];queue&lt;int&gt; Q;void BFS() &#123; memset(dep, 0, sizeof(dep)); Q.push(s); dep[s] = 1; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = heads[x]; i != -1; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; if (dep[y]) continue; dep[y] = dep[x] + 1; f[y][0] = x; for (int j = 1; j &lt;= t; ++j) f[y][j] = f[f[y][j - 1]][j - 1]; Q.push(y); &#125; &#125;&#125;int LCA(int x, int y) &#123; if (dep[x] &gt; dep[y]) swap(x, y); // let dep[x] &lt; dep[y] for (int i = t; i &gt;= 0; --i) if (dep[f[y][i]] &gt;= dep[x]) y = f[y][i]; if (x == y) return x; for (int i = t; i &gt;= 0; --i) if (f[x][i] != f[y][i]) &#123; x = f[x][i]; y = f[y][i]; &#125; return f[x][0];&#125;inline void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;inline void addDuplexEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1);&#125;int main() &#123; read(n); read(m); read(s); memset(heads, -1, sizeof(heads)); for (int i = 1; i &lt;= n - 1; ++i) &#123; read(x); read(y); addDuplexEdge(x, y); &#125; // initialize the tree t = (int)(log(n) / log(2)) + 1; BFS(); // prepare the LCA while (m--) &#123; read(a); read(b); write(LCA(a, b)); puts(""); &#125; return 0;&#125; Tarjan ç¼©ç‚¹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1010// ä¼¼ä¹Žå¼€å¤§äº†ä¼š Segmentation Fault (core dumped)struct edgeNode &#123; int vertexTo; int edgeNext; &#125;;struct graph &#123; edgeNode edges[N]; int heads[N], numEdges; int stk[N], top; bool instk[N]; int dfn[N], low[N], clr[N], num, cnt; vector&lt;int&gt; scc[N]; inline void init() &#123; numEdges = 0; top = 0; num = 0; cnt = 0; memset(heads, -1, sizeof(heads)); memset(stk, 0, sizeof(stk)); memset(instk, false, sizeof(instk)); memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); memset(clr, 0, sizeof(clr)); &#125; inline void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges; &#125; inline void addUndirectedEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1); &#125; inline void Tarjan(int x) &#123; dfn[x] = low[x] = ++num; stk[++top] = x; instk[x] = true; for (int i = heads[x]; i != -1; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; if (!dfn[y]) &#123; Tarjan(y); low[x] = min(low[x], low[y]); &#125; else if (instk[y]) &#123; low[x] = min(low[x], dfn[y]); &#125; &#125; if (dfn[x] == low[x]) &#123; cnt++; int y; do &#123; y = stk[top--]; instk[y] = false; clr[y] = cnt; scc[cnt].push_back(y); &#125; while (x != y); &#125; &#125;&#125;;int n, m, u, v;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; graph g0, g1; g0.init(); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; g0.addEdge(u, v); &#125; for (int i = 1; i &lt;= n; ++i) if (!g0.dfn[i]) g0.Tarjan(i); g1.init(); for (int x = 1; x &lt;= n; ++x) &#123; for (int i = g0.heads[x]; i != -1; i = g0.edges[i].edgeNext) &#123; int y = g0.edges[i].vertexTo; if (g0.clr[x] == g0.clr[y]) continue; g1.addEdge(g0.clr[x], g0.clr[y]); &#125; &#125; cout &lt;&lt; g1.numEdges; return 0;&#125; çº¿æ®µæ ‘åŒºé—´æœ€å¤§å€¼ï¼ˆå•ç‚¹ä¿®æ”¹ï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// the segment tree to get thr max number in a array;#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10010 // leave node numberstruct segmentTree &#123; int l, r, dat; &#125;;segmentTree t[N * 4];int n, m, a[N], opt, x, y;inline void build(int p, int l, int r) &#123; t[p].l = l; t[p].r = r; if (l == r) &#123; t[p].dat = a[l]; return; &#125; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat); // store thr max number&#125;inline void change(int p, int x, int v) &#123; if (t[p].l == t[p].r) &#123; t[p].dat = v; return; &#125; int mid = (t[p].l + t[p].r) / 2; if (x &lt;= mid) change(p * 2, x, v); else change(p * 2 + 1, x, v); t[p].dat = max(t[p * 2].dat, t[p * 2 + 1].dat);&#125;inline int query(int p, int l, int r) &#123; if (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].dat; int mid = (t[p].l + t[p].r) / 2; int val = -(1 &lt;&lt; 30); if (l &lt;= mid) val = max(val, query(p * 2, l, r)); if (r &gt; mid) val = max(val, query(p * 2 + 1, l, r)); return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; switch(opt) &#123; case 1: &#123; change(1, x, y); break; &#125; case 2: &#123; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; åŒºé—´å’Œï¼ˆå•ç‚¹ä¿®æ”¹ï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010struct segmentTreeNode &#123; int l, r, dat; &#125;;segmentTreeNode t[maxn * 4];int a[maxn], n, m, opt, x, y;inline void build(int p, int l, int r) &#123; t[p].l = l; t[p].r = r; if (l == r) &#123; t[p].dat = a[l]; return; &#125; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); t[p].dat = t[p * 2].dat + t[p * 2 + 1].dat;&#125;inline void change(int p, int x, int v) &#123; if (t[p].l == t[p].r) &#123; t[p].dat = v; return; &#125; int mid = (t[p].l + t[p].r) / 2; if (x &lt;= mid) change(p * 2, x, v); else change(p * 2 + 1, x, v); t[p].dat = t[p * 2].dat + t[p * 2 + 1].dat;&#125;inline int query(int p, int l, int r) &#123; if (l &lt;= t[p].l &amp;&amp; r &gt;= t[p].r) return t[p].dat; int mid = (t[p].l + t[p].r) / 2; int val = 0; if (l &lt;= mid) val += query(p * 2, l, r); if (r &gt; mid) val += query(p * 2 + 1, l, r); return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; switch (opt) &#123; case 1: &#123; change(1, x, y); break; &#125; case 2: &#123; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; åŒºé—´å’Œï¼ˆåŒºé—´ä¿®æ”¹ï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// segmentTree2.cpp// modify in a interval// 1 x y k: add `k` to all the value in [x, y]// 2 x y: ask the sum in [x, y]#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 500010typedef long long int64;struct segmentTreeNode &#123; int l, r; int64 sum, add; &#125;;segmentTreeNode t[maxn * 4];int a[maxn], n, m, op, x, y, k;#define l(x) t[x].l#define r(x) t[x].r#define sum(x) t[x].sum#define add(x) t[x].add inline void build(int p, int l, int r) &#123; l(p) = l; r(p) = r; add(p) = 0; if (l == r) &#123; sum(p) = a[l]; return; &#125; int mid = (l + r) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); &#125;inline void spread(int p) &#123; if (add(p)) &#123; sum(p * 2) += add(p) * (r(p * 2) - l(p * 2) + 1); sum(p * 2 + 1) += add(p) * (r(p * 2 + 1) - l(p * 2 + 1) + 1); add(p * 2) += add(p); add(p * 2 + 1) += add(p); add(p) = 0; &#125;&#125;inline void change(int p, int l, int r, int d) &#123; if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) &#123; sum(p) += (int64)d * (r(p) - l(p) + 1); add(p) += d; return; &#125; spread(p); int mid = (l(p) + r(p)) / 2; if (l &lt;= mid) change(p * 2, l, r, d); if (r &gt; mid) change(p * 2 + 1, l, r, d); sum(p) = sum(p * 2) + sum(p * 2 + 1);&#125;inline int64 ask(int p, int l, int r) &#123; if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) return sum(p); spread(p); int mid = (l(p) + r(p)) / 2; int64 val = 0; if (l &lt;= mid) val += ask(p * 2, l, r); if (r &gt; mid) val += ask(p * 2 + 1, l, r); return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; cin &gt;&gt; op; switch (op) &#123; case 1: &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; k; change(1, x, y, k); break; &#125; case 2: &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; ask(1, x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; zkw å•ç‚¹ä¿®æ”¹12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 500010int tree[maxn * 4], a[maxn], M, N, opM, op, x, y;inline void maintain(int p) &#123; tree[p] = tree[p &lt;&lt; 1] + tree[p &lt;&lt; 1 | 1];&#125;inline void build() &#123; for (M = 1; M &lt; N; M &lt;&lt;= 1); for (int i = M + 1; i &lt;= M + N; ++i) tree[i] = a[i - M]; for (int i = M - 1; i; --i) maintain(i);&#125;inline void update(int p, int v) &#123; p += M; tree[p] = v; for (p &gt;&gt;= 1; p; p &gt;&gt;= 1) maintain(p);&#125;inline int query(int l, int r) &#123; int val = 0; for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) val += tree[l ^ 1]; if (r &amp; 1) val += tree[r ^ 1]; &#125; return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; N &gt;&gt; opM; for (int i = 1; i &lt;= N; ++i) cin &gt;&gt; a[i]; build(); while (opM--) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; switch (op) &#123; case 1: &#123; update(x, a[x] += y); break; &#125; // add y to a[x] case 2: &#123; cout &lt;&lt; query(x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; zkw åŒºé—´ä¿®æ”¹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 500010typedef long long int64;struct segmentTreeNode &#123; int l, r; int64 tag, sum; &#125;;segmentTreeNode tree[maxn * 4];int a[maxn], N, M;int opM, op, x, y, v;#define lson(x) (x &lt;&lt; 1)#define rson(x) (x &lt;&lt; 1 | 1)#define l(x) tree[x].l#define r(x) tree[x].r#define sum(x) tree[x].sum#define tag(x) tree[x].taginline void pushDown(int p) &#123; if (tag(p) &amp;&amp; p &lt; M) &#123; tag(lson(p)) += tag(p); tag(rson(p)) += tag(p); sum(lson(p)) += (r(lson(p)) - l(lson(p)) + 1) * tag(p); sum(rson(p)) += (r(rson(p)) - l(rson(p)) + 1) * tag(p); tag(p) = 0; &#125;&#125;inline void maintain(int p) &#123; sum(p) = sum(lson(p)) + sum(rson(p)); &#125;inline void build() &#123; for (M = 1; M &lt; N; M &lt;&lt;= 1); for (int i = M + 1; i &lt;= M + N; ++i) &#123; sum(i) = a[i - M]; l(i) = r(i) = i - M; &#125; for (int i = M - 1; i; --i) &#123; maintain(i); l(i) = l(lson(i)); r(i) = r(rson(i)); // question &#125;&#125;inline void applyTag(int p) &#123; static int stk[maxn * 4], top = 0; while (p) &#123; stk[++top] = p; p &gt;&gt;= 1; &#125; while (top) pushDown(stk[top--]);&#125;inline void update(int l, int r, int v) &#123; bool vl, vr; vl = vr = false; int p, sl, sr; for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) &#123; p = l ^ 1; if (!vl) &#123; sl = p; applyTag(p); vl = true; &#125; tag(p) += v; sum(p) += (r(p) - l(p) + 1) * v; &#125; if (r &amp; 1) &#123; p = r ^ 1; if (!vr) &#123; sr = p; applyTag(p); vr = true; &#125; tag(p) += v; sum(p) += (r(p) - l(p) + 1) * v; &#125; &#125; for (sl &gt;&gt;= 1; sl; sl &gt;&gt;= 1) maintain(sl); for (sr &gt;&gt;= 1; sr; sr &gt;&gt;= 1) maintain(sr);&#125;inline int64 query(int l, int r) &#123; bool vl, vr; vl = vr = false; int64 val = 0; for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; if (~l &amp; 1) &#123; if (!vl) applyTag(l ^ 1); val += sum(l ^ 1); &#125; if (r &amp; 1) &#123; if (!vr) applyTag(r ^ 1); val += sum(r ^ 1); &#125; &#125; return val;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; N &gt;&gt; opM; for (int i = 1; i &lt;= N; ++i) cin &gt;&gt; a[i]; build(); while (opM--) &#123; cin &gt;&gt; op; switch (op) &#123; case 1: &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; update(x, y, v); break; &#125; case 2: &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; æ ‘çŠ¶æ•°ç»„å•ç‚¹ä¿®æ”¹123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;#define lowbit(x) (x &amp; -x)#define maxn 500010int n, m, c[maxn], a[maxn], op, x, y;int ask(int x) &#123; int ans = 0; for (; x; x -= lowbit(x)) ans += c[x]; return ans;&#125;int ask(int l, int r) &#123; return ask(r) - ask(l - 1);&#125;void add(int x, int y) &#123; for (; x &lt;= n; x += lowbit(x)) c[x] += y;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) add(i, a[i]); while (m--) &#123; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y; switch (op) &#123; case 1: &#123; add(x, y); break; &#125; case 2: &#123; cout &lt;&lt; ask(x, y) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; åŒºé—´ä¿®æ”¹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 500010#define lowbit(x) (x &amp; -x)inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int a[maxn], b[maxn], n, m, op, x, y, k;inline int ask(int x) &#123; int ans = 0; for (; x; x -= lowbit(x)) ans += b[x]; return ans;&#125;inline void add(int x, int y) &#123; for (; x &lt;= n; x += lowbit(x)) b[x] += y;&#125;int main() &#123; read(n); read(m); memset(b, 0, sizeof(b)); for (int i = 1; i &lt;= n; ++i) read(a[i]); while (m--) &#123; read(op); switch(op) &#123; case 1: &#123; read(x), read(y); read(k); add(x, k); add(y + 1, -k); break; &#125; case 2: &#123; read(x); write(a[x] + ask(x)); puts(""); break; &#125; &#125; &#125; return 0;&#125; æ ‘çŠ¶æ•°ç»„æ±‚é€†åºå¯¹1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define lowbit(x) (x &amp; -x)int a[maxn], n;int c[maxn], num = 0;inline void add(int x, int y) &#123; for (; x &lt;= n; x += lowbit(x)) c[x] += y;&#125;inline int ask(int x) &#123; int ans = 0; for (; x; x -= lowbit(x)) ans += c[x]; return ans;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = n; i; --i) &#123; num += ask(a[i] - 1); add(a[i], 1); &#125; cout &lt;&lt; num; return 0;&#125; Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define INF 0x7fffffffstruct treapNode &#123; int lChild, rChild; // å·¦å³å­èŠ‚ç‚¹ä¸‹æ ‡ int value, weight; // èŠ‚ç‚¹å…³é”®ç åŠæƒå€¼ int count, size; // å‰¯æœ¬æ•°åŠå­æ ‘å¤§å°&#125; treap[maxn];int numNodes, root, n;int newNode(int val) &#123; numNodes++; treap[numNodes].value = val; treap[numNodes].weight = rand(); // éšæœºæƒå€¼ treap[numNodes].count = treap[numNodes].size = 1; return numNodes;&#125; // å»ºç«‹ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹void update(int p) &#123; treap[p].size = treap[treap[p].lChild].size + treap[treap[p].rChild].size + treap[p].count;&#125; // æ›´æ–°æŸä¸€ä¸ªç‚¹çš„ size æ–¹ä¾¿èŽ·å–æŽ’åvoid build() &#123; newNode(-INF); // ä¿è¯ BST æ€§è´¨çš„ä¸¤ä¸ªç‚¹ newNode(INF); root = 1; treap[root].rChild = 2; update(root);&#125; // åˆå§‹åŒ–int getRankByVal(int p, int val) &#123; if (p == 0) return 0; if (val == treap[p].value) return treap[treap[p].lChild].size + 1; if (val &lt; treap[p].value) return getRankByVal(treap[p].lChild, val); return getRankByVal(treap[p].rChild, val) + treap[treap[p].lChild].size + treap[p].count;&#125;// ä¸Šä¸‹ä¸¤ä¸ªå‡½æ•°å¾ˆå¥½ç†è§£ï¼Œä¸ä½œèµ˜è¿°// ä¸€åˆ‡ä»Ž BST æ€§è´¨å‡ºå‘int getValByRank(int p, int rnk) &#123; if (p == 0) return INF; if (treap[treap[p].lChild].size &gt;= rnk) return getValByRank(treap[p].lChild, rnk); if (treap[treap[p].lChild].size + treap[p].count &gt;= rnk) return treap[p].value; return getValByRank(treap[p].rChild, rnk - treap[treap[p].lChild].size - treap[p].count);&#125;void zig(int &amp;p) &#123; int q = treap[p].lChild; treap[p].lChild = treap[q].rChild; treap[q].rChild = p; p = q; update(treap[p].rChild); update(p); // åˆ«å¿˜è®°æ›´æ–°&#125;void zag(int &amp;p) &#123; int q = treap[p].rChild; treap[p].rChild = treap[q].lChild; treap[q].lChild = p; p = q; update(treap[p].lChild); update(p);&#125;void insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == treap[p].value) &#123; treap[p].count++; update(p); return; &#125; if (val &lt; treap[p].value) &#123; insert(treap[p].lChild, val); if (treap[p].weight &lt; treap[treap[p].lChild].weight) zig(p); &#125; else &#123; insert(treap[p].rChild, val); if (treap[p].weight &lt; treap[treap[p].rChild].weight) zag(p); &#125; // zig å’Œ zag æ“ä½œï¼Œä¿è¯æ»¡è¶³å¤§æ ¹å †æ€§è´¨ update(p);&#125; // æ’å…¥ä¸€ä¸ªç‚¹int getPre(int val) &#123; int ans = 1; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].lChild &gt; 0) &#123; p = treap[p].lChild; // å·¦å­æ ‘ä¸Šä¸æ–­å‘å³èµ°ï¼ŒèŽ·å–æœ€å¤§çš„å‰é©± while (treap[p].rChild &gt; 0) p = treap[p].rChild; ans = p; &#125; break; &#125; if (treap[p].value &lt; val &amp;&amp; treap[p].value &gt; treap[ans].value) ans = p; // å°è¯•æ›´æ–°ç­”æ¡ˆ p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125; // èŽ·å–å‰é©±int getNext(int val) &#123; int ans = 2; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].rChild &gt; 0) &#123; p = treap[p].rChild; // å³å­æ ‘ä¸Šä¸æ–­å‘å·¦èµ°ï¼ŒèŽ·å–æœ€å°çš„åŽç»§ while (treap[p].lChild &gt; 0) p = treap[p].lChild; ans = p; &#125; break; &#125; if (treap[p].value &gt; val &amp;&amp; treap[p].value &lt; treap[ans].value) ans = p; // å°è¯•æ›´æ–°ç­”æ¡ˆ p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125;void remove(int &amp;p, int val) &#123; if (p == 0) return; if (val == treap[p].value) &#123; if (treap[p].count &gt; 1) &#123; treap[p].count--; update(p); &#125; else if (treap[p].lChild != 0 || treap[p].rChild != 0) &#123; if (treap[p].rChild == 0 || treap[treap[p].lChild].weight &gt; treap[treap[p].rChild].weight) &#123; zig(p); remove(treap[p].rChild, val); &#125; else &#123; zag(p); remove(treap[p].lChild, val); &#125; // é€šè¿‡æ—‹è½¬æ¥åˆ é™¤èŠ‚ç‚¹ update(p); &#125; else p = 0; return; &#125; if (val &lt; treap[p].value) remove(treap[p].lChild, val); else remove(treap[p].rChild, val); update(p);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); numNodes = 0; build(); cin &gt;&gt; n; int opt, x; while (n--) &#123; cin &gt;&gt; opt &gt;&gt; x; switch (opt) &#123; case 1: &#123; insert(root, x); break; &#125; case 2: &#123; remove(root, x); break; &#125; case 3: &#123; cout &lt;&lt; getRankByVal(root, x) - 1 &lt;&lt; endl; break; &#125; // å‡ä¸€ case 4: &#123; cout &lt;&lt; getValByRank(root, x + 1) &lt;&lt; endl; break; &#125; // åŠ ä¸€ case 5: &#123; cout &lt;&lt; getPre(x) &lt;&lt; endl; break; &#125; case 6: &#123; cout &lt;&lt; getNext(x) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; å°è£…æˆç±»çš„ Treap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;template &lt;typename T&gt;struct treapNode &#123; T value; size_t lChild, rChild, count, size; int weight; treapNode(T val) : value(val), lChild(0), rChild(0), count(1), size(1) &#123; weight = rand(); &#125;&#125;;template &lt;typename T&gt;class treap &#123; public: treap(size_t N, T maximum, T minimum) : numNodes_(0), maximum_(maximum), minimum_(minimum) &#123; dat_ = (treapNode&lt;T&gt;*)malloc(N * sizeof(treapNode&lt;T&gt;)); &#125; ~treap() &#123; delete[] dat_; &#125; inline size_t root() &#123; return root_; &#125; inline size_t newNode(T val); inline void update(size_t p); inline void build(); size_t rankByVal(size_t p, T val); T valByRank(size_t p, size_t rnk); inline T pre(T val); inline T nxt(T val); inline void zig(size_t &amp;p); inline void zag(size_t &amp;p); void remove(size_t &amp;p, T val); void insert(size_t &amp;p, T val); inline size_t rankByVal(T val) &#123; return rankByVal(root_, val); &#125; inline T valByRank(size_t rnk) &#123; return valByRank(root_, rnk); &#125; inline void remove(T val) &#123; remove(root_, val); &#125; inline void insert(T val) &#123; insert(root_, val); &#125; private: treapNode&lt;T&gt; *dat_; size_t root_, numNodes_; T maximum_, minimum_;&#125;;template &lt;typename T&gt;inline size_t treap&lt;T&gt;::newNode(T val) &#123; numNodes_++; dat_[numNodes_] = treapNode&lt;T&gt;(val); return numNodes_;&#125;template &lt;typename T&gt;inline void treap&lt;T&gt;::update(size_t p) &#123; dat_[p].size = dat_[dat_[p].lChild].size + dat_[dat_[p].rChild].size + dat_[p].count;&#125;template &lt;typename T&gt;inline void treap&lt;T&gt;::build() &#123; root_ = newNode(minimum_); // root_ = 1 dat_[root_].rChild = newNode(maximum_); // dat_[2].value = maximum_ update(root_);&#125;template &lt;typename T&gt;size_t treap&lt;T&gt;::rankByVal(size_t p, T val) &#123; if (p == 0) return 0; if (dat_[p].value == val) return dat_[dat_[p].lChild].size + 1; if (val &lt; dat_[p].value) return rankByVal(dat_[p].lChild, val); return rankByVal(dat_[p].rChild, val) + dat_[dat_[p].lChild].size + dat_[p].count;&#125;template &lt;typename T&gt;T treap&lt;T&gt;::valByRank(size_t p, size_t rnk) &#123; if (p == 0) return maximum_; if (dat_[dat_[p].lChild].size &gt;= rnk) return valByRank(dat_[p].lChild, rnk); if (dat_[dat_[p].lChild].size + dat_[p].count &gt;= rnk) return dat_[p].value; return valByRank( dat_[p].rChild, rnk - dat_[dat_[p].lChild].size - dat_[p].count);&#125;template &lt;typename T&gt;inline T treap&lt;T&gt;::pre(T val) &#123; size_t ans = 1; size_t p = root_; while (p != 0) &#123; if (val == dat_[p].value) &#123; if (dat_[p].lChild &gt; 0) &#123; p = dat_[p].lChild; while (dat_[p].rChild &gt; 0) p = dat_[p].rChild; ans = p; &#125; break; &#125; if (dat_[p].value &lt; val &amp;&amp; dat_[p].value &gt; dat_[ans].value) ans = p; p = val &lt; dat_[p].value ? dat_[p].lChild : dat_[p].rChild; &#125; return dat_[ans].value;&#125;template &lt;typename T&gt;inline T treap&lt;T&gt;::nxt(T val) &#123; size_t ans = 2; size_t p = root_; while (p != 0) &#123; if (val == dat_[p].value) &#123; if (dat_[p].rChild &gt; 0) &#123; p = dat_[p].rChild; while (dat_[p].lChild &gt; 0) p = dat_[p].lChild; ans = p; &#125; break; &#125; if (dat_[p].value &gt; val &amp;&amp; dat_[p].value &lt; dat_[ans].value) ans = p; p = val &lt; dat_[p].value ? dat_[p].lChild : dat_[p].rChild; &#125; return dat_[ans].value;&#125;template &lt;typename T&gt;inline void treap&lt;T&gt;::zig(size_t &amp;p) &#123; int q = dat_[p].lChild; dat_[p].lChild = dat_[q].rChild; dat_[q].rChild = p; p = q; update(dat_[p].rChild); update(p);&#125;template &lt;typename T&gt;inline void treap&lt;T&gt;::zag(size_t &amp;p) &#123; int q = dat_[p].rChild; dat_[p].rChild = dat_[q].lChild; dat_[q].lChild = p; p = q; update(dat_[p].lChild); update(p);&#125;template &lt;typename T&gt;void treap&lt;T&gt;::insert(size_t &amp;p, T val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == dat_[p].value) &#123; dat_[p].count++; update(p); return; &#125; if (val &lt; dat_[p].value) &#123; insert(dat_[p].lChild, val); if (dat_[p].weight &lt; dat_[dat_[p].lChild].weight) zig(p); &#125; else &#123; insert(dat_[p].rChild, val); if (dat_[p].weight &lt; dat_[dat_[p].rChild].weight) zag(p); &#125; update(p);&#125;template &lt;typename T&gt;void treap&lt;T&gt;::remove(size_t &amp;p, T val) &#123; if (p == 0) return; if (val == dat_[p].value) &#123; if (dat_[p].count &gt; 1) &#123; dat_[p].count--; update(p); &#125; else if (dat_[p].lChild != 0 || dat_[p].rChild != 0) &#123; if (dat_[p].rChild == 0 || dat_[dat_[p].lChild].weight &gt; dat_[dat_[p].rChild].weight) &#123; zig(p); remove(dat_[p].rChild, val); &#125; else &#123; zag(p); remove(dat_[p].lChild, val); &#125; update(p); &#125; else p = 0; &#125; if (val &lt; dat_[p].value) remove(dat_[p].lChild, val); else remove(dat_[p].rChild, val); update(p);&#125;const int INF = 0x7f7f7f7f;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); size_t n; cin &gt;&gt; n; treap&lt;int&gt; t(n &lt;&lt; 1, INF, -INF); t.build(); int opt, x; while (n--) &#123; cin &gt;&gt; opt &gt;&gt; x; switch (opt) &#123; case 1: &#123; t.insert(x); break; &#125; case 2: &#123; t.remove(x); break; &#125; case 3: &#123; cout &lt;&lt; t.rankByVal(x) - 1 &lt;&lt; endl; break; &#125; case 4: &#123; cout &lt;&lt; t.valByRank(x + 1) &lt;&lt; endl; break; &#125; case 5: &#123; cout &lt;&lt; t.pre(x) &lt;&lt; endl; break; &#125; case 6: &#123; cout &lt;&lt; t.nxt(x) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; Manacher ç®—æ³•1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public: string longestPalindrome(string s) &#123; int len = s.size(); if (len &lt;= 1) return s; string str = preProcess(s); int n = str.size(), pos = 0, MaxRight = 0; vector&lt;int&gt; RL(n, 0); for (int i = 1; i &lt; n - 1; ++i) &#123; RL[i] = MaxRight &gt; i ? min(RL[2 * pos - i], MaxRight - i) : 1; while (str[i + RL[i]] == str[i - RL[i]]) ++RL[i]; if (i + RL[i] &gt; MaxRight) &#123; MaxRight = i + RL[i]; pos = i; &#125; &#125; int maxLen = 0, index = 0; for(int i = 1; i &lt; n - 1; ++i) &#123; if(RL[i] &gt; maxLen) &#123; maxLen = RL[i]; index = i; &#125; &#125; // è¿™é‡Œå¯ä»¥å’Œä¸Šé¢å¹¶åœ¨ä¸€èµ· return s.substr((index - maxLen) / 2, maxLen - 1); &#125; //é¢„å¤„ç†å­—ç¬¦ä¸²ï¼Œabcé¢„å¤„ç†åŽå˜æˆ$#a#b#c#^ string preProcess(const string &amp;s) &#123; int n = s.size(); string res; res.push_back('$'); res.push_back('#'); for(int i = 0; i &lt; n; i++) &#123; res.push_back(s[i]); res.push_back('#'); &#125; res.push_back('^'); return res; &#125; // æ³¨ï¼šæ­¤å¤„å­—ç¬¦ä¸²é¢„å¤„ç†åœ¨å¤´ä¸ŠåŠ å…¥ '$' æ˜¯ä¸ºäº†æ–¹ä¾¿å¤„ç† // å¦‚æžœæ˜¯ç©ºé—´ç˜¤æ‚£è€…ï¼Œç›´æŽ¥åœ¨æœ‰å…³çš„åœ°æ–¹å‡ä¸€å°±è¡Œäº†&#125;; çº¿æ€§ç­›123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int fac[N], prime[N];void linearSieve(int n) &#123; memset(fac, 0, sizeof(fac)); int m = 0; for (int i = 2; i &lt;= n; ++i) &#123; if (fac[i] == 0) &#123; fac[i] = i; prime[++m] = i; &#125; for (int j = 1; j &lt;= m; ++j) &#123; if (prime[j] &gt; fac[i] || prime[j] &gt; n / i) break; fac[i * prime[j]] = prime[j]; &#125; &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; prime[i] &lt;&lt; " ";&#125;int main() &#123; int n; linearSieve(100000); return 0;&#125; ç­›æ³•æ±‚æ¬§æ‹‰å‡½æ•°123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010bool isPrime[N];int phi[N], prime[N], cnt;inline void phiSieve(int n) &#123; cnt = 0; memset(isPrime, true, sizeof(isPrime)); phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (isPrime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt; ++j) &#123; if (i * prime[j] &gt; n) break; isPrime[i * prime[j]] = false; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = prime[j] * phi[i]; break; &#125; else phi[i * prime[j]] = (prime[j] - 1) * phi[i]; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; phiSieve(n); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; phi[i] &lt;&lt; " "; return 0;&#125; ç­›æ³•æ±‚èŽ«æ¯”ä¹Œæ–¯å‡½æ•°123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010bool isPrime[N];int mu[N], prime[N], cnt;inline void muSieve(int n) &#123; cnt = 0; memset(isPrime, true, sizeof(isPrime)); mu[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (isPrime[i]) &#123; prime[++cnt] = i; mu[i] = -1; &#125; for (int j = 1; j &lt;= cnt; ++j) &#123; if (i * prime[j] &gt; n) break; isPrime[i * prime[j]] = false; if (i % prime[j] == 0) &#123; mu[i * prime[j]] = 0; break; &#125; else mu[i * prime[j]] = -mu[i]; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; muSieve(n); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; mu[i] &lt;&lt; " "; return 0;&#125; Miller-Rabin ç´ æ•°æµ‹è¯•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;inline int64 rand64() &#123; return abs((int64)rand() &lt;&lt; 32 | rand()); &#125;inline int64 random(int64 x, int64 y) &#123; return x + rand64() % (y - x + 1); &#125;// éšæœºæ•°ç”Ÿæˆå‡½æ•°int64 montgomery(int64 a, int64 b, int64 c) &#123; int64 result = 1; int64 temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;bool witness(int64 a, int64 p) &#123; int k = 0; int64 q = p - 1; while ((q &amp; 1) == 0) &#123; k++; q &gt;&gt;=1; &#125; int64 v = montgomery(a, q, p); // åˆ¤æ–­ä¸€ if (v == 1 || v == p - 1) return false; while (k--) &#123; v = v * v % p; if (v == p - 1) return false; // åˆ¤æ–­äºŒ &#125; return true;&#125;bool MillerRabin(int64 p) &#123; if (p == 1) return false; if (p == 2) return true; if (p % 2 == 0) return false; // è¿™é‡Œå…¶å®žå¯ä»¥åŠ æ›´å¤šçš„ç‰¹åˆ¤æ¥èŠ‚çº¦æ—¶é—´ for (int i = 1; i &lt;= 50; ++i) if (witness(random(1, p - 1), p)) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) if (MillerRabin(i)) cout &lt;&lt; i &lt;&lt; " "; // è¾“å‡º 1 ~ n ä¹‹é—´çš„æ‰€æœ‰ç´ æ•° return 0;&#125; è´¨å› æ•°åˆ†è§£12345678910111213int p[maxn], c[maxn];void divide(int n) &#123; int m = 0; for (int i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; p[++m] = i; c[m] = 0; while (n % i == 0) &#123; n /= i; c[m]++; &#125; &#125; &#125; if (n &gt; 1) &#123; p[++m] = n; c[m] = 1 &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; p[i] &lt;&lt; '^' &lt;&lt; c[i] &lt;&lt; endl;&#125; å¿«é€Ÿå¹‚ï¼ˆè’™å“¥é©¬åˆ©ç®—æ³•ï¼‰12345678910int64 Montgomery(int64 a, int64 b, int64 c) &#123; if (b == 0) return 1 % c; int64 res = 1, tmp = a; while (b &gt; 0) &#123; if (b &amp; 1) res = (res * tmp) % c; tmp = (tmp * tmp) % c; b &gt;&gt;= 1; &#125; return res;&#125; gcd &amp; lcm12int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;int lcm(int a, int b) &#123; return a * b / gcd(a, b); &#125; exgcdçº¯ exgcd12345678int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d;&#125; exgcd æ±‚æ–¹ç¨‹ $ax + by = c$ ä¸­ $x$ çš„æœ€å°æ­£æ•´æ•°è§£1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d;&#125;int cal(int a, int b, int c, int &amp;x, int &amp;y) &#123; int k, t; int gcd = exgcd(a, b, x, y); if (c % gcd != 0) return -1; // æ–¹ç¨‹æ²¡æœ‰æ•´æ•°è§£ x = x * c / gcd; // ä»Ž a' * x + b' * y = gcd(a', b') // è½¬åŒ–ä¸º a * x + b * y = c k = b / gcd; // çº¦åŽ» gcd(a', b') if (k &lt; 0) k = -k; // å°† b è½¬åŒ–ä¸ºæ­£æ•° x = (x % k + k) % k; //if (x &lt; 0) x = x + k; // æœ€å°éžè´Ÿæ•´æ•°è§£ if (x &lt;= 0) x = x + k // æœ€å°æ­£æ•´æ•°è§£ y = (c - a * x) / b; // æ±‚å‡º y çš„å€¼ while (y &lt; 0) &#123; x = x + k; y = (c - a * x) / b; &#125; // å¯¹ y æ±‚éžè´Ÿæ•´æ•°è§£ return x;&#125;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int x, y; int tmp = cal(a, b, c, x, y); if (tmp == -1) &#123; puts("-1"); return 0; &#125; cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y; return 0;&#125; é€†å…ƒexgcd æ±‚é€†å…ƒæ•ˆçŽ‡è´¼é«˜ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $\mathcal{O}(\log n)$ 1234567891011121314int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; return a; x = 1; y = 0; return a; &#125; int d = exgcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return d;&#125;int getInverse(int n, int p) &#123; int x, y; exgcd(n, p, x, y); return (x + p) % p;&#125; çº¿æ€§æŽ¨é€†å…ƒæ±‚ $1\sim n$ çš„é€†å…ƒï¼Œæ€»æ—¶é—´å¤æ‚åº¦ä¸º $\mathcal{O}(n)$ 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;int64 inv[N];inline void getInverse(int64 n, int64 p) &#123; inv[1] = 1; for (int i = 2; i &lt;= n; ++i) inv[i] = (p - p / i) * inv[p % i] % p; &#125; ç»„åˆæ•°æ¨è¾‰ä¸‰è§’é€’æŽ¨æ±‚å…¨éƒ¨ç»„åˆæ•°1234567891011121314151617181920#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long int64;int64 C[1000][1000];int64 c(int n, int m) &#123; m = min(m, n - m); for (int i = 0; i &lt;= n; ++i) C[i][0] = 1; // å…¨èµ‹ä¸º 1 for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) C[i][j] = C[i - 1][j] + C[i - 1][j - 1]; return C[n][m];&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; c(n, m); return 0;&#125; æ±‚ä¸€ä¸ªç»„åˆæ•°ï¼ˆæ»šåŠ¨æ•°ç»„ï¼‰12345678910111213141516171819#include &lt;bits/stdc++.h&gt; using namespace std;typedef long long int64;int64 C[100010];int64 c(int n, int m) &#123; m = min(m, n - m); C[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 1; --j) C[j] = C[j] + C[j - 1]; return C[m];&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; c(n, m); return 0;&#125; ä¹˜æ³•é€†å…ƒç›´æŽ¥æ±‚123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;int64 exgcd(int64 a, int64 b, int64 &amp;x, int64 &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int64 d = exgcd(b, a % b, x, y); int64 t = x; x = y; y = t - a / b * y; return d;&#125;int64 getInverse(int64 n, int64 p) &#123; int64 x, y; exgcd(n, p, x, y); return (x + p) % p;&#125;int64 c(int64 n, int64 m, int64 p) &#123; int64 x = 1, y = 1; for (int64 i = n; i &gt;= n - m + 1; --i) x *= i; for (int64 i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; int64 n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; å¢å¡æ–¯å®šç†1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;int64 exgcd(int64 a, int64 b, int64 &amp;x, int64 &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; int64 d = exgcd(b, a % b, x, y); int64 t = x; x = y; y = t - a / b * y; return d;&#125;int64 getInverse(int64 n, int64 p) &#123; int64 x, y; exgcd(n, p, x, y); return (x + p) % p;&#125;int64 c(int64 n, int64 m, int64 p) &#123; if (m == 0) return 1 % p; if (n == 0) return 0; if (n &gt;= p || m &gt;= p) return c(n / p, m / p, p) * c(n % p, m % p, p) % p; int64 x = 1, y = 1; for (int64 i = n; i &gt;= n - m + 1; --i) x = x * i % p; for (int64 i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; int64 n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; å¯¹æ‹ç¨‹åº123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; for (int T = 1; T &lt;= 10; ++T) &#123; system("random.exe"); // æ•°æ®ç”Ÿæˆç¨‹åº double st = clock(); system("sol.exe"); // è§£é¢˜çš„ç¨‹åº double ed = clock(); system("bf.exe"); // æš´åŠ›ç¨‹åº if (system("diff data.out data.ans")) &#123; // diff ä¸èƒ½ç”¨å°±ç”¨ fc printf("[ Wrong Answer ]"); &#125; else &#123; printf("[ Accepted ] Testcase #%d: Time %.0lfms\n", T, ed - st); &#125; &#125; return 0;&#125; (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>æ¨¡æ¿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[æµ…æµ…æµ…è°ˆ] æ•°ä½ DP]]></title>
    <url>%2F2018%2F10%2F30%2F%E6%B5%85%E6%B5%85%E6%B5%85%E8%B0%88-%E6%95%B0%E4%BD%8D-DP%2F</url>
    <content type="text"><![CDATA[â€œå‡ºé¢˜äººæ˜¯æ­»çš„ã€‚â€æ€»æœ‰äº›å‡ºé¢˜äººä¼šé—²çš„è›‹ç–¼æ¥å‡ºä¸€äº›åƒä¸‹é¢è¿™æ ·çš„é¢˜ç›®ï¼šæ±‚åŒºé—´ $[l,r]$ ä¹‹é—´æ»¡è¶³è§„åˆ™ $g$ çš„æ•°æœ‰å¤šå°‘ä¸ªã€‚ ä¸€èˆ¬è§£æ³•ä»£ç å¦‚ä¸‹ï¼š 1for (int i = l; i &lt;= r; ++i) if (judge(i)) cnt++; å¦‚æžœæ¯ä¸€æ¬¡ judge() çš„å¤æ‚åº¦ä¸º $\mathcal{O}(\operatorname{length}(i))$ï¼Œåˆ™å®ƒçš„å¤æ‚åº¦ä¸º $\mathcal{O}\left(n\times\operatorname{length}(i)\right)$ï¼Œå¦‚æžœå†ç®—ä¸Šä¸€å †å¸¸æ•°ï¼ˆæ¯”å¦‚å¼€ä¸ªæ•°ç»„ä»€ä¹ˆçš„ï¼‰ï¼Œé‚£ TLE ç®€ç›´æ˜¯è½»è½»æ¾æ¾çš„ðŸ¤£ðŸ¤£ã€‚ ç”¨æ•°ä½ DPæˆ‘ä»¬å¯ä»¥ä»Žæ•°å­—çš„æ¯ä¸€ä½æ¥æžšä¸¾ï¼Œä»Žé«˜ä½å‘ä½Žä½æžšä¸¾ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ $\operatorname{dp}[i][j]$ æ¥è¡¨ç¤ºæžšä¸¾åˆ° $i$ ä½æ—¶ï¼Œæ•°å­—ä¸º $j$ æ—¶çš„æ–¹æ¡ˆæ•°ï¼ˆç­”æ¡ˆæ•°ï¼‰ã€‚ä½†æ˜¯æˆ‘ä»¬éœ€è¦è€ƒè™‘ä¸€äº›é™åˆ¶æˆ‘ä»¬å†³ç­–çš„æ¡ä»¶ï¼Œå‡è®¾æˆ‘ä»¬è¦æ±‚å°äºŽç­‰äºŽ $243$ çš„æ•°å­—ä¸­ç¬¦åˆæ¡ä»¶çš„æœ‰å‡ ä¸ªï¼š å½“æˆ‘ä»¬ç¬¬ä¸€é¡¹ä¸º $1$ æ—¶ï¼Œæˆ‘ä»¬åŽé¢ä¸€ä½å¯ä»¥æžšä¸¾ $0\sim 9$ å½“æˆ‘ä»¬ç¬¬ä¸€é¡¹ä¸º $2$ æ—¶ï¼Œæˆ‘ä»¬åŽé¢ä¸€é¡¹å°±åªèƒ½æžšä¸¾ $0\sim 4$ å¯è§æˆ‘ä»¬éœ€è¦é€šè¿‡åˆ¤æ–­å‰ä¸€é¡¹æ¥å†³å®šåŽä¸€é¡¹æœ€é«˜å¯ä»¥å–å€¼çš„å¤§å°ã€‚åŒæ—¶æˆ‘ä»¬ä¹Ÿéœ€è¦è€ƒè™‘ä¸€äº›æ•°å­—å‰é¢ä¸€ç›´æ˜¯ $0$ï¼Œå¹¶ä¸”ä¼šå½±å“ç­”æ¡ˆçš„æƒ…å†µï¼ˆä¾‹å¦‚ç»Ÿè®¡å„ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°ï¼‰ã€‚ä»¥ä¸‹æ˜¯æ¨¡æ¿ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20int dp[N][N], a[N], n, m;// æ•°ä½ dp æ˜¯éœ€è¦æ·±æœçš„ï¼Œ`dp` æ•°ç»„åªæ˜¯åšè®°å¿†åŒ–æœç´¢ç”¨int dfs(int pos, int pre, bool limit, bool frontzero) &#123; // `frontzero`: å‰å¯¼ 0 çš„åˆ¤æ–­ // `pre`: `pos` å‰ä¸€ä½çš„æ•°å­— if (pos == 0) return 1; // æžšä¸¾å®Œæ¯•ï¼Œé€€å‡º if (!frontzero &amp;&amp; !limit &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; // è¿”å›ž `dp[pos][pre]` çš„æ¡ä»¶ï¼šå‰å¯¼éžé›¶ ä¸” æ— ä¸Šé™é™åˆ¶ ä¸” `dp` æ•°ç»„çš„è¿™ä¸€ä½æœ‰å€¼ // æ³¨æ„è¿™é‡Œå¿…é¡»æŠŠ `!frontzero` å’Œ `!limit` å†™åœ¨å‰é¢ æ¥é˜²æ­¢ `dp` æ•°ç»„è¶Šç•Œ // å› ä¸ºåŽé¢éœ€è¦åœ¨å‰å¯¼é›¶çš„æ—¶å€™åšä¸€ç‚¹æ“ä½œ int p, ret = 0; int up = limit ? a[pos] : 9; for (int i = 0; i &lt;= up; ++i) &#123; if () continue; // å½“æžšä¸¾åˆ°çš„è¿™ä¸€ä½ä¸ç¬¦åˆæ¡ä»¶æ—¶å°±å¿½ç•¥ï¼Œç»§ç»­æžšä¸¾ p = i; if (frontzero &amp;&amp; i == 0) p = -INF; // è¿™é‡Œ `-INF` åªæ˜¯ä¸€ä¸ªå‰å¯¼ 0 çš„æ ‡è®°ï¼Œæ•°å€¼å¹¶æ²¡æœ‰å¤ªå¤§æ„ä¹‰ã€‚ ret += dfs(pos - 1, p, limit &amp; (i == up), (p == -INF)); // è¿™é‡Œ `p = -INF` æ—¶ä¹Ÿæ˜¯ä¼šä¼ è¿›å‡½æ•°ä½œä¸º `pre` å‚æ•°çš„ï¼Œ // æ‰€ä»¥å‰é¢è¦æŠŠ `frontzero` å†™å‰é¢ &#125; if (!frontzero &amp;&amp; !limit) f[pos][pre] = ret; return ret;&#125;int solve(int x) &#123; // `solve(x)`: å¤„ç†ä¸å¤§äºŽ `x` çš„æ•°çš„ç­”æ¡ˆ int idx = 0; while (x) &#123; a[++idx] = x % 10; x /= 10; &#125; // é¢„å¤„ç† `x` çš„æ¯ä¸€ä½ memset(dp, -1, sizeof(dp)); return dfs(idx, -INF, 1, 1); // æ³¨æ„åˆå§‹åŒ–&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; (solve(m) - solve(n - 1)); return 0;&#125; ä¾‹é¢˜HDU 2089 ä¸è¦ 62è§£å†³ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20int a[N], dp[N][2];// `dp[pos][0 / 1]` è¡¨ç¤ºä¸å« 4 å’Œ 6 çš„æƒ…å†µä¸‹ï¼Œå‰©ä½™é•¿åº¦ä¸º `pos` (ä¹Ÿå°±æ˜¯å½“å‰çš„ä½æ•°)ï¼Œ// é¦–ä½æ˜¯(1)å¦(0)ä¸º 6 çš„ æ—¶å€™çš„æ–¹æ¡ˆæ•°ã€‚int dfs(int pos, int pre, int status, bool limit) &#123; if (pos == -1) return 1; if (!limit &amp;&amp; dp[pos][status] != -1) return dp[pos][status]; int up = limit ? a[pos] : 9; int ret = 0; for (int i = 0; i &lt;= up; ++i) &#123; if (pre == 6 &amp;&amp; i == 2) continue; if (i == 4) continue; // ä»”ç»†è¯»é¢˜ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªæ¡ä»¶ ret += dfs(pos - 1, i, i == 6, limit &amp; (i == a[pos])); &#125; if (!limit) dp[pos][status] = ret; return ret;&#125;int solve(int x) &#123; int pos = 0; while (x) &#123; a[pos++] = x % 10; x /= 10; &#125; return dfs(pos - 1, -1, 0, true);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr); int l, r; cin &gt;&gt; l &gt;&gt; r; while ((l != 0) || (r != 0)) &#123; memset(dp, -1, sizeof(dp)); int ans = solve(r) - solve(l - 1); cout &lt;&lt; ans &lt;&lt; endl; cin &gt;&gt; l &gt;&gt; r; &#125; return 0;&#125; Windy æ•°â€‹123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define N 20#define INF 0x7f7f7f7fint a[N], dp[N][N], n, m;int dfs(int pos, int pre, bool limit, bool frontzero) &#123; if (pos == 0) return 1; if (!frontzero &amp;&amp; !limit &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; int p, ret = 0; int up = limit ? a[pos] : 9; for (int i = 0; i &lt;= up; ++i) &#123; if (abs(i - pre) &lt; 2) continue; // åˆ¤å®šå½“å‰æžšä¸¾çš„ä½èƒ½å¦æ»¡è¶³é¢˜ç›®ä¸­çš„æ¡ä»¶ p = i; if (frontzero &amp;&amp; i == 0) p = -INF; ret += dfs(pos - 1, p, limit &amp;&amp; (i == up), (p == -INF)); &#125; if (!frontzero &amp;&amp; !limit) dp[pos][pre] = ret; return ret;&#125;int solve(int x) &#123; int len = 0; while (x) &#123; a[++len] = x % 10; x /= 10; &#125; return dfs(len, -INF, 1, 1);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; memset(dp, -1, sizeof(dp)); // åˆå§‹åŒ– cout &lt;&lt; (solve(m) - solve(n - 1)); return 0;&#125; (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>åŠ¨æ€è§„åˆ’</category>
      </categories>
      <tags>
        <tag>åŠ¨æ€è§„åˆ’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[æ‚è°ˆ] è€ƒåŽä½™ç”Ÿ......]]></title>
    <url>%2F2018%2F10%2F13%2F%E6%9D%82%E8%B0%88-%E8%80%83%E5%90%8E%E4%BD%99%E7%94%9F%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©åˆèµ›è€ƒå®Œäº†ï¼Œæˆ‘æ„Ÿè§‰æˆ‘å·²ç»é€€å½¹äº†â€¦â€¦è¿™é‡Œæ¥è¯´ä¸€ä¸‹è¿™å‡ ä¸ªæœˆæ¥é«˜ä¸­ç”Ÿæ´»çš„æ„Ÿå—ã€‚ NOIP åˆèµ›æ„Ÿå—ä¸€äº›é‡ç”·è½»å¥³çš„å®¶åº­ï¼Œç”Ÿå­©å­çš„æ¨¡å¼æ˜¯ï¼Œåªè¦æ˜¯å¥³å­©å°±ä¸€ç›´ç”Ÿï¼Œç”Ÿåˆ°ç”·å­©ä¸ºæ­¢ã€‚ç„¶è€Œè¿™ä¹ˆåšå¹¶ä¸ä¼šè®©äººå£æ€§åˆ«å¤±è¡¡ï¼Œè®©äººå£æ€§åˆ«å¤±è¡¡çš„æ˜¯é€‰æ‹©æ€§çš„æ‰“èƒŽã€‚ ä»¥ä¸Šå†…å®¹å’ŒæŸé“é€‰æ‹©é¢˜ç›¸å…³ã€‚ç­”æ¡ˆæ˜¯ 1:1ã€‚ å…¨å›½é’å°‘å¹´è®¡ç®—æœºç¨‹åºè®¾è®¡å¤§èµ›ç©¶ç«Ÿä½•æ—¶åˆ›åŠžï¼ŸCatalan æ•°åˆ°åº•è¡¨ç¤ºä»€ä¹ˆï¼Ÿæ˜¯ä»€ä¹ˆè®©ä¸€å°åªæœ‰çº¢è“ä¸¤è‰²çƒçš„æŠ½å¥–æœºå¦‚æ­¤ç«çˆ†ï¼Ÿå…³æœºçš„æ‰‹æœºç©¶ç«Ÿèƒ½å¦å¸¦è¿›è€ƒåœºï¼Ÿè´Ÿæƒå›žè·¯ä¸Ž Dijkstra ç®—æ³•æœ‰ä»€ä¹ˆä¸ä¸ºäººçŸ¥çš„å…³ç³»ï¼Ÿå›¾çµå¥–åˆ°åº•æ˜¯å“ªæ–¹è®¾ç«‹ï¼Ÿå››äººéƒŠæ¸¸ä¸ºä½•åªæœ‰ä¸¤äººå¦‚çº¦ï¼Ÿæ˜¯ä»€ä¹ˆè®© ï¼‹ï¼‹cnt é™·å…¥æ— æ„ä¹‰çš„å¾ªçŽ¯ï¼ŸåŒå‘é“¾è¡¨ç©¶ç«Ÿæ˜¯ä½•æ–¹ç¥žåœ£ï¼Ÿå°çŒªåˆä¸ºä½•åœ¨ä¸¤å®¶å•†åº—é—´å› å·¨é¢æ¶ˆè´¹å¾˜å¾Šä¸å®šï¼Ÿæ¬¢è¿Žæ¥åˆ°ç¬¬äºŒåå››å±Š NOIpï¼ ä»¥ä¸Šæ‘˜è‡ªçŸ¥ä¹Ž å¯èƒ½æ˜¯å› ä¸ºæˆ‘æ¯”è¾ƒèœï¼Œè€ƒè¯•çš„æ—¶å€™å¿˜è®°äº†å¾ˆå¤šä¸œè¥¿ï¼Œæ¯”å¦‚åº·æ‰˜å±•å¼€ TATã€‚ä½†æ˜¯æ€»ä½“æ¥è¯´è¿™æ¬¡è¿˜å¥½ï¼Œæ²¡æœ‰å¤ªæ¶å¿ƒçš„é¢˜ï¼Œä¸æ˜¯é¢˜ç›®çš„é—®é¢˜ï¼Œæ˜¯æˆ‘çš„é—®é¢˜ã€‚ä¸ç®¡è¿™æ¬¡èƒ½ä¸èƒ½è¿›å…¥å¤èµ›ï¼Œåˆèµ›éƒ½è®©æˆ‘çŸ¥é“äº†æˆ‘çš„åŸºç¡€çŸ¥è¯†å’Œå¾ˆå¤šçŸ¥è¯†çš„æŽŒæ¡æ˜¯å¾ˆä¸å¥½çš„ï¼Œæˆ‘ä»ç„¶éœ€è¦åŽ»åŠ æ²¹ï¼ŒåŽ»ç»§ç»­åŠªåŠ›ï¼ˆå“ªæ€•ä»¥åŽå¹¶ä¸å†èµ°ä¿¡æ¯å­¦å¥¥èµ›è¿™æ¡é“è·¯ï¼‰ã€‚æœ€åŽç¥å„ä½å¤§ä½¬ score++ã€‚ é«˜ä¸­çš„ç”Ÿæ´»æ„Ÿå— æš‘å‡å…¶å®žå°±å·²ç»æ˜¯æˆ‘çš„é«˜ä¸­çš„å¼€å§‹äº†ï¼Œä¸»è¦æ˜¯å› ä¸ºæš‘æœŸçš„å¤ä»¤è¥ï¼Œå¤ä»¤è¥ç»“æŸåŽä¾¿æ˜¯æˆ‘çš„ç¬¬ä¸€æ¬¡çš„ä¿¡æ¯å¥¥èµ›é›†è®­ç»åŽ†çš„å¼€å§‹ã€‚ä»¥å‰æˆ‘éƒ½æ˜¯è‡ªå·±ä¸€ä¸ªäººåœ¨é‚£è¾¹çžŽå­¦ï¼Œå¶å°”çœ‹ç‚¹ Github ä¸Šçš„ä»£ç æ¥æå‡ä¸€ä¸‹è‡ªå·±çš„â€œä¿®å…»â€ã€‚é›†è®­çš„å¼€å§‹å¤šå°‘æ˜¯æœ‰ç‚¹ä¸é€‚åº”çš„ï¼Œå°±å¦‚åŒåˆšåˆšå¼€å§‹å­¦ä¹ èµ°è·¯çš„å©´å„¿è·Œè·Œæ’žæ’žï¼Œæˆ‘ä¹Ÿå°±æ˜¯è¿™ä¸ªæ„Ÿè§‰ã€‚æœ‰æ—¶åå‡ å¤©è¿žç»­ç€ä¸‹æ¥ä¼šè®©æˆ‘æ„Ÿè§‰éžå¸¸çš„ä¸é€‚åº”ï¼Œä»¥è‡³äºŽæˆ‘ä¼šå˜å¾—é‚£ä¹ˆæ¸´æœ›å‡ºåŽ»èµ°èµ°ã€‚ æš‘å‡å¾ˆå¿«å°±è¿‡åŽ»äº†ï¼Œè¡¥ä½œä¸šçš„æ—¶é—´ä¹Ÿæ˜¯è½¬çž¬å³é€ï¼Œä¸€ä¸‹å­å°±å¼€å­¦äº†ï¼Œå¼€å­¦çš„ç¬¬ä¸€ä¸ªæ˜ŸæœŸï¼Œæ¯å¤©çš„ä½œä¸šéƒ½æ¥å¾—åŠï¼Œé™¤äº†å¯¹æ•°å­¦è€å¸ˆçš„è®²è¯¾æ–¹å¼ä»¥åŠä¸è®²é“ç†çš„ä¸ºäººæ— è¯­å¤–ï¼Œæ²¡æœ‰ä»€ä¹ˆäº‹æƒ…æ˜¯èƒ½å¤Ÿè®©æˆ‘æ„Ÿåˆ°ä¸å¼€å¿ƒçš„ã€‚æˆ‘åˆä¸­æ˜¯å½“è¿‡çºªå¾‹å§”å‘˜çš„ï¼Œæ‰€ä»¥ç­çº§é‡ŒæŸäº›ç­å¹²éƒ¨çš„è¡Œä¸ºæˆ‘å…¶å®žçœ‹ç€ä¸æ˜¯å¾ˆé¡ºçœ¼ï¼Œæˆ‘åŠªåŠ›å…‹åˆ¶è‡ªå·±ä¸è¦å¦„åŠ è¯„è®ºï¼Œè¿™ä¸å…³æˆ‘çš„äº‹ï¼Œæˆ‘ä¹Ÿç¡®å®žåšåˆ°äº†ï¼Œä½†ä¸ºäº†å‘æ³„æˆ‘çš„æƒ…ç»ªï¼Œæˆ‘ä¹Ÿä¸å¾—ä¸æŠŠé‚£äº›æƒ…ç»ªæ³¼æ´’åˆ°æˆ‘çš„æ—¥è®°æœ¬ä¸­ã€‚æœ‰ä¸€å¤©ï¼Œå¦ˆå¦ˆç»™æˆ‘çœ‹äº†åˆä¸­ç­ä¸»ä»»æœ‰å…³â€œåå¯¹å­¦æ ¡è¿‡åº¦è¡Œæ”¿åŒ–â€çš„ä¸€æ¡æœ‹å‹åœˆï¼Œè¯´çš„æŒºå¥½ï¼Œæ°å¥½é‚£å¤©ä¸­åˆåˆæœ‰ä¸€å †äººåŽ»å‚åŠ ä»€ä¹ˆâ€œå­¦ç”Ÿä¼šé¢è¯•â€ï¼Œå›žåˆ°æ•™å®¤çš„äººä¸ªä¸ªè„¸ä¸Šæ´‹æº¢ç€â€œè‡ªè±ªâ€çš„â€œå¾®ç¬‘â€ï¼Œå˜´ä¸Šå´æ˜¯ä¸€é˜µå¹ï¼Œæˆ‘ä¸æ˜¯å¾ˆæ˜Žç™½ä¸ºä»€ä¹ˆä»–ä»¬çŸ¥é“é‚£ä¹ˆè‚¯å®šè‡ªå·±è€Œå¦å®šåˆ«äººã€‚ä¹Ÿè®¸è¿™ç§ä¸œè¥¿æ˜¯æˆ‘è¿™ä¸ªä¸æƒ³å‚ä¸Žå­¦æ ¡æ‰€è°“è¡Œæ”¿äº‹åŠ¡çš„â€œä¸ç§¯æžâ€çš„å­¦ç”Ÿæ‰€ä¸èƒ½ç†è§£çš„å§ã€‚ è™šä¼ªçš„çœŸè¯šæ¯”é­”é¬¼æ›´å¯æ€•ã€‚è€Œæˆ‘åœ¨ç­é‡Œçš„å¾ˆå¤šäººèº«ä¸Šçœ‹åˆ°äº†é­”é¬¼ï¼ŒæŸäº›äººèº«ä¸Šçœ‹åˆ°äº†è™šä¼ªçš„çœŸè¯šï¼Œå°‘æ•°äººèº«ä¸Šçœ‹åˆ°äº†å¤©ä½¿ã€‚æ‰€è°“é­”é¬¼ï¼Œä¾¿æ˜¯ä¸€ç§æ‹œé‡‘ä¸»ä¹‰ï¼Œæœ‰é’±äººå®¶çš„å­¦ç”Ÿå–œæ¬¢è‡ªå·±èšåœ¨ä¸€èµ·åŒæ—¶æ‹‰æ‹¢ä¸€å †äººï¼Œè€ŒæŽ’æ–¥é‚£äº›ä¸Žä»–ä»¬æ‰€ç›¸æ–¥çš„äººï¼Œæˆ‘ä¸å–œæ¬¢è¿™ç§äººï¼Œç”šè‡³åŽŒæ¶ï¼Œå›´ç€ä»–ä»¬çš„äººä¸­ä¸ä¹æœ‰å˜´ä¸Šä¸€ä¼šè¯´ç€â€œæˆ‘ä¸å–œæ¬¢é’±â€ï¼Œä¸€ä¼šæœ‰è¯´ç€â€œä½ ä»¬å®¶æœ‰é’±ï¼ŒçœŸé¦™â€çš„äººï¼Œè™šä¼ªçš„çœŸè¯šæ¯”é­”é¬¼æ›´å¯æ€•ï¼Œè¿™äº›ä¸æ˜¯ä»–ä»¬çš„åŽŸè¯ï¼Œä½†æ˜¯æ¯«æ— ç–‘é—®æ˜¯ä»–ä»¬è¯ä¸­çš„æ„æ€ã€‚å¤©ä½¿ï¼Œä¹Ÿå°±æ˜¯çœŸè¯šï¼Œå¤ªç¨€æœ‰äº†ï¼Œæœ‰äº›çœŸè¯šçš„äººç”šè‡³ä¼šè¢«é”™å½“æˆæ™ºéšœï¼Œæˆ‘ä¸€å¼€å§‹æ€»æ˜¯çœ‹ä½Žä¸€ä½åŒå­¦ï¼Œè®¤ä¸ºä»–ä¸€å¤©åˆ°æ™šéƒ½åœ¨è¯´å­¦ä¹ çš„ä¸œè¥¿ï¼Œç”Ÿæ´»ä¸€ç‚¹è¶£å‘³ä¹Ÿæ²¡æœ‰ï¼ŒçŽ°åœ¨æˆ‘æ˜Žç™½ä»–æ˜¯çœŸæ­£çš„å–œæ¬¢å­¦ä¹ ï¼Œæˆ‘ä¹Ÿæ¯”è¾ƒå–œæ¬¢å’Œè¿™ç§äººå¾…åœ¨ä¸€èµ·ã€‚è€Œä¸æ˜¯å’ŒæŸäº›åœ¨è¯¾ä¸Šå‰Šå°–è„‘è¢‹å¤§è¨€ä¸æƒ­åœ°æ‰¯æ·¡ï¼Œåœ¨ç§ä¸‹åˆçœ‹ä½Žå‘¨å›´çš„æ‰€æœ‰äººï¼Œè®¤ä¸ºè‡ªå·±ä¸å¯ä¸€ä¸–çš„äººï¼Œæ•æˆ‘ç›´è¨€ï¼ŒåŽè€…å°±æ˜¯ä¸€æ ¹å•¥éƒ½æ²¡æœ‰çš„è‘±ã€‚ è¿™å‡ ä¸ªæ˜ŸæœŸè€ƒè¯•å¾ˆå¤šï¼Œæ—¢è¦å‡†å¤‡ NOIP åˆèµ›ï¼Œåˆè¦å¯¹ä»˜å­¦æ ¡æ–‡åŒ–è¯¾çš„è€ƒè¯•ï¼ŒçœŸçš„æ˜¯å¿™ï¼Œåœ¨åŠªåŠ›åè°ƒè¿™ä¸ªå…³ç³»çš„åŒæ—¶ï¼Œæˆ‘å¼€å§‹åŠªåŠ›åœ°å°è¯•æ—©ä¸Šè·‘æ­¥ï¼Œè™½ç„¶è¿™ä¼šè®©æˆ‘æœ‰ç‚¹å‘å›°ï¼Œä½†æ˜¯è¿˜æ˜¯è®©æˆ‘ç²¾ç¥žäº†å¾ˆå¤šï¼Œè¿åŠ¨æ˜¯çœŸçš„èƒ½è®©ä¸€ä¸ªäººçš„é¢è²Œå‘ç”Ÿæ”¹å˜çš„ã€‚ å…ˆå†™è¿™ä¹ˆå¤šå§ï¼Œæœ‰ç©ºä»¥åŽæŽ¥ç€å†™ï¼Œæ€»çš„æ¥è¯´ï¼Œè¿™ä¸€ä¸ªæœˆä¸‹æ¥è¿˜æ˜¯æ¯”è¾ƒé€‚åº”çš„ï¼Œå¯¹æŸäº›ä¸è®²é“ç†çš„è€å¸ˆæˆ‘è§‰å¾—è¿˜æ˜¯èƒ½å¿åˆ™å¿æ¯”è¾ƒå¥½ï¼Œä¸è¦å½“ç€å¥¹ï¼ˆä»–ï¼‰çš„é¢æ¥è®©æ‰€æœ‰çš„äººä½“ä¼šåˆ°å¥¹ï¼ˆä»–ï¼‰çš„æ— çŸ¥ã€‚ (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>æ‚è°ˆ</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸‰æ‰‡é—¨ä½ åˆ°åº•æ¢ä¸æ¢ï¼Ÿâ€”â€”è’™ç‰¹éœå°”é—®é¢˜ï¼]]></title>
    <url>%2F2018%2F10%2F11%2F%E4%B8%89%E6%89%87%E9%97%A8%E4%BD%A0%E5%88%B0%E5%BA%95%E6%8D%A2%E4%B8%8D%E6%8D%A2%EF%BC%9F%E2%80%94%E2%80%94%E8%92%99%E7%89%B9%E9%9C%8D%E5%B0%94%E9%97%AE%E9%A2%98%EF%BC%81%2F</url>
    <content type="text"><![CDATA[ä¸‰é—¨é—®é¢˜ï¼ˆä¹Ÿç§°ä¸ºè’™ç‰¹éœå°”é—®é¢˜ï¼‰ï¼Œæ˜¯ä¸€ä¸ªç»å…¸çš„é—®é¢˜ï¼Œç®€å•æ¦‚æ‹¬ä¸€ä¸‹å°±æ˜¯ä¸‰ä¸ªé—¨é‡Œæœ‰ä¸€ä¸ªçš„åŽé¢ç”±ä½ æƒ³è¦çš„ä¸œè¥¿ï¼Œä½ é€‰ä¸€ä¸ªé—¨ï¼Œç„¶åŽæ‰“å¼€å¦å¤–ä¸¤æ‰‡é—¨ä¸­çš„ä¸€æ‰‡ï¼Œå‘çŽ°é‚£ä¸ªé—¨åŽé¢æ˜¯åˆ«çš„ï¼Œé‚£ä¹ˆè¿™æ—¶å€™ä½ æ¢ä¸æ¢é—¨ï¼Ÿ è´´ä¸€ä¸ªçŸ¥ä¹Žä¸Šçš„è§†é¢‘ é¡ºä¾¿æ”¾ä¸ªä»£ç 12345678910111213141516171819202122from random import uniformdef defCar(): i = int(uniform(1, 4)) return idef cpt_posb(): N = 1000000 change = 0 dischange = 0 for i in range(N): car = defCar() doors = [1, 2, 3] choice = int(uniform(1, 4)) if choice == car: dischange += 1 else: change += 1 print(change / N * 100, "%") print(dischange / N * 100, "%")if __name__ == "__main__": cpt_posb() (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>æ¦‚çŽ‡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP åˆèµ›] è®¡ç®—æœºå¸¸è¯†æ€»ç»“]]></title>
    <url>%2F2018%2F10%2F09%2FNOIP-%E5%88%9D%E8%B5%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ç»§ç»­æ€»ç»“åˆèµ›å†…å®¹ï¼Œè¿™æ¬¡æ˜¯è®¡ç®—æœºå¸¸è¯†çš„æ€»ç»“ç¯‡ã€‚ è®¡ç®—æœºçš„å‘å±•å²è®¡ç®—æœºå‘å±•çš„ä»£åˆ«åˆ’åˆ† ä»£åˆ« å¹´ä»£ é€»è¾‘ï¼ˆç”µå­å…ƒä»¶ï¼‰ ç¬¬ä¸€ä»£ 1946â€”â€”1958 ç”µå­ç®¡ ç¬¬äºŒä»£ 1959â€”â€”1964 æ™¶ä½“ç®¡ ç¬¬ä¸‰ä»£ 1965â€”â€”1970 é›†æˆç”µè·¯ ç¬¬å››ä»£ 1971â€”â€”Today å¤§è§„æ¨¡ã€è¶…å¤§è§„æ¨¡é›†æˆç”µè·¯ ç¬¬ä¸€å°ç”µå­è®¡ç®—æœº1946 å¹´ 2 æœˆï¼Œåœ¨ç¾Žå›½å®¾å¤•æ³•å°¼äºšå¤§å­¦è¯žç”Ÿäº†ä¸–ç•Œä¸Šç¬¬ä¸€å°ç”µå­è®¡ç®—æœº ENIAC (Electronic Numberical Integrator and Computer)ï¼Œè¿™å°è®¡ç®—æœºå åœ° 170 å¹³æ–¹ç±³ï¼Œè´¨é‡ 30 å¨ï¼Œç”¨äº† 18000 å¤šä¸ªç”µå­ç®¡ï¼Œæ¯ç§’èƒ½è¿›è¡Œ 5000 æ¬¡åŠ æ³•è¿ç®—ï¼ˆå…¶å®žæˆ‘å¹¶ä¸çŸ¥é“è¿™äº›æ•°å­—æœ‰ä»€ä¹ˆç”¨ï¼‰ è®¡ç®—æœºç³»ç»Ÿç»“æž„ä¸­å¤®å¤„ç†å™¨ CPU (Central Processing Unit) ç”±è¿ç®—å™¨ï¼ŒæŽ§åˆ¶å™¨å’Œä¸€äº›å¯„å­˜å™¨ç»„æˆï¼› è¿ç®—å™¨è¿›è¡Œå„ç§ç®—æœ¯è¿ç®—å’Œé€»è¾‘è¿ç®—ï¼› æŽ§åˆ¶å™¨æ˜¯è®¡ç®—æœºçš„æŒ‡æŒ¥ç³»ç»Ÿï¼› CPU çš„ä¸»è¦æŒ‡æ ‡æ˜¯ä¸»é¢‘å’Œå­—é•¿ã€‚ å­—é•¿æŒ‡ä¸€å°è®¡ç®—æœºæ‰€èƒ½å¤„ç†çš„äºŒè¿›åˆ¶ä»£ç çš„ä½æ•°ï¼Œä¹Ÿå°±æ˜¯ ALU (Arithmetic and Logic Unit ç®—æœ¯é€»è¾‘è¿ç®—å•å…ƒ) çš„å®½åº¦ã€‚å­—é•¿è¶Šå¤§ï¼Œèƒ½è¡¨ç¤ºçš„æ•°å€¼èŒƒå›´å°±è¶Šå¤§ï¼Œè®¡ç®—å‡ºçš„æ•°å€¼çš„æœ‰æ•ˆä½æ•°å°±è¶Šå¤šï¼Œå­—é•¿è¶Šé•¿ï¼Œèƒ½è¡¨ç¤ºçš„ä¿¡æ¯å°±è¶Šå¤šï¼Œæœºå™¨çš„åŠŸèƒ½ä¹Ÿå°±è¶Šå¼ºã€‚ è¿ç®—é€Ÿåº¦æŒ‡è®¡ç®—æœºæ¯ç§’é’Ÿæ‰€èƒ½å¤Ÿæ‰§è¡Œçš„æŒ‡ä»¤æ¡æ•°ï¼Œä¸€èˆ¬ç”¨ MIPS (Million of Instructions Per Second æ¯ç§’ç™¾ä¸‡æ¡æŒ‡ä»¤) ä¸ºå•ä½ã€‚ç”±äºŽä¸åŒç±»åž‹çš„æŒ‡ä»¤æ‰§è¡Œæ—¶é—´é•¿çŸ­ä¸åŒï¼Œå› æ­¤è¿ç®—é€Ÿåº¦çš„è®¡ç®—æ–¹æ³•ä¹Ÿä¸ç›¸åŒ ä¸»é¢‘æŒ‡ CPU çš„æ—¶é’Ÿé¢‘çŽ‡ï¼ŒMHz æˆ– GHz ä¸ºå•ä½ å„ç§æ€»çº¿ æ€»çº¿åç§° æ„ä¹‰ æ•°æ®æ€»çº¿ å†³å®šäº† CPU å’Œå¤–ç•Œçš„æ•°æ®ä¼ è¾“é€Ÿåº¦ åœ°å€æ€»çº¿ å†³å®šäº† CPU èƒ½è®¿é—®çš„æœ€å¤§å†…å­˜ç©ºé—´çš„å¤§å° æŽ§åˆ¶æ€»çº¿ å†³å®šäº†å¯¹å¤–éƒ¨å™¨ä»¶çš„æŽ§åˆ¶èƒ½åŠ› ç›¸å…³é¢˜ç›® (NOIP-2009-T11) å…³äºŽ CPU ä¸‹é¢å“ªäº›è¯´æ³•æ˜¯æ­£ç¡®çš„ ( AB )ï¼šA. CPU å…¨ç§°ä¸ºä¸­å¤®å¤„ç†å™¨ï¼ˆæˆ–ä¸­å¤®å¤„ç†å•å…ƒï¼‰ã€‚B. CPU èƒ½ç›´æŽ¥è¿è¡Œæœºå™¨è¯­è¨€ã€‚C. CPU æœ€æ—©æ˜¯ç”± Intel å…¬å¸å‘æ˜Žçš„ã€‚D. åŒæ ·ä¸»é¢‘ä¸‹ï¼Œ32 ä½çš„ CPU æ¯” 16 ä½çš„ CPU è¿è¡Œé€Ÿåº¦å¿«ä¸€å€ã€‚ Intel å‘æ˜Žçš„æ˜¯å¾®å¤„ç†å™¨ CPU çš„ä½æ•°åªèƒ½è¯´æ˜Žå¤„ç†çš„ä½æ•°ï¼Œç”±äºŽæŒ‡ä»¤ä¸åŒï¼Œå¾ˆéš¾åˆ¤æ–­å“ªä¸ªå¿« (NOIP-2016-T9) æŸè®¡ç®—æœºçš„ CPU å’Œå†…å­˜ä¹‹é—´çš„åœ°å€æ€»çº¿çš„å®½åº¦æ˜¯ 32 ä½ ( bit )ï¼Œè¿™å°è®¡ç®—æœºæœ€å¤šå¯ä»¥ä½¿ç”¨ ( B ) çš„å†…å­˜ã€‚A. 2 GB &nbsp;&nbsp;&nbsp; B. 4 GB &nbsp;&nbsp;&nbsp; C. 8 GB &nbsp;&nbsp;&nbsp; D. 16GB è¿™é“é¢˜ä¸­ä¸»è¦æ˜¯è¦å…ˆèŽ·å–åœ°å€æ€»çº¿çš„å®½åº¦ï¼ˆä¸€èˆ¬ä¸Ž ALU çš„å®½åº¦ç›¸ç­‰ï¼‰ï¼Œåœ°å€æ€»çº¿å¯»å€æ˜¯æŒ‰ç…§å­—èŠ‚ï¼ˆ$\operatorname{Byte}$ï¼‰çš„ï¼Œæ‰€ä»¥ç­”æ¡ˆå°±æ˜¯ $2^{32} \operatorname{Byte}$ï¼Œä¹Ÿå°±æ˜¯ $4 \operatorname{GB}$ï¼Œä¸ç”¨ç®¡é¢˜ä¸­ç»™å‡ºçš„å•ä½ã€‚ å­˜å‚¨å™¨ä¸»å­˜å‚¨å™¨ä¸»å­˜å‚¨å™¨ï¼ˆä¹Ÿç§°ä¸ºå†…å­˜å‚¨å™¨ï¼‰ï¼Œå±žäºŽä¸»æœºçš„ä¸€éƒ¨åˆ†ã€‚ RAM éšæœºå­˜å‚¨å™¨ï¼šéšæœºæŒ‡éšæ—¶è¯»å‡ºå’Œå†™å…¥ ROM åªè¯»å­˜å‚¨å™¨ï¼šä¾‹å¦‚ BIOS (Basic Input Output System) å°±æ˜¯å›ºå®šåœ¨ä¸»æ¿ ROM ä¸Šçš„ä¸€ä¸ªè½¯ä»¶ Cacheï¼šåœ¨ CPU å’Œå†…å­˜ä¹‹é—´è®¾ç½®çš„ä¸€çº§æˆ–ä¸¤çº§çš„å‘Šè¯‰å°å®¹é‡å­˜å‚¨å™¨ï¼Œç§°ä¸ºé«˜é€Ÿç¼“å­˜å­˜å‚¨å™¨ã€‚ è¾…åŠ©å­˜å‚¨å™¨è¾…åŠ©å­˜å‚¨å™¨ï¼ˆä¹Ÿç§°ä¸ºå¤–å­˜å‚¨å™¨ï¼‰ï¼Œå±žäºŽå¤–éƒ¨è®¾å¤‡ã€‚ è½¯ç›˜å­˜å‚¨å™¨ ç¡¬ç›˜å­˜å‚¨å™¨ é—ªå­˜ï¼šå­˜å‚¨é€Ÿåº¦ä»‹äºŽè½¯ç›˜å’Œç¡¬ç›˜ä¹‹é—´çš„ä¸€ç§å¤–éƒ¨å­˜å‚¨å™¨ å…‰ç›˜ï¼šåˆ†ä¸ºåªè¯»å…‰ç›˜ï¼Œä¸€æ¬¡å†™å…¥åž‹å…‰ç›˜å’Œå¯æ“¦å†™å…‰ç›˜ å¯„å­˜å™¨CPU çš„å†…éƒ¨å­˜å‚¨å•ä½ï¼Œå­˜å–é€Ÿåº¦æœ€å¿«ã€‚ é€Ÿåº¦å­˜å‚¨å™¨è®¿é—®é€Ÿåº¦ï¼šå¯„å­˜å™¨ &gt; Cache &gt; å†…å­˜ &gt; å¤–å­˜ ç›¸å…³é¢˜ç›® (NOIP-2010-T8) ä¸»å­˜å‚¨å™¨çš„å­˜å–é€Ÿåº¦æ¯”ä¸­å¤®å¤„ç†å™¨(CPU)çš„å·¥ä½œé€Ÿåº¦æ…¢çš„å¤šï¼Œä»Žè€Œä½¿å¾—åŽè€…çš„æ•ˆçŽ‡å—åˆ°å½±å“ã€‚è€Œæ ¹æ®å±€éƒ¨æ€§åŽŸç†ï¼ŒCPUæ‰€è®¿é—®çš„å­˜å‚¨å•å…ƒé€šå¸¸éƒ½è¶‹äºŽä¸€ä¸ªè¾ƒå°çš„è¿žç»­åŒºåŸŸä¸­ã€‚äºŽæ˜¯ï¼Œä¸ºäº†æé«˜ç³»ç»Ÿæ•´ä½“çš„æ‰§è¡Œæ•ˆçŽ‡ï¼Œåœ¨CPUä¸­å¼•å…¥äº†( B )ã€‚Aï¼Žå¯„å­˜å™¨ &nbsp;&nbsp;&nbsp; Bï¼Žé«˜é€Ÿç¼“å­˜ &nbsp;&nbsp;&nbsp; Cï¼Žé—ªå­˜ &nbsp;&nbsp;&nbsp; Dï¼Žå¤–å­˜ (NOIP-2011-T4) 4ï¼Žå¯„å­˜å™¨æ˜¯ï¼ˆ D ï¼‰çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚A. ç¡¬ç›˜ &nbsp;&nbsp;&nbsp; B. é«˜é€Ÿç¼“å­˜ &nbsp;&nbsp;&nbsp; C. å†…å­˜ &nbsp;&nbsp;&nbsp; D. ä¸­å¤®å¤„ç†å™¨ï¼ˆCPUï¼‰ æœ‰å…³äººç‰©å†¯ Â· è¯ºä¾æ›¼1944 å¹´ï¼Œç¾Žç±åŒˆç‰™åˆ©æ•°å­¦å®¶å†¯ Â· è¯ºä¼Šæ›¼æå‡ºäº†è®¡ç®—æœºçš„åŸºæœ¬ç»“æž„å’Œå·¥ä½œæ–¹å¼çš„è®¾æƒ³ï¼Œä¸ºè®¡ç®—æœºçš„å‘å±•å’Œè¯žç”Ÿæä¾›äº†ç†è®ºåŸºç¡€ã€‚å½“ä»Šä¸–ç•Œçš„è®¡ç®—æœºå¤§éƒ¨åˆ†ä»å±žäºŽå†¯ Â· è¯ºä¼Šæ›¼ç»“æž„ã€‚ä»–çš„ç†è®ºè¦ç‚¹å¦‚ä¸‹ï¼š è®¡ç®—æœºç¡¬ä»¶è®¾å¤‡ç”±å­˜å‚¨å™¨ã€è¿ç®—å™¨ã€æŽ§åˆ¶å™¨ã€è¾“å…¥è®¾å¤‡å’Œè¾“å‡ºè®¾å¤‡ 5 éƒ¨åˆ†ç»„æˆã€‚ å­˜å‚¨ç¨‹åºæ€æƒ³â€”â€”æŠŠè®¡ç®—è¿‡ç¨‹æè¿°ä¸ºç”±è®¸å¤šå‘½ä»¤æŒ‰ä¸€å®šé¡ºåºç»„æˆçš„ç¨‹åºï¼Œç„¶åŽæŠŠç¨‹åºå’Œæ•°æ®ä¸€èµ·è¾“å…¥è®¡ç®—æœºï¼Œè®¡ç®—æœºå¯¹å·²å­˜å…¥çš„ç¨‹åºå’Œæ•°æ®å¤„ç†åŽï¼Œè¾“å‡ºç»“æžœã€‚ å†¯ Â· è¯ºä¾æ›¼è¿˜è®¾è®¡å‡ºç¬¬ä¸€å°å…·æœ‰å­˜å‚¨ç¨‹åºåŠŸèƒ½çš„è®¡ç®—æœº EDVAC (Electronic Discrete Variable Automatic Computer ç¦»æ•£å˜é‡è‡ªåŠ¨ç”µå­è®¡ç®—æœº) å›¾çµï¼ˆ1912.6.23 â€”â€” 1954.6.7ï¼‰è‰¾ä¼¦ Â· å›¾çµï¼š1913 å¹´ï¼Œå›¾çµè¿›å…¥å‰‘æ¡¥å¤§å­¦å›½çŽ‹å­¦é™¢ï¼Œæ¯•ä¸šåŽåˆ°ç¾Žå›½æ™®æž—æ–¯é¡¿å¤§å­¦æ”»è¯»åšå£«å­¦ä½ï¼ŒäºŒæˆ˜çˆ†å‘åŽå›žåˆ°å‰‘æ¡¥ï¼ŒåŽæ›¾ååŠ©å†›æ–¹ç ´è§£å¾·å›½è‘—åå¯†ç ç³»ç»Ÿ Enigmaï¼Œå¸®åŠ©ç›Ÿå†›å–å¾—äº†äºŒæˆ˜èƒœåˆ©ã€‚å›¾çµæå‡ºçš„å›¾çµæœºæ¨¡åž‹ä¸ºçŽ°ä»£è®¡ç®—æœºçš„é€»è¾‘å·¥ä½œæ–¹å¼å¥ å®šäº†åŸºç¡€ã€‚å›¾çµä¹Ÿæ˜¯è®¡ç®—æœºç§‘å­¦ç†è®ºåŸºç¡€ç¬¬ä¸€äººã€‚ Ada Lovelaceè¿™ä¸ªäººè€ƒè¯•ä¸­æœ€å¤šè€ƒä¸€ä¸‹å¥¹æ˜¯ä¸–ç•Œä¸Šç¬¬ä¸€ä¸ªç»™è®¡ç®—æœºå†™ç¨‹åºçš„äººï¼Œæ›¾å¯¹çŽ°ä»£è®¡ç®—æœºæŠ€æœ¯ä¹‹çˆ¶æŸ¥å°”æ–¯ Â· å·´è´å¥‡çš„ç¬”è®°æ‰‹ç¨¿è¿›è¡Œäº†æ•´ç†å’Œä¿®æ­£ã€‚åŒæ—¶åœ¨ 1980 å¹´ 12 æœˆ 10 æ—¥ï¼Œç¾Žå›½å›½é˜²éƒ¨åˆ¶ä½œäº†ä¸€ä¸ªæ–°çš„è®¡ç®—å™¨ç¼–ç¨‹è¯­è¨€ Adaã€‚å¦‚æžœæƒ³è¦æ›´æ·±å…¥åœ°äº†è§£è¿™ä¸ªäººç‚¹è¿™é‡Œã€‚ å…‹åŠ³å¾· Â· é¦™å†œï¼ˆ1916.4.30 â€”â€” 2001.2.26ï¼‰å…‹åŠ³å¾· Â· è‰¾å°”ä¼å¾· Â· é¦™å†œï¼ˆClaude Elwood Shannonï¼‰ï¼Œç¾Žå›½æ•°å­¦å®¶ã€ç”µå­å·¥ç¨‹å¸ˆå’Œå¯†ç å­¦å®¶ï¼Œè¢«èª‰ä¸ºä¿¡æ¯è®ºçš„åˆ›å§‹äººã€‚æ˜¯å¯†æ­‡æ ¹å¤§å­¦å­¦å£«ï¼Œéº»çœç†å·¥å­¦é™¢åšå£«ã€‚1948 å¹´ï¼Œä»–å°†çƒ­åŠ›å­¦ä¸­çš„ç†µçš„æ¦‚å¿µå¼•å…¥ä¿¡æ¯é€šä¿¡é¢†åŸŸï¼Œæ ‡å¿—ç€ä¿¡æ¯è®ºç ”ç©¶çš„å¼€ç«¯ã€‚ (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP åˆèµ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP åˆèµ›] æ€»ç»“ (POJ1664)]]></title>
    <url>%2F2018%2F10%2F08%2FNOIP-%E5%88%9D%E8%B5%9B-%E6%80%BB%E7%BB%93-%E8%8B%B9%E6%9E%9C%E6%94%BE%E7%9B%98%E5%AD%90%E9%97%AE%E9%A2%98-POJ1664%2F</url>
    <content type="text"><![CDATA[åˆèµ›æ¨¡æ‹Ÿæµ‹è¯•é”™äº†ä¸€é“ç®€å•é¢˜ï¼Œä¼¼ä¹Žè¿˜æ˜¯ä¸€é“é™ˆå¹´è€é¢˜ï¼Œç½‘ä¸ŠåŽ»æŸ¥äº†ä¸€ä¸‹ï¼Œä¼¼ä¹Žè¿˜å’Œ POJ 1663 è¿™é“æ°´é¢˜ä¸€æ¨¡ä¸€æ ·ï¼Œè¿™é‡Œæ€»ç»“ä¸€ä¸‹ é¢˜ç›®å¤§æ„ï¼šæœ‰ $m$ ä¸ªä¸€æ¨¡ä¸€æ ·çš„è‹¹æžœæ”¾å…¥ $n$ ä¸ªä¸€æ¨¡ä¸€æ ·çš„ç›˜å­ä¸­ï¼Œæ±‚æ”¾æ³•çš„æ•°é‡ $k$ã€‚æ³¨æ„ï¼šå¯¹äºŽ $m=7,n=3$ è¿™ç»„æ•°æ®ï¼š$5,1,1$ å’Œ $1,5,1$ æ˜¯ä¸€æ ·çš„ã€‚ æ€è·¯æˆ‘ä»¬æ¥åˆ†ç±»è®¨è®ºï¼Œä»¤ $\operatorname{f}(m,n)$ è¡¨ç¤ºæ”¾æ³•çš„æ•°é‡ $k$ï¼Œ $m&lt; n$ï¼Œæ­¤æ—¶æˆ‘ä»¬æŠŠå¤šä½™çš„ç›˜å­æ‹¿æŽ‰ï¼Œ$\operatorname{f}(m,n)=\operatorname{f}(m,m)$ $m\geqslant n$ï¼Œæ­¤æ—¶æˆ‘ä»¬å†åˆ†ä¸¤ç±»æ¥è®¨è®ºï¼šæœ‰ç›˜å­ç©ºç€å’Œæ²¡æœ‰ç›˜å­ç©ºç€ã€‚æœ‰ç›˜å­ç©ºç€æ—¶ï¼Œ$\operatorname{f}(m,n)=\operatorname{f}(m,n-1)$ï¼›æ²¡æœ‰ç›˜å­ç©ºç€æ—¶ï¼Œ$\operatorname{f}(m,n)=\operatorname{f}(m-n,n)$äºŽæ˜¯æˆ‘ä»¬å¾—å‡º $\operatorname{f}(m, n)$ çš„è¡¨è¾¾å¼ï¼š $$\operatorname{f}(m,n)=\begin{cases}1 &amp; \text{when $m=0$ or $n=1$} \\\operatorname{f}(m,m) &amp; \text{when $m&lt; n$} \\\operatorname{f}(m,n-1)+\operatorname{f}(m-n,n) &amp; \text{otherwise}\end{cases}$$ æ‰€ä»¥æˆ‘ä»¬å°±å¯ä»¥å†™å‡º POJ 1664 çš„ä»£ç äº†123456789101112131415161718#include &lt;iostream&gt;using namespace std;int f(int m, int n) &#123; if (m == 0 || n == 1) return 1; if (m &lt; n) return f(m, m); else return f(m, n - 1) + f(m - n, n);&#125;int main() &#123; int m, n, t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; m &gt;&gt; n; cout &lt;&lt; f(m, n); &#125; return 0;&#125; è‡³äºŽåˆèµ›ä¸­çš„é‚£é“é¢˜å˜›ï¼Œæ‰‹åŠ¨æ‰“è¡¨å°±å¯ä»¥äº†ï¼Œåº”è¯¥è¿˜æŒºå¿«çš„ï¼ˆä¼¼ä¹Žè¿˜å¯ä»¥ç›´æŽ¥æš´åŠ›æžšä¸¾â€¦â€¦ï¼‰ã€‚ (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP åˆèµ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP æ¨¡æ‹Ÿ] è®°å½•ä¸€é“çŽ„å­¦çš„é¢˜ç›®]]></title>
    <url>%2F2018%2F10%2F05%2FNOIP-%E6%A8%A1%E6%8B%9F-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E7%8E%84%E5%AD%A6%E7%9A%84%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©çš„ç¬¬äºŒé“é¢˜å®žåœ¨æ˜¯å‘ï¼Œè€ƒåœºä¸Šæš´åŠ›éƒ½ä¸èƒ½ä¸€æ¬¡æ‰“å¯¹ï¼Œæœ€åŽè®¢æ­£çš„æ—¶å€™è¿˜ WA äº† 20 å¤šæ¬¡ï¼Œç®€ç›´å¤ªå‘äº†å•Šï¼ï¼ðŸ˜­ðŸ˜­ðŸ˜­ðŸ˜­ é¢˜ç›®å¤§æ„ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º $n$ æ•°åˆ—ï¼Œå’Œ $m$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡æ±‚å‡ºä¸€ä¸ªåŒºé—´ $[l,r]$ çš„å’Œç„¶åŽå°†è¯¥åŒºé—´çš„æ‰€æœ‰æ•°å˜ä¸ºåŽŸæ¥çš„å¹³æ–¹ç„¶åŽæ¨¡ä¸Š $c=2305843008676823040$ é¢˜è§£è¿™é“é¢˜ç»™æˆ‘çš„ç¬¬ä¸€ä¸ªæ„Ÿè§‰å°±æ˜¯ï¼šè¿™ä¸ªæ¨¡æ•°å¤ªçµé­‚äº†ï¼Œè¿™ä¹ˆé•¿è€Œä¸”è¿˜ä¸æ˜¯ä¸ªè´¨æ•°ï¼ˆ$c = 2^{29}\times 3\times 5\times 17\times 257\times 65537$ï¼‰ã€‚äºŽæ˜¯æ‰“äº†ä¸ªè¡¨ï¼Œå‘çŽ°ä¸€ä¸ªæ•°å¹³æ–¹äº†å‡ åæ¬¡ä¹‹åŽå°±æ˜¯ä¸€ä¸ªå®šå€¼äº†ï¼Œæ‰€ä»¥å¯ä»¥è€ƒè™‘ä¼˜åŒ–æš´åŠ›ä»¥åŠä¼˜åŒ–åŒºé—´æŸ¥è¯¢å’Œä¿®æ”¹ï¼Œæ‰€ä»¥å°±è‡ªç„¶è€Œç„¶çš„æƒ³åˆ°äº†çº¿æ®µæ ‘ï¼ˆå½“ç„¶äº†ï¼Œä¼¼ä¹Žçº¯æš´åŠ›ä¿®æ”¹æˆ–è€…åˆ†å—ä»€ä¹ˆçš„â€¦â€¦ï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 70000#define modn 2305843008676823040typedef unsigned long long uint64;// æ•°æ®å¤ªå¤§äº†ï¼Œå¼€ä¸ª unsigned long long é˜²æ­¢çˆ†ï¼ˆä¼¼ä¹Ž long long å°±å¯ä»¥äº†ï¼‰struct segmentTreeNode &#123; int l, r; uint64 sum; bool flag; &#125;;// è£¸çº¿æ®µæ ‘segmentTreeNode t[maxn * 4];int n, m, x, y;uint64 a[maxn];#define l(x) t[x].l#define r(x) t[x].r#define sum(x) t[x].sum#define flag(x) t[x].flaginline uint64 mul(uint64 a, uint64 b) &#123; uint64 ans = 0; while (b &gt; 0) &#123; if (b &amp; 1) ans = (ans + a) % modn; a = (a + a) % modn; b &gt;&gt;= 1; &#125; return ans;&#125; // å¿«é€Ÿä¹˜ï¼Œé˜²çˆ†è£…å¤‡inline void build(int p, int l, int r) &#123; l(p) = l; r(p) = r; flag(p) = false; if (l == r) &#123; sum(p) = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); sum(p) %= modn; // åˆ«å¿˜è®°æ¨¡ï¼ï¼ï¼ flag(p) = flag(p * 2) &amp;&amp; flag(p * 2 + 1); // çŽ„å­¦æ›´æ–°&#125;inline uint64 query(int p, int l, int r) &#123; if (l &lt;= l(p) &amp;&amp; r(p) &lt;= r) return sum(p); int mid = (l(p) + r(p)) &gt;&gt; 1; uint64 val = 0; if (l &lt;= mid) (val += query(p * 2, l, r)) %= modn; if (r &gt; mid) (val += query(p * 2 + 1, l, r)) %= modn; return val;&#125;inline void update(int p, int l, int r) &#123; if (flag(p)) return; if (l(p) == r(p)) &#123; uint64 tmp = mul(sum(p), sum(p)); if (tmp == sum(p)) flag(p) = true; sum(p) = tmp; return; &#125; int mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) update(p * 2, l, r); if (r &gt; mid) update(p * 2 + 1, l, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); sum(p) %= modn; // åˆ«å¿˜è®°æ¨¡ï¼ï¼ï¼ flag(p) = flag(p * 2) &amp;&amp; flag(p * 2 + 1);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; build(1, 1, n); while (m--) &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; query(1, x, y) &lt;&lt; endl; update(1, x, y); &#125; return 0;&#125; å—¯ï¼ŒæŽ¥ä¸‹æ¥è¯æ˜Žä¸€ä¸‹ä¸ºä»€ä¹ˆä¼šå˜æˆä¸€ä¸ªå®šå€¼ã€‚å› ä¸ºï¼š$$c = 2305843008676823040 = 2^{29}\times 3\times 5\times 17\times 257\times 65537$$æ‰€ä»¥æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼š$$\varphi(c)=2^{28}\times 2\times 4\times 256\times 65536=2^{59}$$ç„¶åŽæˆ‘ä»¬æ¥åˆ†ç±»è®¨è®ºå¯¹äºŽä¸€ä¸ªæ•° $x$ï¼Œå¦‚æžœ $\gcd(x, c)=1$ï¼Œé‚£ä¹ˆæ ¹æ®è´¹é©¬-æ¬§æ‹‰å®šç†ï¼š$$x^{\varphi(c)}\equiv 1\pmod c$$æ‰€ä»¥ $x^{59}$ ä¹‹åŽå®ƒå°±æ˜¯ $1$ äº†ã€‚å¦‚æžœ $\gcd(x, c)\neq 1$ï¼š å¦‚æžœ $x=c$ï¼Œé‚£ä¹ˆæ˜¾ç„¶ï¼Œ$x$ ä¼šå˜æˆä¸€ä¸ªå®šå€¼ å¦‚æžœ $x\neq c$ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸€å®šå¯ä»¥ä»Ž $c$ ä¸­åˆ†ç¦»å‡ºä¸€ä¸ª $câ€™$ ä½¿å¾— $\gcd(x,câ€™)=1$ï¼Œè€Œ $\varphi(câ€™)&lt;59$ï¼Œæ‰€ä»¥ $x$ åœ¨ $59$ æ¬¡æ–¹å‰å°±å¯ä»¥å˜æˆä¸€ä¸ªå®šå€¼ã€‚ è¯æ¯•ï¼Œå¤ªå¦™äº†ï¼ (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP æ¨¡æ‹Ÿ</tag>
        <tag>çº¿æ®µæ ‘</tag>
        <tag>æ•°è®º</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¿ƒæ€è°ƒå´©ï¼šä¸€é“æš´åŠ› AC çš„é¢˜]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%BF%83%E6%80%81%E8%B0%83%E5%B4%A9%EF%BC%9A%E4%B8%80%E9%81%93%E6%9A%B4%E5%8A%9B-AC-%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æœ‰æ˜¯ä»¤äººæ„‰æ‚¦çš„å›½åº†ä¸ƒè¿žæµ‹ï¼Œç¬¬ä¸€é“é¢˜æ•´æ•´å¡äº†æˆ‘ä¸¤ä¸ªå°æ—¶ï¼ï¼éƒ½æ²¡æ—¶é—´åŽ»æ€è€ƒç¬¬ä¸‰é“é¢˜ðŸ˜­ðŸ˜­ã€‚ç„¶è€Œåšå‡ºæ¥äº†ä¹‹åŽå´å‘çŽ°æ˜¯å¦‚æ­¤çš„å¼±æ™ºã€‚ã€‚ã€‚ é¢˜ç›®å¤§æ„ä½ æœ‰ä¸€ä¸ªå›¾ï¼Œä½ ä»Žæœ€å·¦ä¸‹è§’çš„ç‚¹å¼€å§‹ï¼Œå¯ä»¥å‘ä¸Šæˆ–å‘ä¸‹èµ° ä¸å¤§äºŽ $h$ çš„å•ä½åˆ°å¦ä¸€ä¸ª #ï¼Œæˆ–è€…åœ¨åŒä¸€å±‚ç›¸è¿žçš„ #ï¼Œæ±‚èƒ½èµ°åˆ°ç»ˆç‚¹ $(x,y)$ çš„ $h$ çš„æœ€å°å€¼ã€‚ è¾“å…¥/è¾“å‡º[æ ·ä¾‹è¾“å…¥] 5 8 ####____ ___#_### ###__#__ ______#_ ######## 2 4 [æ ·ä¾‹è¾“å‡º] 2 é¢˜è§£å—¯â€¦â€¦è¿™é“é¢˜å¯ä»¥ç›´æŽ¥ BFS æ¨¡æ‹Ÿç„¶åŽæ¯æ¬¡æ‰¾ $h$ çš„æ—¶å€™äºŒåˆ†ç­”æ¡ˆå°±å¯ä»¥è¿‡äº†ã€‚è€ƒè¯•çš„æ—¶å€™æˆ‘æ˜¯ç”¨æœ€å°ç”Ÿæˆæ ‘åšçš„ï¼Œå› ä¸ºæœ€å°ç”Ÿæˆæ ‘æœ‰ä¸€ä¸ªæ€§è´¨ï¼šæœ€çŸ­çš„è¾¹ä¸€å®šä¼šè¢«åŒ…å«åœ¨ MST ä¸­ï¼Œè¿™ä¹Ÿæ˜¯ Kruskal ç®—æ³•çš„åŽŸç†ã€‚æ‰€ä»¥æˆ‘ä»¬åœ¨åš Kruskal çš„æ—¶å€™å°±å¯ä»¥ç”¨å¹¶æŸ¥é›†æ¥åˆ¤æ–­ä¸€ä¸‹æœ€å·¦ä¸‹è§’çš„ç‚¹å’Œç›®æ ‡ç‚¹æ˜¯å¦å·²ç»è¿žé€šï¼Œå¦‚æžœè¿žé€šå°±å¯ä»¥è·³å‡ºäº†ä¹Ÿå°±æ˜¯è¿™ä¸ªåœ°æ–¹è®©æˆ‘æ€è€ƒäº†ä¸€å¹´ï¼Œä¸€å¼€å§‹è¿˜åœ¨æƒ³æ€Žä¹ˆåœ¨åšå®Œ Kruskal ä¹‹åŽæœç´¢è·¯å¾„â€¦â€¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1010struct edgeNode &#123; int vertexTo; int vertexFrom; int edgeNext; int weight;&#125;;// è¿™ä¸ªåœ°æ–¹å…¶å®žä¸éœ€è¦å‰å‘æ˜Ÿï¼Œä¸€å¼€å§‹æƒ³é”™äº†æ‰æ‰“æˆè¿™ä¸ªchar ch;edgeNode edges[maxn * maxn * 2];int heads[maxn * maxn* 2], numEdges = 0, fa[maxn * maxn], ans = 0;bool dat[maxn][maxn];int n, m, x, y;inline void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].vertexFrom = vertex1; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;inline void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125;inline bool operator&lt;(edgeNode&amp; a, edgeNode&amp; b) &#123; return a.weight &lt; b.weight;&#125;inline int get(int x) &#123; return fa[x] == x ? x : (fa[x] = get(fa[x]));&#125;inline int change(int x, int y) &#123; return (x - 1) * m + y;&#125; // ç‚¹çš„æœ‰åºæ•°å¯¹è½¬åºå·inline void kruskal() &#123; for (int i = 1; i &lt;= numEdges; ++i) &#123; int u = get(edges[i].vertexFrom); int v = get(edges[i].vertexTo); if (u == v) continue; fa[u] = v; ans = max(ans, edges[i].weight); if (get(change(x, y)) == get(change(n, 1))) break; // å¼¹å‡º &#125;&#125;int main() &#123; ifstream in("mario.in"); ofstream out("mario.out"); // æ‡’å¾—æ‰“å¿«è¯» QAQ in &gt;&gt; n &gt;&gt; m; memset(dat, false, sizeof(dat)); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; in &gt;&gt; ch; dat[i][j] |= (ch == '#'); &#125; &#125; in &gt;&gt; x &gt;&gt; y; //////////////////////////////////////////// memset(heads, -1, sizeof(heads)); for (int i = 1; i &lt;= m; ++i) &#123; int k = 1; while (!dat[k][i]) k++; for (int j = k + 1; j &lt;= n; ++j) &#123; if (dat[j][i]) &#123; addDuplexEdge(change(k, i), change(j, i), j - k); k = j; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (!dat[i][j]) continue; else if (!dat[i][j + 1]) continue; else addDuplexEdge(change(i, j), change(i, j + 1), 0); &#125; &#125; //////////////////////////////////////////// /////////////////// åŠ è¾¹ /////////////////// //////////////////////////////////////////// for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; fa[change(i, j)] = change(i, j); &#125; &#125; sort(edges + 1, edges + numEdges + 1); kruskal(); out &lt;&lt; ans; return 0;&#125; (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP æ¨¡æ‹Ÿ</tag>
        <tag>æœ€å°ç”Ÿæˆæ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[çŒ´æŽ’ï¼ï¼Ÿä¸€é“é«˜è€ƒé¢˜ï¼ï¼Ÿå‡ºé¢˜äººçš„æ— ä¸‹é™çŒ´å­ä¸“åœº!]]></title>
    <url>%2F2018%2F10%2F03%2F%E7%8C%B4%E6%8E%92%EF%BC%81%EF%BC%9F%E4%B8%80%E9%81%93%E9%AB%98%E8%80%83%E9%A2%98%EF%BC%81%EF%BC%9F%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E6%97%A0%E4%B8%8B%E9%99%90%E7%8C%B4%E5%AD%90%E4%B8%93%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æ¨¡æ‹Ÿæµ‹çš„ç¬¬ä¸€é“é¢˜å®žåœ¨æ˜¯å¦™ï¼Œæœ¬ä»¥ä¸ºæ˜¯ç®€å•æŽ’åºï¼Œä½†æ˜¯å‘çŽ°æŸäº›æ•°æ®ä¸‹è¿‡ä¸äº†ï¼ŒåŽæ¥æƒ³æ‰“æš´åŠ›ï¼Œä½†æ˜¯æ€•ç›´æŽ¥è¢« T æŽ‰ï¼ŒäºŽæ˜¯ä½¿ç”¨äº†å…¨ä¸–ç•Œæœ€å¥½çš„çŒ´å­æŽ’åºï¼Œéª—äº†ä¸ª 35 åˆ†ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ é¢˜ç›®æè¿°Coder Jun å½“å¹´æ²¡æœ‰ç»åŽ†é«˜è€ƒå°±ç›´æŽ¥ä¿é€è¿›äº†åç‰Œå¤§å­¦ï¼Œå¦‚ä»Šå­©å­éƒ½ä¸Šåˆä¸­äº†ï¼Œæƒ³æƒ³ä¿é€æ”¿ç­–å·²ç»å–æ¶ˆï¼Œå­©å­è¿‡å‡ å¹´é“å®šè¦å‚åŠ é«˜è€ƒï¼Œå¿ƒé‡Œéžå¸¸ç€æ€¥ï¼ŒäºŽæ˜¯å†³å®šæŠ½ç©ºåšäº›é«˜è€ƒé¢˜ï¼Œå¥½ç»™å­©å­ä¼ æŽˆä¼ æŽˆç»éªŒã€‚äºŽæ˜¯ä»–é‡åˆ°äº†è¿™æ ·ä¸€é“é«˜è€ƒé¢˜ã€‚é¢˜ç›®ç»™ä½ äº† $N$ ä¸ªäºŒå…ƒç»„ï¼Œå…¶ä¸­ç¬¬iä¸ªäºŒå…ƒç»„è¡¨ç¤ºä¸º $(A_i,B_i)$ã€‚ä½¿ç”¨è¿™ä¸ªäºŒå…ƒç»„ï¼Œæˆ‘ä»¬å¯ä»¥æž„é€ å‡ºå¦ä¸€ä¸ªåºåˆ— $T$ï¼Œæž„é€ æ–¹æ³•å¦‚ä¸‹ï¼š å½“ $i=1$ æ—¶ï¼Œ$T_i=A_i+B_i$ å½“ $i\neq 1$ æ—¶ï¼Œ$T_i=B_i+\max\lbrace T_{i-1},\sum_{j=1}^i A_j\rbrace$ ç”±äºŽè®¡ç®—Tæ—¶éœ€è¦ç”¨åˆ° max å‡½æ•°ä»¤ Coder Jun æ„Ÿåˆ°éžå¸¸ä¸çˆ½ï¼Œæ‰€ä»¥ Coder Jun æƒ³è®©ä½ å¸®ä»–æ¥æœ€å°åŒ– $T_N$ çš„å€¼ï¼Œå³ä½ éœ€è¦å¯¹è¿™ $N$ ä¸ªäºŒå…ƒç»„è¿›è¡Œé‡æŽ’ï¼Œä½¿å¾— $T_N$ çš„å€¼æœ€å°ã€‚ é¢˜è§£éª—åˆ†ç®—æ³•å—¯ï¼Œåæ­£é¢˜ç›®ä¸­è¯´çš„å°±æ˜¯é‡æŽ’ï¼Œè€Œæˆ‘åˆä¸çŸ¥é“æ€Žä¹ˆæŽ’ï¼Œé‚£å½“ç„¶å°±æ˜¯çŒ´æŽ’äº†â€¦â€¦ 35åˆ†éª—åˆ†ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010typedef long long int64;struct Tuple &#123; int A; int B; &#125;;int N;Tuple tuple[maxn];// è¿™ä¸ª tuple åœ¨æŸäº›åœ°æ–¹å¥½åƒä¼šç¼–è¯‘å‡ºé”™......map&lt;string, int64&gt; mp;int64 ans = (1 &lt;&lt; 30), prefix[maxn];string sit;inline void prepare() &#123; prefix[1] = tuple[1].A; for (int i = 2; i &lt;= N; ++i) prefix[i] = prefix[i - 1] + tuple[i].A;&#125;inline int64 calc() &#123; int64 T_i_1, T_i; for (int i = 1; i &lt;= N; ++i) &#123; if (i == 1) &#123; T_i = tuple[i].A + tuple[i].B; T_i_1 = T_i; &#125; else &#123; T_i = tuple[i].B + max(T_i_1, prefix[i]); T_i_1 = T_i; &#125; &#125; return T_i;&#125;inline string hash() &#123; ostringstream ret; for (int i = 1; i &lt;= N; ++i) ret &lt;&lt; tuple[i].A &lt;&lt; " " &lt;&lt; tuple[i].B &lt;&lt; endl; return ret.str();&#125;int main() &#123; ifstream in("gaokao.in"); ofstream out("gaokao.out"); srand((unsigned)time(NULL)); in &gt;&gt; N; for (int i = 1; i &lt;= N; ++i) &#123; in &gt;&gt; tuple[i].A &gt;&gt; tuple[i].B; &#125; for (int i = 1; i &lt;= 10000000; ++i) &#123; if (clock() &gt;= 600) break; prepare(); mp[hash()] = calc(); if (clock() &gt;= 600) break; random_shuffle(tuple + 1, tuple + N + 1); if (clock() &gt;= 600) break; // éª—åˆ†ç²¾é«“ä¹‹å¤„ï¼Œæžé™å¡æ—¶ &#125; map&lt;string, int64&gt;::iterator iter; for (iter = mp.begin(); iter != mp.end(); ++iter) if (ans &gt; iter-&gt;second) &#123; ans = iter-&gt;second; sit = iter-&gt;first; &#125; out &lt;&lt; ans &lt;&lt; endl &lt;&lt; sit; return 0;&#125; è¿™ä¸ªä»£ç çœ‹çœ‹å¼€å¿ƒä¸€ä¸‹å°±å¥½ï¼Œè™½ç„¶è¯´å¯¹äºŽæŸäº›æ•°æ®æ˜¯å¯èƒ½å¯¹çš„ï¼Œä½†æ˜¯è¿˜æ˜¯è¦çœ‹äººå“ã€‚ æ­£è§£å…ˆåŒæ‰‹é€ä¸Šæ´›è°·ä¸Šçš„åŽŸé¢˜ðŸ‘ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬æ¥äº†è§£ä¸€ä¸‹ååºå…³ç³»è¿™ä¸ªä¸œè¥¿ï¼Œæˆ‘ä»¬å…¶å®žåªè¦æ˜Žç™½ä¸¥æ ¼ååºå’Œéžä¸¥æ ¼ååºçš„æ€§è´¨å°±è¡Œäº†ï¼ˆä¸»è¦æ˜¯ä¼ é€’æ€§è¿™ä¸ªä¸œè¥¿ï¼‰ã€‚ç„¶åŽæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹æ±‚è§£è¿™é“é¢˜äº†ã€‚è¿™é“é¢˜æ— éžå°±æ˜¯æ‰¾å‡ºä¸€ä¸ªæŽ’åºæ–¹æ³•æ¥ä»¤æ‰€æœ‰çš„æƒ…å†µä¸‹çš„ç»“æžœæœ€å°æˆ–æœ€å¤§ã€‚å› ä¸ºæˆ‘ä»¬æœ‰å…¬å¼ï¼š $$T_i=\begin{cases}A_i+B_i &amp; \text{when $i=1$} \\B_i+\max\lbrace T_{i-1},\sum_{j=1}^i A_j\rbrace &amp; \text{when $i\neq1$}\end{cases}$$ æ‰€ä»¥ $T_i\geqslant T_{i-1}$ æ˜¯ä¸¥æ ¼é€’å¢žçš„ã€‚ç„¶åŽæˆ‘ä»¬ç”¨ç›¸é‚»äº¤æ¢æ³•æ¥è€ƒè™‘ååºå…³ç³»ï¼ˆæŽ’åºçš„æ–¹æ³•ï¼‰ã€‚å¯¹äºŽæŸä¸¤ä¸ªå…ƒç»„ $(A_i,B_i)$ å’Œ $(A_{i+1}, B_{i+1})$ï¼Œå¦‚æžœæˆ‘ä»¬ä¸äº¤æ¢ï¼Œé‚£ä¹ˆï¼š $$\begin{aligned}\max\lbrace T_i, T_{i+1}\rbrace = {}&amp; T_{i+1} {} \\= {}&amp; B_{i+1}+\max\lbrace T_{i},\sum_{j=1}^{i+1}A_j\rbrace {} \\= {}&amp; B_{i+1}+\max\lbrace B_i+\max\lbrace T_{i-1},\sum_{j=1}^i A_j\rbrace,\sum_{j=1}^{i+1}A_j\rbrace\end{aligned}$$ æˆ‘ä»¬ä»¤ $S=\sum_{j=1}^{i-1}A_j$ï¼Œé‚£ä¹ˆä¸Šå¼å¯ä»¥è¡¨ç¤ºä¸ºï¼š $$\max\lbrace T_i,T_{i+1}\rbrace=B_{i+1}+\max\lbrace B_i+\max\lbrace T_{i-1},S+A_i\rbrace,S+A_i+A_{i+1}\rbrace$$ å³ï¼š $$\max\lbrace T_i,T_{i+1}\rbrace=\max\lbrace \left(T_{i-1}+B_i+B_{i+1}\right),\left(S+A_i+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_{i+1}\right)\rbrace$$ å¦‚æžœè¿™ä¸¤ä¸ªå…ƒç»„äº¤æ¢ï¼Œé‚£ä¹ˆ $\max\lbrace T_i,T_{i+1}\rbrace=T_i$ï¼Œå³ï¼š $$\begin{aligned}\max\lbrace T_i,T_{i+1}\rbrace=\max\lbrace \left(T_{i-1}+B_i+B_{i+1}\right),\left(S+A_{i+1}+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_i\right)\rbrace\end{aligned}$$ æˆ‘ä»¬ä¸å¦¨è®¾ä¸äº¤æ¢æ›´ä¼˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¾—åˆ°ï¼š $$\begin{aligned}{}&amp; \max\lbrace \left(T_{i-1}+B_i+B_{i+1}\right),\left(S+A_i+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_{i+1}\right)\rbrace\leqslant {} \\{}&amp; \max\lbrace \left(T_{i-1}+B_i+B_{i+1}\right),\left(S+A_{i+1}+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_i\right)\rbrace\end{aligned}$$ æ‰€ä»¥æˆ‘ä»¬çŽ°åœ¨å°±éœ€è¦æ€è€ƒå¦‚ä½•åˆ åŽ» $\left(T_{i-1}+B_i+B_{i+1}\right)$ è¿™ä¸€é¡¹äº†ã€‚è€ƒè™‘å¯¹äºŽä¸€ä¸ªä¸ç­‰å¼ $\max\lbrace a,c\rbrace\leqslant\max\lbrace b,c\rbrace$ï¼Œå¦‚æžœæˆ‘ä»¬åˆ åŽ» $c$ï¼Œé‚£ä¹ˆå°±å˜æˆäº† $a\leqslant c$ï¼Œå¦‚æžœè¿™ä¸ªä¸ç­‰å¼æˆç«‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸ç”¨ç®¡ï¼Œå¦‚æžœä¸æˆç«‹ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿›è¡Œäº¤æ¢ï¼ŒäºŽæ˜¯ï¼Œæˆ‘ä»¬åˆ¤æ–­æ›´ä¼˜æ¡ä»¶å°±å˜æˆäº† $$\begin{aligned}{}&amp; \max\lbrace \left(S+A_i+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_{i+1}\right)\rbrace\leqslant {} \\{}&amp; \max\lbrace \left(S+A_{i+1}+B_i+B_{i+1}\right),\left(S+A_i+A_{i+1}+B_i\right)\rbrace\end{aligned}$$ ä¸¤è¾¹æ¶ˆåŽ» $S$ï¼š $$\begin{aligned}{}&amp; \max\lbrace \left(A_i+B_i+B_{i+1}\right),\left(A_i+A_{i+1}+B_{i+1}\right)\rbrace\leqslant {} \\{}&amp; \max\lbrace \left(A_{i+1}+B_i+B_{i+1}\right),\left(A_i+A_{i+1}+B_i\right)\rbrace\end{aligned}$$ åŒ–ç®€å¾—ï¼š $$\max\lbrace A_{i+1},B_i\rbrace+A_i+B_{i+1}\leqslant\max\lbrace A_i,B_{i+1}\rbrace+A_{i+1}+B_i$$ ç§»é¡¹ï¼š $$\max\lbrace A_{i+1},B_i\rbrace-A_{i+1}-B_i\leqslant\max\lbrace A_i,B_{i+1}\rbrace-A_i-B_{i+1}$$ æˆ‘ä»¬å¯ä»¥å‘çŽ°ï¼Œä¸¤è¾¹å¼å­ä¸­å¤§çš„æ•°è¢«åˆ åŽ»äº†ï¼Œç•™ä¸‹çš„æ˜¯å°çš„æ•°çš„ç›¸åæ•°ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬äº†å¯ä»¥å¾—åˆ°ï¼š $$-\min\lbrace A_{i+1},B_i\rbrace\leqslant -\min\lbrace A_i, B_{i+1}\rbrace$$ å³ï¼š $$\min\lbrace A_i, B_{i+1}\rbrace\leqslant\min\lbrace A_{i+1},B_i\rbrace$$ è¿™ä¹Ÿå°±æ˜¯æˆ‘ä»¬åˆ¤æ–­æ›´ä¼˜çš„æ¡ä»¶äº†ï¼Œä½†æ˜¯ç»†ç»†ä¸€æƒ³ï¼Œå‘çŽ°ä¸å¯¹ï¼Œè¿™ä¸ªå¼å­ä¸æ»¡è¶³ååºçš„ä¼ é€’æ€§å•Šï¼ä¸¾ä¸ªä¾‹å­ï¼š 7 3 1 1 1 6 æ˜¾ç„¶ï¼Œè¿™æ ·å¯ä»¥æ˜¯æŽ’å®ŒåºåŽçš„ç»“æžœï¼Œå› ä¸ºä¸¤ä¸¤ä¹‹é—´ç”¨æ¡ä»¶åˆ¤æ–­éƒ½æ˜¯ç­‰äºŽã€‚è¿™æ ·ç®—å‡ºæ¥ç­”æ¡ˆæ˜¯ $17$ã€‚è€Œå¦‚æžœè¿™æ ·æŽ’ï¼š 1 1 1 6 7 3 ç­”æ¡ˆæ˜¯ $12$ï¼Œæ˜¾ç„¶è¿™æ ·æ›´ä¼˜ã€‚æ‰€ä»¥è¿™ä¸ªååºå…³ç³»å¹¶ä¸èƒ½å¾—å‡ºæœ€ä¼˜è§£ã€‚ æˆ‘ä»¬ä»Ž $A, B$ çš„å¤§å°å…³ç³»æ¥åˆ†ä¸‰ç»„è€ƒè™‘ï¼š $A_i&lt;B_i,A_{i+1}&lt;B_{i+1}$ æ—¶ï¼Œ$A_i\leqslant A_{i+1}$ï¼ŒæŒ‰ç…§ $A$ å‡åºæŽ’åº $A_i=B_i,A_{i+1}=B_{i+1}$ æ—¶ï¼Œéšä¾¿è¿™ä¹ˆæŽ’éƒ½å¯ä»¥ $A_i&gt;B_i,A_{i+1}&gt;B_{i+1}$ æ—¶ï¼Œ$B_i\geqslant B_{i+1}$ï¼ŒæŒ‰ç…§ $B$ æ¥é™åºæŽ’åº æŽ¥ä¸‹æ¥æ€è€ƒè¿™ä¸‰ç»„å¦‚ä½•æŽ’åºï¼š $1$ ç»„å’Œ $2$ ç»„ï¼Œ$1$ ç»„åœ¨ $2$ ç»„å‰è‚¯å®šèƒ½ä¿è¯æ»¡è¶³æ¡ä»¶ã€‚ $2$ ç»„å’Œ $3$ ç»„ï¼Œ$2$ ç»„åœ¨ $3$ ç»„å‰é¢è‚¯å®šèƒ½ä¿è¯æ»¡è¶³æ¡ä»¶ã€‚ é‚£ä¹ˆ $1$ ç»„åœ¨å‰ï¼Œ$2$ ç»„åœ¨ä¸­ï¼Œ$3$ ç»„åœ¨åŽï¼Œæ˜¯è‚¯å®šèƒ½ä¿è¯æ»¡è¶³è¦æ±‚çš„ã€‚ æˆ‘ä»¬ä»¤ $C_i=\operatorname{sgn}(A_i - B_i)$ï¼Œåˆ™å¯¹äºŽ $1$ ç»„ $C=-1$ï¼Œå¯¹äºŽ $2$ ç»„ $C=0$ï¼Œå¯¹äºŽç¬¬ä¸‰ç»„ $C=1$ï¼Œæ‰€ä»¥æœ€ç»ˆçš„æŽ’åºæ–¹æ³•æ˜¯ï¼šå…ˆæŒ‰ $C$ å€¼æŽ’åºï¼›ç„¶åŽè‹¥ $C$ å€¼å°äºŽç­‰äºŽ $0$ï¼ŒæŒ‰ $A$ å‡åºæŽ’åºï¼ˆè¿™é‡ŒæŠŠ $2$ ç»„å½’å…¥ $1$ ç»„ï¼‰ï¼›è‹¥ $C$ å€¼å¤§äºŽ $0$ï¼Œåˆ™æŒ‰ $B$ é™åºæŽ’åºã€‚ æ­£ç¡®ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 20010typedef long long int64;struct TU &#123; int64 A, B, C; &#125;;int64 N, p[maxn];TU t[maxn];inline bool cmp(TU a, TU b) &#123; if (a.C != b.C) return a.C &lt; b.C; if (a.C &lt;= 0) return a.A &lt; b.A; return a.B &gt; b.B;&#125;int main() &#123; freopen("gaokao.in", "r", stdin); freopen("gaokao.out", "w", stdout); scanf("%lld", &amp;N); for (int64 i = 1; i &lt;= N; ++i) &#123; scanf("%lld%lld", &amp;t[i].A, &amp;t[i].B); if (t[i].A &gt; t[i].B) t[i].C = 1; else if (t[i].A &lt; t[i].B) t[i].C = -1; else t[i].C = 0; &#125; sort(t + 1, t + N + 1, cmp); p[1] = t[1].A; int64 Ti1, Ti; for (int64 i = 2; i &lt;= N; ++i) p[i] = p[i - 1] + t[i].A; for (int64 i = 1; i &lt;= N; ++i) &#123; if (i == 1) &#123; Ti = t[i].A + t[i].B; Ti1 = Ti; &#125; else &#123; Ti = t[i].B + max(Ti1, p[i]); Ti1 = Ti; &#125; &#125; printf("%lld\n", T_i); for (int64 i = 1; i &lt;= N; ++i) printf("%lld %lld\n", t[i].A, t[i].B); return 0;&#125; (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP æ¨¡æ‹Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP æ¨¡æ‹Ÿ] ä¸€æ¬¡å‡ºå·è€å¸ˆæŠŠé¢˜ç›®å‡ºåçš„æ¨¡æ‹Ÿèµ›]]></title>
    <url>%2F2018%2F10%2F01%2FNOIP-%E6%A8%A1%E6%8B%9F-%E4%B8%80%E6%AC%A1%E5%87%BA%E5%8D%B7%E8%80%81%E5%B8%88%E6%8A%8A%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%8D%E7%9A%84%E6%A8%A1%E6%8B%9F%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[åœ¨è¿™é‡Œå…ˆç¥ç¥–å›½æ¯äº²ç”Ÿæ—¥å¿«ä¹ï¼Œä»¥åŠæˆä¸ºä¸–ç•Œä¸Šå­˜åœ¨æ—¶é—´æœ€é•¿çš„ç¤¾ä¼šä¸»ä¹‰å›½å®¶ï¼ðŸ˜ŠðŸ˜Šã€‚ å¥½äº†ï¼Œè¯´ä»Šå¤©è¿™å¥—é¢˜ç›®ï¼Œéš¶å±žäºŽå›½åº†ä¸ƒè¿žæµ‹ðŸ˜­ï¼Œç¬¬ä¸€é“é¢˜æœ€æ¶å¿ƒï¼Œç¬¬äºŒé¢˜æœ€éš¾æƒ³ï¼Œç¬¬ä¸‰é“é¢˜æœ€ç®€å•ã€‚ T1 breadé¢˜ç›®N ä¸ªæ•°ï¼ŒM æ¬¡æ“ä½œï¼Œç»™å‡ºä¸¤ä¸ªå‚æ•° p, qï¼Œç¬¬iæ¬¡æŸ“è‰²å°†åŒºé—´ (i * p + q) % N + 1 å’Œ (i * q + p) % N + 1 ä¹‹é—´çš„æ•°å˜ä¸º iï¼ˆåŽé¢çš„æ“ä½œå°†å‰é¢çš„è¦†ç›–ï¼‰ è¾“å…¥ M, N, p, q è¾“å‡ºæ¯ä¸ªæ•°çš„æœ€ç»ˆæ•°å­— 100% æ•°æ® n &lt;= 1e6, m &lt;= 1e7 m * p + q, m * q + p åœ¨ int èŒƒå›´å†… é¢˜è§£ä¸€å¼€å§‹çœ‹åˆ°è¿™é“é¢˜æ˜¯æ‡µé€¼çš„ï¼Œå…ˆæ‰“äº†ä¸€æ³¢æš´åŠ›æ¨¡æ‹Ÿï¼Œæœ€å¤§çš„æ•°æ®è·‘ä¸€å¹´éƒ½è·‘ä¸å‡ºæ¥ï¼ŒäºŽæ˜¯å¼€å§‹æ€è€ƒæ›´å¥½çš„ç®—æ³•ï¼ŒåŽæ¥åœ¨æŸå¤§ä½¬çš„æç¤ºä¸‹ï¼Œæƒ³åˆ°äº†å¹¶æŸ¥é›†çš„åšæ³•ã€‚å…ˆæ‰“è¡¨ï¼Œå‘çŽ°åœ¨ $M &gt; N$ æ—¶ï¼ŒåŒºé—´æ˜¯ä¼šæœ‰å¾ªçŽ¯çš„ï¼Œå¹¶ä¸”æ˜¯ $N$ æ¬¡ä¸€å¾ªçŽ¯ï¼Œè€Œè¿™é“é¢˜ä¸­æœ€åŽæŸä¸ªç‚¹çš„é¢œè‰²æ˜¯ä»¥æœ€åŽä¸€æ¬¡æŸ“è‰²ä¸ºå‡†çš„ï¼Œæ‰€ä»¥åªè¦å¯¹ $\max\lbrace M - N + 1, 1\rbrace$ åˆ° $M$ è¿™å‡ æ¬¡æ“ä½œè¿›è¡Œè¿ç®—å³å¯ã€‚ä½†æ˜¯å‘çŽ°è¿™æ ·è¿˜æ˜¯ä¼šè¶…æ—¶ï¼Œå› ä¸ºåŒºé—´æ˜¯ä¼šæœ‰é‡å¤çš„ï¼Œè¿™ä¼šé€ æˆå†—ä½™çš„å¤æ‚åº¦ï¼Œæ‰€ä»¥éœ€è¦è€ƒè™‘å¦‚ä½•å°†è¿™äº›è¿ç®—åŽ»æŽ‰ã€‚è€ƒè™‘å€’åºè¿›è¡Œå¤„ç†ï¼Œå½“æˆ‘ä»¬å¯¹åŒºé—´ $[l, r]$ è¿›è¡Œå¤„ç†æ—¶ï¼Œå¯¹äºŽæˆ‘ä»¬é‡åˆ°çš„æ¯ä¸€ä¸ªç‚¹ $k$ æœ‰ä¸¤ç§æƒ…å†µï¼š $k$ æœªè¢«æ›´æ–°è¿‡ã€‚ $k$ å·²ç»è¢«æ›´æ–°è¿‡äº†ï¼Œé‚£ä¹ˆä¸Šæ¬¡æ›´æ–°æ—¶å®ƒæ‰€åœ¨åŒºé—´çš„æ‰€æœ‰çš„ç‚¹ä¹Ÿéƒ½è¢«æ›´æ–°è¿‡äº†ã€‚ ä»Ž $r$ å‘å‰åˆ° $l$ è¿›è¡Œæ›´æ–°ï¼Œæˆ‘ä»¬è®°å½•ç‚¹ $k$ ä¸Šæ¬¡æ›´æ–°æ—¶çš„å·¦è¾¹ç•Œ $lâ€™$ï¼Œè‹¥ $k$ è¢«æ›´æ–°è¿‡ï¼Œé‚£ä¹ˆç›´æŽ¥è·³åˆ° $lâ€™-1$ å†ç»§ç»­å‘å‰æ›´æ–°ã€‚é‚£ä¸ºä»€ä¹ˆè¦ç”¨å¹¶æŸ¥é›†å‘¢ï¼Ÿå› ä¸ºè‹¥ $lâ€™-1$ ä¹Ÿè¢«æ›´æ–°è¿‡äº†ï¼Œå°±å¯ä»¥ç›´æŽ¥è·³åˆ°æ›´å‰é¢ï¼Œè¿›ä¸€æ­¥å‡å°‘å†—ä½™è¿ç®—ï¼ŒåŒæ—¶ä¹Ÿé˜²æ­¢æ•°æ®å¡æˆ‘ä»¬ã€‚ è´´ä¸Šä»£ç ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline void read(int &amp;x) &#123; x = 0; static char ch = 0; static bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125;struct PAINT &#123; int l, r; &#125;;#define maxm 10000010#define maxn 1000010int N, M, p, q, ans[maxn], fa[maxn];bool painted[maxn];PAINT paint[maxm];inline int get(int x) &#123; if (fa[x] == x) return x; return fa[x] = get(fa[x]); // è¿™é‡Œäº¤çš„æ—¶å€™æ‰“æˆäº† fa[x] == get(fa[x]) TAT // ç„¶è€Œåª WA äº†ä¸€ä¸ªç‚¹ orz&#125;int main() &#123; freopen("bread.in", "r", stdin); freopen("bread.out", "w", stdout); read(N); read(M); read(p); read(q); memset(ans, 0, sizeof(ans)); for (int i = 1; i &lt;= N; ++i) fa[i] = i; int low = max(M - N + 1, 1); for (int i = M; i &gt;= low; --i) &#123; int l = min((i * p + q) % N + 1, (i * q + p) % N + 1); int r = max((i * p + q) % N + 1, (i * q + p) % N + 1); paint[i].l = l; paint[i].r = r; &#125; // é˜²æ­¢åŒºé—´å‡ºé”™ï¼Œå› ä¸ºåˆå¯èƒ½å‡ºçŽ° l &gt; r çš„æƒ…å†µã€‚ for (int i = M; i &gt;= low; --i) &#123; int l = paint[i].l; int r = paint[i].r; int j = r; while (j &gt;= l) &#123; if (ans[j] == 0) &#123; ans[j] = i; fa[j] = get(l); j--; &#125; else &#123; j = fa[j] - 1; &#125; &#125; &#125; for (int i = 1; i &lt;= N; ++i) &#123; write(ans[i]); puts(""); &#125; return 0;&#125; T2 divideé¢˜ç›®ä½ æœ‰ n1 ä¸ª 1ï¼Œn2 ä¸ª 2, n3 ä¸ª 3, n4 ä¸ª 4, n5 ä¸ª 5, n6 ä¸ª 6ï¼Œé—®èƒ½å¦å°†ä»–ä»¬åˆ†æˆä¸¤éƒ¨åˆ†ä½¿å¾—ä¸¤éƒ¨åˆ†çš„å’Œç›¸ç­‰ è¾“å…¥ ç¬¬ä¸€è¡Œä¸€ä¸ªæ•´æ•°nï¼Œä¹‹åŽnè¡Œæ¯è¡Œå…­ä¸ªæ•´æ•°n1, n2, n3, n4, n5, n6 è¾“å‡º å¦‚æžœå¯ä»¥è¾“å‡º &quot;Can be divided.&quot;ï¼Œä¸è¡Œè¾“å‡º &quot;Can&apos;t be divided.&quot; é¢˜è§£è¿™é“é¢˜è€å¸ˆæ¥è¯´äº†ä¸‹ $n$ æœ€å¤§æœ‰ $5000$ï¼ŒäºŽæ˜¯åšä¿¡äº†è¿™é“é¢˜æ˜¯æ•°è®ºé¢˜ TATã€‚æ‰€ä»¥æ€è€ƒçš„è§’åº¦å®Œå…¨é”™è¯¯ï¼Œç›´æŽ¥çˆ†é›¶ã€‚æ¯”èµ›ç»“æŸåŽçŸ¥é“äº†åº”è¯¥ç”¨èƒŒåŒ…åšï¼Œä½†æ˜¯è£¸çš„å¤šé‡èƒŒåŒ…ä¼š TLEï¼Œæ›´ä½•å†µæœ‰ $5000$ çš„æ•°æ®ï¼Œæ‰€ä»¥åŽ»é˜…è¯»äº†æ ‡ç¨‹ï¼Œå‘çŽ°äº†åŽŸæ¥æ­£è§£æ˜¯ä¸€ä¸ªå¾ˆç¥žå¥‡çš„ dpã€‚ é¦–å…ˆæˆ‘ä»¬ä»¤ $f[i][j]$ è¡¨ç¤ºå½“æ€»å’Œä¸º $j$ æ—¶ï¼Œ$i$ è¿™ä¸ªæ•°è¿˜å¯ä»¥ä½¿ç”¨çš„ä¸ªæ•°ï¼Œ$a[i]$ è¡¨ç¤º $i$ è¿™ä¸ªæ•°å¯ä»¥ä½¿ç”¨çš„æ€»ä¸ªæ•°ï¼ŒäºŽæ˜¯æˆ‘ä»¬æœ‰åŠ¨æ€è§„åˆ’æ–¹ç¨‹å¦‚ä¸‹ï¼š $$f[i][j] =\begin{cases}a[i], &amp; \text{when $f[i - 1][j]\geqslant 0$} \\f[i][j - i] - 1, &amp; \text{when $j\geqslant i$ and $f[i - 1][j]\leqslant 0$} \\-1, &amp; \text{otherwise}\end{cases}\\\text{There is a solution only when $f[6][\frac{\sum_{i = 1}^6 a[i]\times i}{2}] \geqslant 0$}$$ ç„¶åŽå‘çŽ°æ•°ç»„ f å…¶å®žåªéœ€è¦ä¸€ç»´å°±å¤Ÿäº†ï¼Œè€Œä¸” $j$ ä¹Ÿåªéœ€è¦æžšä¸¾åˆ° $\frac{\sum_{i = 1}^6 a[i]\times i}{2}$ å°±è¡Œäº†ï¼Œæ‰€ä»¥å®žçŽ°çš„æ—¶å€™åªè¦è¿™æ ·å­å°±è¡Œäº†ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline void read(int &amp;x) &#123; x = 0; static char ch = 0; static bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125;#define maxn 20010// è¿™ä¸ª maxn ä¸èƒ½çœint n, a[10], sum, f[maxn];int main() &#123; read(n); while (n--) &#123; sum = 0; for (int i = 1; i &lt;= 6; ++i) &#123; read(a[i]); sum += a[i] * i; &#125; if (sum &amp; 1) &#123; puts("Can't be divided."); continue; &#125; sum &gt;&gt;= 1; memset(f, -1, sizeof(f)); f[0] = 0; for (int i = 1; i &lt;= 6; ++i) &#123; for (int j = 0; j &lt;= sum; ++j) &#123; if (f[j] &gt;= 0) f[j] = a[i]; else if (i &lt;= j) f[j] = f[j - i] - 1; else f[j] = -1; &#125; &#125; if (f[sum] &gt;= 0) puts("Can be divided."); else puts("Can't be divided."); &#125; return 0;&#125; T3 cmié¢˜ç›®æœ‰ä¸€å…¨æŽ’åˆ—ï¼Œæ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªæ•°ï¼Œæ±‚ä½¿å…¶å˜ä¸ºå‡åºçš„æœ€å°‘ç§»åŠ¨æ¬¡æ•° è¾“å…¥ ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œä¸ºæŽ’åˆ—ä¸­æ•°å­—çš„æ•°é‡ï¼Œç¬¬äºŒè¡Œä¸ºæŽ’åˆ— è¾“å‡º ä¸€è¡Œï¼Œæœ€å°‘ç§»åŠ¨çš„æ¬¡æ•° é¢˜è§£å°±æ˜¯æœ€é•¿ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰ï¼Œä¸­é—´å†åŠ ä¸€ç‚¹ä¼˜åŒ–ï¼ˆå¯ä»¥äºŒåˆ†ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥ç”¨ lower_bound() å‡½æ•°ï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;inline void read(int &amp;x) &#123; x = 0; static char ch = 0; static bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) putchar(stk[top--] + '0');&#125;#define maxn 200010int n, a[maxn], f[maxn], ans;int main() &#123; freopen("cmi.in", "r", stdin); freopen("cmi.out", "w", stdout); read(n); read(a[1]); ans = 1; f[1] = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; read(a[i]); if (a[i] &gt; f[ans]) &#123; ans++; f[ans] = a[i]; &#125; else &#123; int pos = lower_bound(f + 1, f + ans + 1, a[i]) - f; f[pos] = a[i]; &#125; &#125; write(n - ans); return 0;&#125; æ€»ç»“ä»Šå¤©çš„é¢˜ç›®åšå®ŒåŽçœŸçš„æ˜¯æ„Ÿè§‰å‡ºå·è€å¸ˆå‡ºåäº†ï¼Œä»¥åŽè¿˜æ˜¯å¾—å…ˆæµè§ˆä¸€éé¢˜ç›® orzã€‚ (adsbygoogle = window.adsbygoogle || []).push({});]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP æ¨¡æ‹Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP åˆèµ›] å„ç±»æŽ’åºç®—æ³•æ—¶é—´/ç©ºé—´å¤æ‚åº¦æ•´ç†]]></title>
    <url>%2F2018%2F09%2F28%2FNOIP-%E5%88%9D%E8%B5%9B-%E5%90%84%E7%B1%BB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[æŽ’åºç®—æ³•åœ¨åˆèµ›ä¸­ä¼¼ä¹Žæ¯æ¬¡éƒ½ä¼šè€ƒåˆ°ï¼Œè€Œä¸”è€ƒåˆ°çš„ä¸å¤–ä¹Žå®ƒä»¬çš„æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ï¼Œæ‰€ä»¥æ­¤å¤„è¿›è¡Œä¸€æ¬¡æ•´ç†ã€‚ æ—¶é—´å¤æ‚åº¦ ç®—æ³•åç§° å¹³å‡æ—¶é—´å¤æ‚åº¦ æœ€å¥½æ—¶é—´å¤æ‚åº¦ æœ€åæ—¶é—´å¤æ‚åº¦ ç¨³å®šæ€§ æ¡¶æŽ’åº $\mathcal{O}(n)$ $\mathcal{O}(n)$ $\mathcal{O}(n)$ ä¸ç¨³å®š åŸºæ•°æŽ’åº $\mathcal{O}(n)$ $\mathcal{O}(n)$ $\mathcal{O}(n)$ ç¨³å®š å½’å¹¶æŽ’åº $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ ç¨³å®š å¿«é€ŸæŽ’åº $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ $\mathcal{O}(n^2)$ ä¸ç¨³å®š é€‰æ‹©æŽ’åº $\mathcal{O}(n^2)$ $\mathcal{O}(n)$ $\mathcal{O}(n)$ ä¸ç¨³å®š æ’å…¥æŽ’åº $\mathcal{O}(n^2)$ $\mathcal{O}(n)$ $\mathcal{O}(n^2)$ ç¨³å®š å¸Œå°”æŽ’åº è§ç»´åŸºç™¾ç§‘ è§ç»´åŸºç™¾ç§‘ è§ç»´åŸºç™¾ç§‘ ä¸ç¨³å®š å †æŽ’åº $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ $\mathcal{O}(n\log n)$ ä¸ç¨³å®š å†’æ³¡æŽ’åº $\mathcal{O}(n^2)$ $\mathcal{O}(n^2)$ $\mathcal{O}(n^2)$ ç¨³å®š æ³¨ï¼šã€Šç®—æ³•ã€‹çš„ä½œè€…æ›¾ç»è¯´è¿‡ï¼Œæ‰€æœ‰çš„ä¸ç¨³å®šç®—æ³•éƒ½å¯ä»¥ç”¨é¢å¤–ç©ºé—´å˜æˆç¨³å®šçš„ï¼Œæ‰€ä»¥è¿™é‡Œçš„æ•´ç†åªèƒ½ç”¨äºŽ NOIP åˆèµ› ç©ºé—´å¤æ‚åº¦å†’æ³¡æŽ’åº,ç®€å•é€‰æ‹©æŽ’åº,å †æŽ’åº,ç›´æŽ¥æ’å…¥æŽ’åº,å¸Œå°”æŽ’åºçš„ç©ºé—´å¤æ‚åº¦ä¸º $\mathcal{O}(1)$ï¼Œå› ä¸ºéœ€è¦ä¸€ä¸ªä¸´æ—¶å˜é‡æ¥äº¤æ¢å…ƒç´ ä½ç½®,(å¦å¤–éåŽ†åºåˆ—æ—¶è‡ªç„¶å°‘ä¸äº†ç”¨ä¸€ä¸ªå˜é‡æ¥åšç´¢å¼•)å¿«é€ŸæŽ’åºç©ºé—´å¤æ‚åº¦ä¸º $\mathcal{O}(\log n)$ ï¼ˆå› ä¸ºé€’å½’è°ƒç”¨äº†ï¼‰ï¼Œå½’å¹¶æŽ’åºç©ºé—´å¤æ‚æ˜¯ $\mathcal{O}(n)$ï¼Œéœ€è¦ä¸€ä¸ªå¤§å°ä¸ºnçš„ä¸´æ—¶æ•°ç»„.åŸºæ•°æŽ’åºçš„ç©ºé—´å¤æ‚æ˜¯ $\mathcal{O}(n)$ï¼Œæ¡¶æŽ’åºçš„ç©ºé—´å¤æ‚åº¦ä¸ç¡®å®šã€‚]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP åˆèµ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEXO] hexo ä¸­åŠ å…¥ AdSense å¹¿å‘ŠæœåŠ¡çš„æ–¹æ³•]]></title>
    <url>%2F2018%2F09%2F25%2FHEXO-hexo-%E4%B8%AD%E5%8A%A0%E5%85%A5-AdSense-%E5%B9%BF%E5%91%8A%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å°±åœ¨æ˜¨å¤©ï¼æˆ‘çš„ AdSense ç”³è¯·ç»ˆäºŽè¿‡äº†ï¼è¿™é‡Œæ¥æ€»ç»“ä¸€ä¸‹ hexo ä¸Š AdSense é€šè¿‡çš„ç»éªŒã€‚ æ³¨å†Œ AdSense è´¦å·è¿™ä¸ªä¸å¤šè¯´äº†ï¼Œç›´æŽ¥åŽ»è¿™é‡Œ æ›´æ”¹è‡ªå·± hexo ä¸»é¢˜æ–‡ä»¶æ­¤å¤„ä»¥ NexT ä¸»é¢˜ä¸ºä¾‹ï¼ˆæ³¨ï¼šå¯èƒ½ä¸æ˜¯æœ€ç®€æ–¹å¼ï¼Œè‡ªè¡Œæ–Ÿé…Œï¼‰ï¼š æ–°å»º theme/next/layout/_custom/google_adsense.swigï¼Œå°† AdSense ä¸Šçš„ä»£ç ç²˜è´´è¿›åŽ» åœ¨ theme/next/layout/_custom/head.swig ä¸­ä¹Ÿç²˜è´´ä¸€ä»½ å¦‚æžœåœ¨æ¯ç¯‡åšå®¢é‡Œä¹Ÿæƒ³çœ‹åˆ°å¹¿å‘Šçš„è¯ï¼Œåœ¨ theme/next/layout/post.swig é‡Œä¸­åœ¨å¸Œæœ›çœ‹åˆ°çš„åœ°æ–¹åŠ ä¸Š: 1&#123;% include &apos;_custom/google_adsense.swig&apos; %&#125; ä¾‹å¦‚ï¼šåœ¨ &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &lt;/div&gt; ä¸­é—´æ’å…¥ï¼Œæ€»ä»£ç å¦‚ä¸‹ï¼š 123456&#123;% block content %&#125; &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;&#123; post_template.render(page) &#125;&#125; &#123;% include &apos;_custom/google_adsense.swig&apos; %&#125; &lt;/div&gt;&#123;% endblock %&#125; æ­¤æ—¶å¦‚æžœ hexo server çš„è¯æ˜¯çœ‹ä¸åˆ°å¹¿å‘Šçš„ï¼Œå› ä¸º AdSense çš„æ˜¾ç¤ºæ˜¯ Google æŽ§åˆ¶çš„ã€‚ ç–¯ç‹‚æ›´æ–°åšå®¢ä½ éœ€è¦ä½¿ä½ çš„ç½‘ç«™å†…å®¹å……è¶³ä»¥é€šè¿‡ AdSense çš„å®¡æ ¸ï¼ˆæˆ‘å†™äº† 21 ç¯‡å·¦å³æ‰é€šè¿‡ï¼Œå…¶å®žç®—ä¸Šæ‰€æœ‰ç½‘é¡µå…¶å®žè¿˜ä¸æ­¢ï¼‰ï¼Œå¦‚æžœè¢«æ‹’ç»äº†ï¼Œå°±å†é‡æ–°ç”³è¯·ä¸€æ¬¡ï¼Œè¯´ä¸å®šå°±è¿‡äº†ðŸ¤£ã€‚ æ€»ç»“ä½¿ç”¨ AdSense æ¥èµšå¤–å—ï¼Œç¾Žæ»‹æ»‹~~]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++ å¥‡æŠ€æ·«å·§] ç»ˆæžå¿«é€Ÿè¯»å…¥/è¾“å‡º]]></title>
    <url>%2F2018%2F09%2F22%2FC-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E7%BB%88%E6%9E%81%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%85%A5-%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[ä¸Šæ¬¡çœ‹åˆ°ä¸€ä¸ªæ‰‹å†™ getchar() çš„å¤§ç¥žï¼Œå‘çŽ°è‡ªå·±çš„å¿«é€Ÿè¯»å…¥è¿˜æ˜¯ä¸å¤Ÿéªšï¼ŒäºŽæ˜¯åŽ»æŸ¥äº†ä¸‹ç½‘ç»œï¼Œå‘çŽ°äº†æ›´åŠ åŽ‰å®³çš„å¿«è¯»æ–¹å¼ã€‚é¡ºä¾¿æŠŠè‡ªå·±çš„å¿«è¾“ç”¨éžé€’å½’ä¼˜åŒ–äº†ä¸€ä¸‹ã€‚ æ‰‹å†™ getchar()12345inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125; // ä½¿ç”¨ fread() æ¥æé«˜é€Ÿåº¦ å¿«è¯»ä½¿ç”¨ nextchar()1234567891011inline void read(int&amp; x) &#123; x = 0; static char ch = 0; static bool sign = false; // ä½¿ç”¨ static èŠ‚çœç©ºé—´ while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; // è¿™é‡Œ x * 10 å’Œ (x &lt;&lt; 1) + (x &lt;&lt; 3) ç¼–è¯‘åŽçš„ä»£ç æ˜¯ä¸€æ ·çš„ // æ‰€ä»¥ä¸éœ€è¦ç”¨ä½è¿ç®—äº† x = sign ? -x : x;&#125; éžé€’å½’ write()1234567inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) &#123; putchar(stk[top--] + '0'); &#125;&#125; é€Ÿåº¦æµ‹è¯•æ•°æ®ç”Ÿæˆ12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ofstream test("testdata.txt"); srand((unsigned)time(NULL) * 19260817); // +1s for (int i = 1; i &lt;= 5000000; ++i) test &lt;&lt; rand() &lt;&lt; " "; return 0;&#125; // ç¥–ä¼ ä»£ç  è€ç‰ˆæœ¬æµ‹è¯•12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;inline void read(int&amp; x) &#123; x = 0; char ch = 0; bool sign = false; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int main() &#123; freopen("testdata.txt", "r", stdin); freopen("output.txt", "w", stdout); int array[1000000]; auto start = system_clock::now(); for (int i = 1; i &lt;= 1000000; ++i) read(array[i - 1]); for (int i = 1; i &lt;= 1000000; ++i) write(array[i - 1]), putchar(' '); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; cost: 0.406813 seconds æ–°ç‰ˆæœ¬æµ‹è¯•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;inline char nextchar() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125; // ä½¿ç”¨ fread() æ¥æé«˜é€Ÿåº¦inline void read(int&amp; x) &#123; x = 0; char ch = 0; bool sign = false; // ä½¿ç”¨ static èŠ‚çœç©ºé—´ while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = nextchar(); &#125; while (isdigit(ch)) &#123; x = x * 10 + (ch ^ 48); ch = nextchar(); &#125; // è¿™é‡Œ x * 10 å’Œ (x &lt;&lt; 1) + (x &lt;&lt; 3) ç¼–è¯‘åŽçš„ä»£ç æ˜¯ä¸€æ ·çš„ // æ‰€ä»¥ä¸éœ€è¦ç”¨ä½è¿ç®—äº† x = sign ? -x : x;&#125;inline void write(int x) &#123; static int stk[100], top = 0; if (x == 0) &#123; putchar('0'); return; &#125; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; while (x) &#123; stk[++top] = x % 10; x /= 10; &#125; while (top) &#123; putchar(stk[top--] + '0'); &#125;&#125;int main() &#123; freopen("testdata.txt", "r", stdin); freopen("output.txt", "w", stdout); int array[1000000]; auto start = system_clock::now(); for (int i = 1; i &lt;= 1000000; ++i) read(array[i - 1]); for (int i = 1; i &lt;= 1000000; ++i) write(array[i - 1]), putchar(' '); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; cost: 0.275003 seconds æ€»ç»“æ–°çš„å¿«è¯»å‡ ä¹Žæ˜¯å¿«äº†ä¸€å€ï¼Œä¸è¿‡ä¸¤è€…éƒ½å·²ç»æ˜¯ç¥žä»™æ‰“æž¶äº†ï¼Œåƒ scanf è¿™ç§éƒ½å·²ç»è¢«è¸¢é£žäº†ï¼Œä¸è¿‡ï¼Œå¿«è¯»è™½å¥½ï¼Œä½¿ç”¨è¿˜æ˜¯è¦è°¨æ…Žï¼Œé€Ÿåº¦çš„æé«˜ä¸»è¦è¿˜æ˜¯é ç®—æ³•çš„ä¼˜åŒ–ï¼ˆé™¤äº†æŸäº›é«˜æ€§èƒ½çš„é¢˜ï¼‰ã€‚ è¡¥å……è¿™ä¸ª nextchar() å‡½æ•°åªèƒ½åœ¨è¯»å…¥æ–‡ä»¶æ—¶ä½¿ç”¨ï¼Œåœ¨æŽ§åˆ¶å°è¾“å…¥æ—¶ä¼šå‡ºé”™ï¼Œå› ä¸º fread() æ˜¯ä¸“é—¨é’ˆå¯¹æ–‡ä»¶çš„ã€‚]]></content>
      <categories>
        <category>å¥‡æŠ€æ·«å·§</category>
      </categories>
      <tags>
        <tag>C++ å¥‡æŠ€æ·«å·§</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP åˆèµ›] æ€»ç»“ä¸€æ³¢è¯»ç¨‹åºå†™ç»“æžœé¢˜ç›®]]></title>
    <url>%2F2018%2F09%2F20%2FNOIP-%E5%88%9D%E8%B5%9B-%E6%80%BB%E7%BB%93%E4%B8%80%E6%B3%A2%E8%AF%BB%E7%A8%8B%E5%BA%8F%E5%86%99%E7%BB%93%E6%9E%9C%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[ä¸ºäº†æé«˜åˆèµ›åˆ†æ•°ï¼Œç—›ä¸‹å†³å¿ƒæ€»ç»“ä¸€æ³¢è¯»ç¨‹åºå†™ç»“æžœçš„é¢˜ã€‚ps: ä¸€æ¬¡æ›´æ–°ä¸å®Œï¼Œä¼šæŒç»­æ›´æ–° ç¬¬äºŒåä¸€å±Š / NOIP 20151234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void fun(char *a, char *b) &#123; a = b; (*a)++;&#125;int main() &#123; char c1, c2, *p1, *p2; c1 = 'A'; c2 = 'a'; p1 = &amp;c1; p2 = &amp;c2; fun(p1, p2); cout &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; endl; return 0;&#125;// è¾“å‡ºï¼šAb è¿™é“é¢˜ä¸­å…ˆæ˜¯å°† p1 èµ‹å€¼ä¸º c1 çš„åœ°å€ï¼Œå°† p2 èµ‹å€¼ä¸º c2 çš„åœ°å€ï¼Œç„¶åŽå°† p1 èµ‹å€¼ä¸º p2 çš„å€¼ï¼Œå³çŽ°åœ¨ p1 æ‰€è¡¨ç¤ºçš„æ˜¯ c2 çš„åœ°å€ï¼Œæ‰€ä»¥æœ€åŽåªæœ‰ c2 ä¼šå‘ç”Ÿæ”¹å˜ï¼Œè¿™é“é¢˜ä¸€å¼€å§‹æ²¡çœ‹å‡ºæ¥ï¼ŒåŽæ¥ä»”ç»†æƒ³äº†æƒ³æ‰ååº”è¿‡æ¥ï¼Œä¸å¤±ä¸ºä¸€é“å‘é¢˜ã€‚ 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int fun(int n, int fromPos, int toPos) &#123; int t, tot; if (n == 0) return 0; for (t = 1; t &lt;= 3; t++) if (t != fromPos &amp;&amp; t != toPos) break; tot = 0; tot += fun(n - 1, fromPos, t); tot++; tot += fun(n - 1, t, toPos); return tot;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; fun(n, 1, 3) &lt;&lt; endl; return 0;&#125;// è¾“å…¥ï¼š5// è¾“å‡ºï¼š31 è¿™é“é¢˜å…¶å®žçº¯å±žç³Šå¼„äººï¼Œå¯ä»¥å‘çŽ° fun è¿™ä¸ªå‡½æ•°ä¸­ä¸ç®¡ fromPos å’Œ toPos ä¸ºä½•å€¼ï¼Œæ€»èƒ½ç»§ç»­ä¸‹åŽ»ï¼Œæ‰€ä»¥ç®€åŒ–åŽçš„å‡½æ•°å¦‚ä¸‹ï¼š 1234int fun(int n) &#123; if (n == 0) return 0; return fun(n - 1) * 2 + 1;&#125; å¥½äº†ï¼Œè¿™æ ·å­çš„é€’å½’å‡½æ•°æ‰‹æŽ¨å°±è¡Œäº†ã€‚ æœªå®Œå¾…ç»­â€¦â€¦]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP åˆèµ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP åˆèµ›] æ€»ç»“å„ç§å‘äººåŸºç¡€çŸ¥è¯†]]></title>
    <url>%2F2018%2F09%2F16%2FNOIP-%E5%88%9D%E8%B5%9B-%E6%80%BB%E7%BB%93%E5%90%84%E7%A7%8D%E5%9D%91%E4%BA%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[åˆèµ›ä¸´è¿‘ï¼Œæ¯å¤©ä¸€å¼ åˆèµ›å·è®©æˆ‘å‘çŽ°äº†å¾ˆå¤šåŸºç¡€çŸ¥è¯†ä¸Šçš„å‘ï¼ŒäºŽæ˜¯å†³å®šæ€»ç»“ä¸€ä¸‹ã€‚ ä¿¡ä»°å‘NOIï¼ˆ1984 è‡³ä»Šï¼‰: å·²ç»„ç»‡ 33 æ¬¡æ´»åŠ¨ï¼Œå„çœé€‰æ‹”äº”åé€‰æ‰‹ï¼Œè‡³å°‘ä¸€åä¸ºå¥³é€‰æ‰‹ã€‚NOIPï¼ˆ1995 è‡³ä»Šï¼‰: å·²ç»„ç»‡ 22 æ¬¡æ¯”èµ›ï¼Œå…¨å›½åŒä¸€æ—¶é—´ï¼Œä¸åŒåœ°ç‚¹ã€‚IOIï¼ˆ1989 è‡³ä»Šï¼‰: å·²ç»„ç»‡ 19 æ¬¡æ¯”èµ›ï¼ŒIOI 2000 ç”±ä¸­å›½ä¸»åŠžï¼ŒCCF æ‰¿åŠžã€‚APIOï¼ˆ2007 åˆ›å»ºï¼‰: APIO ä¸­å›½èµ›åŒºç”±ä¸­å›½è®¡ç®—æœºå­¦ä¼šç»„ç»‡ã€‚ NOIP 2022 å¹´å¼€å§‹å°†åœæ­¢æ”¯æŒ Pascal ç½‘ç»œåè®®å‘ARP (Address Resolution Protocol) åœ°å€è§£æžåè®®DHCP (Dynamic Host Configuration Protocol) åŠ¨æ€ä¸»æœºé…ç½®åè®®FTP (File Transfer Protocol) æ–‡ä»¶ä¼ è¾“åè®®HTTP (Hypertext Transfer Protocol) è¶…æ–‡æœ¬ä¼ è¾“åè®®HTTPS (Secure Hypertext Transfer Protocol) å®‰å…¨è¶…æ–‡æœ¬ä¼ è¾“åè®®IMAP4 (Internet Mail Access Protocol Version 4) Internet é‚®ä»¶è®¿é—®åè®®â€”â€”ç‰ˆæœ¬4IPv6 (Internet Protocol Version 6) Internet åè®®â€”â€”ç‰ˆæœ¬6POP3 (Post Office Protocol version 3) é‚®å±€åè®®â€”â€”ç‰ˆæœ¬3SMTP (Simple Mail Transfer Protocol) ç®€å•é‚®ä»¶ä¼ è¾“åè®®TFTP (Trivial File Transfer Protocol) å°åž‹æ–‡ä»¶ä¼ è¾“åè®® WWW æ˜¯ URLï¼Œä¸æ˜¯ç½‘ç»œåè®®]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP åˆèµ›</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP æ¨¡æ‹Ÿ] è®°å½•ä¸€é“å‘é¢˜]]></title>
    <url>%2F2018%2F09%2F01%2FNOIP-%E6%A8%A1%E6%8B%9F-%E8%AE%B0%E5%BD%95%E4%B8%80%E9%81%93%E5%9D%91%E9%A2%98%2F</url>
    <content type="text"><![CDATA[æ˜¨å¤©çš„ä¸€åœºæ¨¡æ‹Ÿï¼Œç¬¬äºŒé¢˜æœ¬æ¥åº”è¯¥æ˜¯ä¸€é“å¾ˆæ°´çš„é¢˜ï¼Œç„¶è€Œæœ€åŽæ‰“å´©äº†ï¼Œå½’æ ¹ç»“åº•è¿˜æ˜¯è‡ªå·±ä¸å¤Ÿä»”ç»†ï¼Œé¢˜ç›®å®¡é”™ï¼Œæœ€åŽå¯¼è‡´æ–¹æ³•ç”¨é”™ã€‚ é¢˜ç›®æè¿°[é—®é¢˜æè¿°] ç¥žå³å°†å¸¦é¢†ä¸€äº›äººåŽ»ä»–ä»¬çš„å­¤å¯‚ä¹‹å¢ƒï¼Œç”±äºŽè¿™ä¸ªä¸–ç•Œçš„ä¸ç¨³å®šï¼Œåœ°ç‚¹ä¹‹é—´çš„æœ‰å‘é“è·¯ä¼šä¸ å®šæœŸåœ°æ¯åï¼Œå‡ºäºŽå·¥ä½œå‡†å¤‡ï¼Œç¥žæƒ³çŸ¥é“åœ¨æŸäº›é“è·¯æ¯åä¹‹åŽæŸä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ã€‚ å°±æ˜¯ç»™å®šä¸€ä¸ªæœ‰å‘å›¾ï¼ŒçŽ°æœ‰ä¸¤ä¸ªæ“ä½œï¼Œæ“ä½œ1 æ˜¯åˆ é™¤ä¸€æ¡è¾¹ï¼ˆä¸€æ¡è¾¹å¯é‡å¤åˆ é™¤ï¼‰ï¼Œæ“ä½œ2 æ˜¯è¯¢é—®ä¸¤ä¸ªç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯ã€‚ [è¾“å…¥æ ¼å¼] è¾“å…¥æ–‡ä»¶åä¸ºjourney.inã€‚ ç¬¬1 è¡Œä¸¤ä¸ªæ­£æ•´æ•°n, mï¼Œåˆ†åˆ«è¡¨ç¤ºå›¾çš„ç‚¹æ•°å’Œæ“ä½œæ•°ã€‚ ç¬¬2 è¡Œè‡³ç¬¬n + 1 è¡Œæ¯è¡Œn ä¸ªæ­£æ•´æ•°ï¼Œä¸ºå›¾çš„é‚»æŽ¥çŸ©é˜µï¼Œç¬¬i è¡Œç¬¬j åˆ—çš„æ•°è¡¨ç¤ºç‚¹i å’Œç‚¹ j é—´è·ç¦»ï¼Œä¿è¯å¯¹è§’çº¿ä¸º0ã€‚ æŽ¥ä¸‹æ¥m è¡Œæ¯è¡Œä¸‰ä¸ªæ­£æ•´æ•°c, x, yï¼› c è¡¨ç¤ºæ“ä½œç§ç±»ï¼Œä¸º1 æˆ–2ï¼Œå½“c = 1 æ—¶è¡¨ç¤ºåˆ é™¤x ä¸Žy ç›¸è¿žçš„è¾¹ï¼Œå½“ c = 2 æ—¶è¡¨ç¤ºè¯¢é—® x åˆ° y çš„æœ€çŸ­è·¯ï¼Œè‹¥ä¸å¯è¾¾åˆ™è¾“å‡º -1ã€‚ [è¾“å‡ºæ ¼å¼] è¾“å‡ºæ–‡ä»¶åä¸ºjourney.out è¾“å‡ºè‹¥å¹²è¡Œï¼Œæ¯ä¸ª 2 æ“ä½œå¯¹åº”ä¸€è¡Œï¼Œç­”æ¡ˆä¸ºè¯¢é—®ä¸­ x åˆ° y çš„æœ€çŸ­è·¯æˆ– -1 [æ ·ä¾‹] è§ä¸‹å‘/girls/girls.in(out)ã€‚ [æ•°æ®è§„æ¨¡ä¸Žçº¦å®š] å¯¹äºŽ30% çš„æ•°æ®ï¼šn, m &lt;= 10 å¯¹äºŽ50% çš„æ•°æ®ï¼šn, m &lt;= 50 å¯¹äºŽ100% çš„æ•°æ®ï¼šn &lt;= 200; m &lt;= 100000, æ“ä½œ1 ä¸è¶…è¿‡200 æ¬¡ï¼Œè¾¹æƒä¸è¶…è¿‡10000 é¢˜è§£ä¸€ç¢°åˆ°æŸ¥æ‰¾çš„é¢˜ï¼Œé‚£è‚¯å®šå°±æ˜¯ä¸¤æ¡è·¯äº†ï¼Œç¦»çº¿å’Œåœ¨çº¿ä¸¤ç§æ€è·¯ï¼Œä¹ä¸€çœ‹è¿™ $n$ çš„æ•°æ®èŒƒå›´ï¼Œå¹¶ä¸”é¢˜ç›®ä¸­è¿˜è¯´è¾“å…¥é‚»æŽ¥çŸ©é˜µï¼Œé‚£æ±‚æœ€çŸ­è·¯è‚¯å®šæ˜¯ Floyd äº†ï¼Œå†ä¸€æƒ³ï¼Œå¦‚æžœæ˜¯åœ¨çº¿æŸ¥è¯¢é‚£åªæœ‰æœ´ç´ ç®—æ³•äº†ï¼ŒæŸ¥ä¸€æ¬¡æ±‚ä¸€æ¬¡å…¨æºæœ€çŸ­è·¯ï¼Œç„¶åŽè¿™ç§æ–¹æ³•å°± TLE äº†ï¼Œä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 210#define INF 0x3f3f3f3finline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;inline void writeln(int &amp;x) &#123; write(x); puts(""); &#125;inline void read(int &amp;a, int &amp;b) &#123; read(a); read(b); &#125;inline void read(int &amp;a, int &amp;b, int &amp;c) &#123; read(a); read(b); read(c); &#125;int g[maxn][maxn], d[maxn][maxn], n, m, c, x, y;void Floyd() &#123; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) g[i][j] = min(g[i][j], g[i][k] + g[k][j]);&#125;int main() &#123; freopen("journey.in", "r", stdin); freopen("journey.out", "w", stdout); memset(d, INF, sizeof(d)); read(n, m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) read(g[i][j]); while (m--) &#123; read(c, x, y); switch (c) &#123; case 1: &#123; g[x][y] = INF; break; &#125; case 2: &#123; memcpy(d, g, sizeof(g)); Floyd(); if (g[x][y] == INF) puts("-1"); else writeln(g[x][y]); memcpy(g, d, sizeof(d)); break; &#125; &#125; &#125; return 0;&#125; æ‰€ä»¥æ­£è§£è‚¯å®šå°±æ˜¯ç¦»çº¿æ“ä½œäº†ï¼Œå…ˆæŠŠè¯¥åˆ çš„è¾¹éƒ½ç»™åˆ æŽ‰ï¼Œç„¶åŽä»Žæœ€åŽä¸€ä¸ªæ“ä½œå¼€å§‹å¤„ç†ï¼Œé‡åˆ°æ“ä½œä¸€å°±åŠ è¾¹ï¼Œæ±‚ä¸€æ¬¡æœ€çŸ­è·¯ï¼Œå½“ç„¶è¿™é‡Œä¸æ˜¯ç”¨ Floyd è€Œæ˜¯ç”¨ä¸€ä¸ª $\mathcal{O}(n^2)$ çš„æ–¹æ³•ï¼Œé™„ä¸Šä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3f#define maxn 210#define maxm 100010struct op &#123; int c, x, y; &#125;;// op ç»“æž„ä½“ï¼Œè®°å½•æ“ä½œop ops[maxm];int g[maxn][maxn], d[maxn][maxn];int w[maxm], ans[maxm];int n, m;inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;inline void write(int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;inline void writeln(int x) &#123; write(x); puts(""); &#125;inline void read(int &amp;a, int &amp;b) &#123; read(a); read(b); &#125;inline void read(int &amp;a, int &amp;b, int &amp;c) &#123; read(a); read(b); read(c); &#125;// å¿«è¯»å¿«å†™é»‘ç§‘æŠ€void Floyd() &#123; for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125;// Floyd å¯¹ d[][] æ“ä½œæ±‚æœ€çŸ­è·¯int main() &#123; freopen("journey.in", "r", stdin); freopen("journey.out", "w", stdout); read(n, m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) read(g[i][j]); memcpy(d, g, sizeof(g)); // è¾“å…¥ï¼Œg[][] ç”¨æ¥å¤‡ä»½åŽŸé‚»æŽ¥çŸ©é˜µ for (int i = 1; i &lt;= m; ++i) &#123; read(ops[i].c, ops[i].x, ops[i].y); if (ops[i].c == 1) &#123; w[i] = g[ops[i].x][ops[i].y]; d[ops[i].x][ops[i].y] = INF; &#125; &#125; Floyd(); // è¯»å…¥æ‰€æœ‰æ“ä½œåŽ Floyd int cnt = 0; for (int k = m; k &gt; 0; --k) &#123; // æ³¨æ„å¾ªçŽ¯é¡ºåºï¼Œä»Žæœ€åŽä¸€ä¸ªå¼€å§‹ int x = ops[k].x; int y = ops[k].y; if (ops[k].c == 2) ans[++cnt] = (d[x][y] == INF ? -1 : d[x][y]); // é¢˜ç›®ä¸­è¦æ±‚å¦‚æžœä¸è¿žé€šè¾“å‡º -1ï¼Œæ‰€ä»¥è¿™é‡Œç‰¹åˆ¤ä¸€ä¸‹ // æ ‡ç¨‹ä¸­ä¼¼ä¹Žæ²¡æœ‰è¿™ä¸€å¥ï¼Œè‡ªå·±æžäº†ä¸€ä¸ªæ•°æ®æŠŠæ ‡ç¨‹ç»™å¡æŽ‰äº†ï¼Œæ‰€ä»¥è¿˜æ˜¯è¦åŠ çš„ else &#123; // æ±‚ä¸€æ¬¡æœ€çŸ­è·¯ï¼Œåªè¦æŠŠ d[x][y] åŠ è¿›åŽ»å†æ¯”è¾ƒä¸€ä¸‹å°±å¯ä»¥äº† for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; int tmp = d[i][x] + d[y][j] + w[k]; if (tmp &lt; d[i][j]) d[i][j] = tmp; &#125; &#125; &#125; &#125; // æœ€åŽè¾“å‡ºè¦æ³¨æ„é¡ºåº for (int i = cnt; i &gt; 0; --i) writeln(ans[i]); return 0;&#125; æ€»ç»“ä»¥åŽçœ‹åˆ°è¿™ç§é¢˜å¿…é¡»è¦è¯»æ¸…æ¥šé¢˜æ„ï¼Œç„¶åŽå†³å®šæ˜¯å¦ç¦»çº¿æ“ä½œï¼Œè€ƒè¯•çš„æ—¶å€™æˆ‘æ ¹æœ¬å°±æ˜¯æ™ºéšœäº†ï¼Œç›´æŽ¥åœ¨æ•°ç»„ $d$ ä¸Šé¢åˆ è¾¹ï¼Œæ±‚æœ€çŸ­è·¯ï¼Œç„¶åŽ GGã€‚å¹¸å¥½æœ€åŽé†’æ‚Ÿè¿‡æ¥æ‰“äº†ä¸ªæš´åŠ›ã€‚é‚»é˜¶çŸ©é˜µå°±æ˜¯è¿™ç‚¹å¤ªå‘ã€‚ã€‚ã€‚å®¹æ˜“è®©äººè¯¯æ“ä½œã€‚ã€‚ã€‚]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP æ¨¡æ‹Ÿ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEXO] NexT ä¸»é¢˜æé«˜åšå®¢é¢œå€¼]]></title>
    <url>%2F2018%2F08%2F30%2FHEXO-NexT-%E4%B8%BB%E9%A2%98%E6%8F%90%E9%AB%98%E5%8D%9A%E5%AE%A2%E9%A2%9C%E5%80%BC%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æ˜¯æŠŠåšå®¢å¥½å¥½åœ°ç¾ŽåŒ–äº†ä¸€æŠŠï¼Œä»Šå¤©å°±æ¥è®²ä¸€ä¸‹ hexo åšå®¢ç¾ŽåŒ–è¿‡ç¨‹ä¸­çš„å¿ƒå¾—ï¼Œå› ä¸ºè‡ªå·±ä½¿ç”¨çš„æ˜¯ NexT ä¸»é¢˜ï¼Œæ‰€ä»¥è¿™é‡Œçš„æœ‰äº›è¿‡ç¨‹ä»…ä¾›åˆ«çš„ä¸»é¢˜çš„ç”¨æˆ·åšå‚è€ƒã€‚ æ–‡ç« çš„æ¨¡æ¿æ–‡ä»¶ä¸ºäº†æ¯æ¬¡æ›´æ–°æ–¹ä¾¿ï¼Œæˆ‘ç›´æŽ¥æ”¹äº† blog/scaffolds/ ä¸‹çš„ post.mdï¼Œæ¯æ¬¡ç”Ÿæˆçš„æ—¶å€™æ¨¡æ¿å°±éƒ½æœ‰äº†ï¼Œä¸éœ€è¦è‡ªå·±å†åŽ»å¼„ã€‚è¿™ä¸ªæ˜¯æˆ‘çš„æ¨¡æ¿ï¼š 1234567891011121314151617---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:mathjax: truecopyright: truecomment: truephoto: ---&#123;% note default %&#125;&#123;% endnote %&#125;&lt;!-- more --&gt;--- è¯´æ˜Žä¸€ä¸‹ï¼Œè¿™ä¸ª note è¦åœ¨ next\_config.yml ä¸­å¼€å¯æ‰å¯ä»¥å†™ã€‚ä¸‹é¢ä¼šè®²åˆ°ã€‚photo æ˜¯æ–‡ç« å¼€å¤´çš„å›¾ç‰‡ï¼Œå°±åƒè¿™ç¯‡æ–‡ç« å¼€å¤´é‚£æ ·ï¼Œæ³¨æ„ä¸€å®šè¦åŠ ç»å¯¹è·¯å¾„ï¼Œæ¯”å¦‚æˆ‘è¿™å¼ å›¾ç‰‡å­˜åœ¨æ–‡ç« çš„æ–‡ä»¶å¤¹ä¸‹ï¼Œé‚£ä¹ˆè·¯å¾„å°±æ˜¯ /2018/08/30/HEXO-NexT-ä¸»é¢˜æé«˜åšå®¢é¢œå€¼/photo1.jpgã€‚copyright è¿™ä¸€é¡¹ä¹Ÿæ˜¯è¦å¼€å¯ä¹‹åŽæ‰è¡Œï¼Œæˆ‘çš„åšå®¢çš„ copyright æ˜¯è‡ªå·±é‡æ–°å†™çš„ï¼ŒåŽé¢ä¼šè®²åˆ°ã€‚æœ€åŽè¿™ä¸ª --- æ˜¯ç»“æŸç¬¦ï¼Œå’Œæœ€åŽçš„ç»“æŸè¯­ä¸€èµ·ç”¨ã€‚ Markdown æŠ€å·§ä¸Žå†…ç½®æ ·å¼åŸºç¡€çš„è¯­æ³•å°±ä¸æäº†ï¼Œç‚¹è¿›æ¥çš„åº”è¯¥éƒ½ä¼šäº†ã€‚è¿™é‡Œå°±è®²è®²ä¸€äº›æŠ€å·§ã€‚ ç¼–è¾‘å™¨æˆ‘ç”¨çš„ Markdown ç¼–è¾‘å™¨æ˜¯ Typoraï¼Œæœ‰äº›è¡Œå†…å…¬å¼çš„æ˜¾ç¤ºå¯ä»¥åœ¨è®¾ç½®é‡Œæ‰“å¼€ã€‚è¿™æ˜¯æˆ‘ç”¨è¿‡çš„æœ€å¥½çš„ Markdownç¼–è¾‘å™¨ åˆ†éš”çº¿å’Œç©ºè¡Œ12345è¿™æ˜¯æ–‡å­—&lt;hr /&gt;ä¸Šé¢æ˜¯åˆ†éš”çº¿&lt;br /&gt;ä¸Šé¢æ˜¯ç©ºè¡Œ æ•ˆæžœå¦‚ä¸‹ï¼š è¿™æ˜¯æ–‡å­— ä¸Šé¢æ˜¯åˆ†éš”çº¿ä¸Šé¢æ˜¯ç©ºè¡Œ å¼•ç”¨123&lt;blockquote&gt;å¼•ç”¨å†…å®¹&lt;/blockquote&gt;&lt;!-- å¦‚æžœå‰åŽé—´éš™å¾ˆå°ï¼Œå¯ä»¥åƒä¸‹é¢è¿™æ ·å†™ --&gt;&lt;p&gt;&lt;blockquote&gt;å¼•ç”¨å†…å®¹&lt;/blockquote&gt;&lt;/p&gt; æ•ˆæžœå¦‚ä¸‹ï¼š å¼•ç”¨å†…å®¹ å¼•ç”¨å†…å®¹ å±…ä¸­å’Œå³å¯¹é½1234&lt;!-- å±…ä¸­ --&gt;&lt;center&gt;å†…å®¹&lt;/center&gt;&lt;!-- å³å¯¹é½ --&gt;&lt;div style="text-align:right"&gt;å†…å®¹&lt;/div&gt; æ•ˆæžœå¦‚ä¸‹ï¼š å†…å®¹ å†…å®¹ å­—ä½“å¤§å°å’Œé¢œè‰²12&lt;font color="#187892" size="number"&gt;å†…å®¹&lt;/font&gt;&lt;!-- è¯¦ç»†è¯·æŸ¥çœ‹ http://www.w3school.com.cn/tags/tag_font.asp --&gt; æ•ˆæžœå¦‚ä¸‹ï¼š å†…å®¹ Todo list1234&lt;ul&gt;&lt;li&gt;&lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ&lt;/li&gt;&lt;li&gt;&lt;i class="fa fa-square"&gt;&lt;/i&gt; æœªå®Œæˆ&lt;/li&gt;&lt;/ul&gt; æ•ˆæžœå¦‚ä¸‹ï¼š å·²å®Œæˆ æœªå®Œæˆ Note åµŒå¥— Todo list1234567891011121314151617181920212223&lt;!-- ä¸€å…±æœ‰ä¸¤ç§å†™æ³•ï¼Œæ•ˆæžœçœ‹ä¸‹é¢ --&gt;&lt;div class="note primary"&gt; &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-square"&gt;&lt;/i&gt; æœªå®Œæˆ &lt;i class="fa fa-square"&gt;&lt;/i&gt; æœªå®Œæˆ &lt;i class="fa fa-square"&gt;&lt;/i&gt; æœªå®Œæˆ&lt;/div&gt;&lt;div class="note primary"&gt; &lt;p&gt; &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-check-square"&gt;&lt;/i&gt; å·²å®Œæˆ &lt;i class="fa fa-square"&gt;&lt;/i&gt; æœªå®Œæˆ &lt;i class="fa fa-square"&gt;&lt;/i&gt; æœªå®Œæˆ &lt;i class="fa fa-square"&gt;&lt;/i&gt; æœªå®Œæˆ &lt;/p&gt;&lt;/div&gt; æ•ˆæžœå¦‚ä¸‹ï¼š å·²å®Œæˆ å·²å®Œæˆ å·²å®Œæˆ å·²å®Œæˆ å·²å®Œæˆ æœªå®Œæˆ æœªå®Œæˆ æœªå®Œæˆ å·²å®Œæˆ å·²å®Œæˆ å·²å®Œæˆ å·²å®Œæˆ å·²å®Œæˆ æœªå®Œæˆ æœªå®Œæˆ æœªå®Œæˆ è¿™ä¸¤ä¸ªå†™æ³•ç†Ÿæ‚‰ HTML çš„åŒå­¦åº”è¯¥æ˜¯æ˜Žç™½çš„ï¼Œè¿™é‡Œå› ä¸ºæˆ‘å¤ªèœäº†å°±ä¸è®²äº†ã€‚ä¸»è¦è¯´ä¸€ä¸‹ &lt;i class=&quot;fa fa-square&quot;&gt;&lt;/i&gt; æ˜¯ä»Ž Font Awesome ä¸ŠèŽ·å–å›¾æ ‡çš„æ–¹æ³•ï¼Œä¸è¿‡æœ‰äº›å›¾æ ‡ä¼¼ä¹Žæ˜¯ä¸èƒ½åŠ è½½çš„ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆã€‚ Font AwesomeFont Awesome æ›´å¤šçš„ä½¿ç”¨å¯ä»¥çœ‹å®˜ç½‘ç¤ºä¾‹ï¼Œè¿™é‡Œè®²ä¸€ä¸ªæ”¾å¤§å›¾æ ‡çš„æ–¹æ³• 123&lt;i class="fa fa-download"&gt;&lt;/i&gt; æ™®é€š&lt;i class="fa fa-download fa-lg"&gt;&lt;/i&gt; å˜å¤§ 33%&lt;i class="fa fa-download fa-2x"&gt;&lt;/i&gt; ä¸¤å€å¤§ æ•ˆæžœå¦‚ä¸‹ï¼š æ™®é€š å˜å¤§ 33% ä¸¤å€å¤§ ä»£ç é«˜äº®ä¸»é¢˜è‡ªå¸¦æ ·å¼ ä»£ç å—é«˜äº®12```[language] [title] [url] [link-text]`ä»£ç ` [language] æ˜¯ä»£ç è¯­è¨€çš„åç§°ï¼Œç”¨æ¥è®¾ç½®ä»£ç å—é¢œè‰²é«˜äº®ï¼Œéžå¿…é¡»ï¼›[title] æ˜¯é¡¶éƒ¨å·¦è¾¹çš„è¯´æ˜Žï¼Œéžå¿…é¡»ï¼›[url] æ˜¯é¡¶éƒ¨å³è¾¹çš„è¶…é“¾æŽ¥åœ°å€ï¼Œéžå¿…é¡»ï¼›[link text] å¦‚å®ƒçš„å­—é¢æ„æ€ï¼Œè¶…é“¾æŽ¥çš„åç§°ï¼Œéžå¿…é¡»ã€‚äº²æµ‹è¿™ 4 é¡¹åº”è¯¥æ˜¯æ ¹æ®ç©ºæ ¼æ¥åˆ†éš”ï¼Œè€Œä¸æ˜¯[]ï¼Œæ•…è¯·ä¸è¦åŠ []ã€‚é™¤éžå¦‚æžœä½ æƒ³å†™åŽé¢ä¸¤ä¸ªï¼Œä½†ä¸æƒ³å†™å‰é¢ä¸¤ä¸ªï¼Œé‚£ä¹ˆå°±å¿…é¡»åŠ  [] äº†ï¼Œè¦è¿™æ ·å†™ï¼š[] [] [url] [link text]ã€‚ é¦–å…ˆå…³äºŽä»£ç å—é¢œè‰²é«˜äº®ï¼Œé«˜äº®çš„æ¨¡å¼å¯ä»¥åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­è®¾ç½®ï¼š123456# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night eighties è¦é¢œè‰²æ­£ç¡®é«˜äº®ï¼Œä»£ç è¯­è¨€çš„åç§°è‚¯å®šè¦å†™å¯¹ï¼Œå„ç§æ”¯æŒè¯­è¨€çš„åç§°å¯ä»¥æŸ¥çœ‹è¿™ç¯‡æ–‡ç« ã€‚å½“ç„¶ï¼Œå¦‚æžœä½ å’Œæˆ‘ä¸€æ ·æ‡’ï¼Œå¯ä»¥åœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ _config.yml ä¸­è®¾ç½®è‡ªåŠ¨é«˜äº®ï¼ˆä¸è¿‡è¿™ä¸ªè‡ªåŠ¨é«˜äº®ä¼¼ä¹Žæœ‰é—®é¢˜ï¼Œä¸å»ºè®®æ‰“å¼€ï¼‰ï¼š123456highlight: enable: true line_number: true# ä»£ç è‡ªåŠ¨é«˜äº®- auto_detect: false+ auto_detect: true ä»Žç½‘ä¸Šæ‰¾åˆ°çš„ä¸€ä¸ªæ–‡æœ¬æ•ˆæžœå¦‚ä¸‹ï¼ˆåˆ«è·Ÿæˆ‘è¯´ä½ ä¸çŸ¥é“ diff æ˜¯ä»€ä¹ˆï¼‰ï¼š123456789101112131415161718192021222324252627Index: languages/ini.js===================================================================--- languages/ini.js (revision 199)+++ languages/ini.js (revision 200)@@ -1,8 +1,7 @@ hljs.LANGUAGES.ini = &#123;- case_insensitive: true,- defaultMode: &#123;+ defaultMode: &#123;- contains: ['comment', 'title', 'setting'],+ illegal: '[^\\s]'+ &#125;,*** /path/to/original timestamp--- /path/to/new timestamp****************** 1,3 ****--- 1,9 ----+ This is an important+ notice! It should+ therefore be located at+ the beginning of this+ document!! compress the size of the! changes. It is important to spell ä»£ç ä»…ä»…é«˜äº®è‚¯å®šæ˜¯ä¸å¤Ÿåœ°ï¼Œä»£ç å—åœ°åŠŸèƒ½ä¹Ÿå¾ˆé‡è¦ï¼Œæ¯”å¦‚å¤åˆ¶è¿™ä¸ªåŠŸèƒ½ã€‚åªè¦åœ¨ _config.yml é‡Œæ‰“å¼€å°±è¡Œå•¦ï¼š123456789codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: 3 # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true Note æ ‡ç­¾åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶_config.ymlé‡Œæœ‰ä¸€ä¸ªå…³äºŽè¿™ä¸ªçš„é…ç½®:123456789# Note tag (bs-callout).note: # é£Žæ ¼ style: flat # è¦ä¸è¦å›¾æ ‡ icons: true # åœ†è§’çŸ©å½¢ border_radius: 3 light_bg_offset: 0 ç”¨ HTML å†™å°±æ˜¯è¿™ä¸ªæ ·å­1234567&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt;&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt;&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt;&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt;&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;&lt;div class="note danger no-icon"&gt;&lt;p&gt;danger no-icon&lt;/p&gt;&lt;/div&gt; ç”¨ swig è¯­æ³•å†™å°±æ˜¯è¿™æ · 12345&#123;% note [class] %&#125;Any content (support inline tags too).&#123;% endnote %&#125;[class] : default | primary | success | info | warning | danger. May be not defined. é‡Œé¢çš„ä¸‰ç§é£Žæ ¼é•¿å•¥æ ·ï¼Ÿå¼€å¯å›¾æ ‡é•¿å•¥æ ·ï¼Ÿå¯ä»¥æŸ¥çœ‹è¿™ä¸ªé¡µé¢ï¼Œæ›´å¤šçš„ä»‹ç»ä¹Ÿåœ¨è¿™ä¸ªé¡µé¢ï¼Œè¯·è‡ªè¡ŒæŸ¥çœ‹ æœ€åŽçš„å‡ ç§æ•ˆæžœï¼š defaultprimarysuccessinfowarningdangerdanger no-icon Label æ ‡ç­¾label æ ‡ç­¾ä¸å»ºè®®åŠ åœ¨æ®µé¦–, é¦–å…ˆå¯ä»¥åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­æœ‰é…ç½®ï¼š12# Label tag.label: true ç„¶åŽæ•ˆæžœå¦‚ä¸‹ï¼ˆ@å‰é¢çš„æ˜¯labelçš„åå­—ï¼ŒåŽé¢çš„æ˜¯è¦æ˜¾ç¤ºçš„æ–‡å­—ï¼‰ default 1&#123;% label default@default %&#125; primary 1&#123;% label primary@primary %&#125; success 1&#123;% label success@success %&#125; info 1&#123;% label info@info %&#125; warning 1&#123;% label warning@warning %&#125; danger 1&#123;% label danger@danger %&#125; Tab é€‰é¡¹å¡å½“ç„¶ä¹Ÿæ˜¯è¦å…ˆé…ç½®ä¸€ä¸‹ï¼š1234567# Tabs tag.tabs: enable: true transition: tabs: true labels: true border_radius: 3 ä»£ç å¦‚ä¸‹ï¼š1234567891011&#123;% tabs é€‰é¡¹å¡, 2 %&#125;&lt;!-- tab --&gt;**è¿™æ˜¯é€‰é¡¹å¡ 1** å‘µå‘µå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆ&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**è¿™æ˜¯é€‰é¡¹å¡ 2** é¢ã€‚ã€‚ã€‚&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**è¿™æ˜¯é€‰é¡¹å¡ 3** å“‡ï¼Œä½ æ‰¾åˆ°æˆ‘äº†ï¼&lt;!-- endtab --&gt;&#123;% endtabs %&#125; æ•ˆæžœå¦‚ä¸‹ï¼šé€‰é¡¹å¡ 1é€‰é¡¹å¡ 2é€‰é¡¹å¡ 3è¿™æ˜¯é€‰é¡¹å¡ 1 å‘µå‘µå“ˆå“ˆå“ˆå“ˆå“ˆå“ˆè¿™æ˜¯é€‰é¡¹å¡ 2 é¢ã€‚ã€‚ã€‚è¿™æ˜¯é€‰é¡¹å¡ 3 å“‡ï¼Œä½ æ‰¾åˆ°æˆ‘äº†ï¼ ä¸Šé¢æºç ä¸­ï¼Œ2 è¡¨ç¤ºä¸€å¼€å§‹åœ¨ç¬¬äºŒä¸ªé€‰é¡¹å¡ï¼Œéžå¿…é¡»ï¼Œè‹¥æ•°å€¼ä¸º -1 åˆ™éšè—é€‰é¡¹å¡å†…å®¹ã€‚ æŒ‰é’®æ ·å¼ä»£ç å¦‚ä¸‹ï¼š1&#123;% btn https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test, æ›´å¤šå…³äºŽæŒ‰é’®çš„ä½¿ç”¨ç‚¹è¿™é‡Œ, download fa-lg fa-fw %&#125; æ•ˆæžœå¦‚ä¸‹ï¼š æ›´å¤šå…³äºŽæŒ‰é’®çš„ä½¿ç”¨ç‚¹è¿™é‡Œ æ›´å¤šçš„ä¸»é¢˜é…ç½®è¿”å›žé¡¶éƒ¨æŒ‰é’®ä¸Žé˜…è¯»è¿›åº¦åœ¨ next/_config.yml é‡Œæ‰¾åˆ° b2t è¿™ä¸ªåœ°æ–¹è¿›è¡Œå¦‚ä¸‹é…ç½®ï¼š1234# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true æ·»åŠ  RSS è®¢é˜…é¦–å…ˆå®‰è£…ä¸€ä¸ªæ¨¡å—1$ npm install hexo-generator-feed --save ç„¶åŽåœ¨æ ¹ç›®å½•ä¸‹çš„ _config.yml é‡Œæ·»åŠ ï¼š1plugins: hexo-generate-feed æœ€åŽåœ¨ next\_config.yml é‡Œé…ç½®ï¼š1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.# Set rss to specific value if you have burned your feed already.rss: /atom.xml é‡æ–°ç”Ÿæˆå°±å¯ä»¥ä½¿ç”¨ RSS äº†ã€‚ è¯„è®ºç³»ç»Ÿé‡é…ç½®ä»¥å‰ç”¨çš„æ˜¯ Disqusï¼Œç„¶è€Œéœ€è¦ç¿»å¢™ï¼Œæ‰€ä»¥å†³å®šæ¢æˆ Valineã€‚è¿™ä¸ª Valine è¦å…ˆåœ¨ LeanCloud é‡Œæ³¨å†Œå¹¶åˆ›å»ºä¸€ä¸ªåº”ç”¨ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°.ç„¶åŽåœ¨ next\_config.yml é‡Œé…ç½®ã€‚æ³¨æ„ï¼šå¾—åœ¨ LeanCloud -&gt; åº”ç”¨ -&gt; è®¾ç½® -&gt; åº”ç”¨ Key ä¸­æŠŠ AppID å’Œ AppKey ç»™å¤åˆ¶åˆ° next\_config.yml é‡Œé¢åŽ»ï¼Œå¹¶ä¸”åœ¨ LeanCloud -&gt; åº”ç”¨ -&gt; è®¾ç½® -&gt; å®‰å…¨ä¸­å¿ƒ é‡Œå°†è‡ªå·±çš„åŸŸåæ·»åŠ åˆ° Web å®‰å…¨åŸŸå ä¸­ã€‚ 1234567891011valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: # your leancloud application appid appkey: # your leancloud application appkey notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: ðŸ˜Žçœ‹äº†è¿™ä¹ˆå¤šï¼Œä¸æƒ³è¯´ç‚¹ä»€ä¹ˆå˜›ðŸ˜‰ # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html è¿™ä¸ª LeanCloud ä¹Ÿæ˜¯æ¯”è¾ƒè‰¯å¿ƒçš„å•Šï¼Œå¯ä»¥å…è´¹ä½¿ç”¨ï¼Œå½“ç„¶æˆ‘ç”¨çš„æ˜¯å¼€å‘ç‰ˆï¼Œæ‰€ä»¥å¤§å®¶ä¸è¦å¤ªç€æ€¥ðŸ¤£ã€‚]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[æ‚è°ˆ] ç¼–ç¨‹è§„èŒƒé‚£äº›äº‹]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%9D%82%E8%B0%88-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢ä¸€ç›´å¾ˆæƒ³å†™ä¸€ç¯‡åšå®¢æ¥æ™®åŠä¸€ä¸‹â€œç¼–ç¨‹è§„èŒƒâ€è¿™ä¸ªçœ‹ä¼¼ä¸é‡è¦å…¶å®žå¾ˆé‡è¦çš„ä¸œè¥¿ï¼Œé¦–å…ˆï¼Œå®ƒæ˜¯å›¢é˜Ÿåˆä½œçš„åŸºç¡€ï¼Œæœ‰äº› OI ç«žèµ›ä¹Ÿæ˜¯æœ‰å›¢é˜Ÿåˆä½œçš„ã€‚å…¶æ¬¡ï¼Œä¸‹åˆ° OI ä¸­å‡ åè¡Œçš„ç¨‹åºï¼Œä¸Šåˆ°å¤§é¡¹ç›®ä¸­å‡ åƒè¡Œç”šè‡³å‡ ä¸‡è¡Œä¹ƒè‡³ä¸Šäº¿ï¼ˆé¢ï¼Œè¿™ä¸ªä¼¼ä¹Žå¾ˆå°‘è§ï¼‰ï¼Œå¦‚æžœå†™å¾—å¤ªéš¾çœ‹é‚£å°±ä¼šè®©äººå®žåœ¨æ˜¯æ— æ³•å¿å—ï¼ˆæ¯”å¦‚åœ¨å†™ DP çš„æ—¶å€™ç¡¬æ˜¯å°†ä¸€ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹åŽ‹æˆäº†ä¸€è¡Œï¼Œè¡Œæ•°æ¯”åˆ—æ•°è¿˜å¤šä¸€å€ï¼‰ã€‚å¯è§ç¼–ç¨‹è§„èŒƒæ˜¯å¤šä¹ˆçš„é‡è¦! Google C++ ç¼–ç¨‹è§„èŒƒGoogle çš„é¡¹ç›®ä¸€ç›´éƒ½è®©äººçœ‹èµ·æ¥èµå¿ƒæ‚¦ç›®ï¼Œå³ä½¿æœ‰äº›æ··ä¹±çš„å®å®šä¹‰ä¹Ÿè®©äººçœ‹èµ·æ¥èµå¿ƒæ‚¦ç›®ï¼Œé¦–å…ˆè´´ä¸€å¼ å›¾ï¼Œè½¬è‡ª CSDN ä¸Šçš„ä¸€ç¯‡åšå®¢ ç„¶åŽè´´ä¸Šè°·æ­Œç¼–ç¨‹æŒ‡å—çš„è¯¦ç»†è¯´æ˜Ž è¯„ä»·Google çš„ç¼–ç¨‹æŒ‡å—çœŸçš„æ˜¯é«˜å¦™ï¼Œçœ‹èµ·æ¥èµå¿ƒæ‚¦ç›®ï¼Œä½†ä¸ªäººè§‰å¾—è¿˜æ˜¯è¦åŽ»å…¶ç³Ÿç²•çš„ï¼Œæ¯”å¦‚â€œä¸ç”¨å…¨å±€å˜é‡â€è¿™ç§ï¼Œåœ¨ç«žèµ›ä¸­å°±å¯ä»¥ç›´æŽ¥å¿½è§†äº†ï¼Œè¿˜æ˜¯ä»¥ä»£ç çš„æ˜“ç”¨æ€§ä¸ºç¬¬ä¸€è¦åŠ¡ã€‚]]></content>
      <categories>
        <category>æ‚è°ˆ</category>
      </categories>
      <tags>
        <tag>æ‚è°ˆ</tag>
        <tag>ç¼–ç¨‹è§„èŒƒ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HEXO] hexo ä¸­æ’å…¥è§†é¢‘çš„æ–¹æ³•]]></title>
    <url>%2F2018%2F08%2F29%2FHEXO-hexo-%E4%B8%AD%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢ä»¥å‰ä¸€ç›´ä»¥ä¸º hexo æ˜¯ä¸èƒ½æ’å…¥è§†é¢‘çš„ï¼Œä»Šå¤©çªç„¶çŸ¥é“äº†ï¼ŒåŽŸæ¥æ’å…¥è§†é¢‘æ˜¯å¯ä»¥çš„ï¼ï¼æœ¬ç¯‡åšå®¢ä¸»è¦è®²è§£ä¸€ä¸‹ hexo åšå®¢å¦‚ä½•æ’å…¥è§†é¢‘ã€‚ æ’å…¥ Youtube è§†é¢‘æ’å…¥ Youtube è§†é¢‘å…¶å®žå¾ˆç®€å•ï¼Œåœ¨ YouTube è§†é¢‘çš„ä¸‹æ–¹çš„â€œå…±äº«â€ä¸­ï¼Œé€‰æ‹©åµŒå…¥å³å¯èŽ·å–ç±»ä¼¼è¿™æ ·çš„é“¾æŽ¥ï¼š 1&lt;iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/7gJ8mGFjeqA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt; æ•ˆæžœå¦‚ä¸‹ï¼ˆè¦æ¢¯å­ï¼‰ï¼š å¯ä»¥å°† width æˆ– height æ”¹ä¸º &quot;100%&quot;ï¼ˆå½“ç„¶ä¹Ÿå¯ä»¥ä¸¤ä¸ªéƒ½æ”¹ï¼Œå…·ä½“æ•ˆæžœè¯•äº†æ‰çŸ¥é“ï¼Œè¿™ä¸ªæ•°å€¼æ˜¯å¯ä»¥éšä¾¿æ”¹çš„ï¼‰ 1&lt;iframe width="100%" height="350" src="https://www.youtube-nocookie.com/embed/7gJ8mGFjeqA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt; æ•ˆæžœå¦‚ä¸‹ï¼ˆè¦æ¢¯å­ï¼‰ï¼š æ’å…¥ Bilibili è§†é¢‘å…¶å®žä¹Ÿæ˜¯ä¸€æ ·ï¼Œç‚¹å‡»â€œåˆ†äº«â€ï¼ŒèŽ·å– iframe è¿™ä¸ªä»£ç å°±å¯ä»¥äº† 1&lt;iframe src="//player.bilibili.com/player.html?aid=19448254&amp;cid=31715906&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"&gt; &lt;/iframe&gt; æ•ˆæžœå¦‚ä¸‹ï¼š è‡ªå®šä¹‰äº†å¤§å°ä¹‹åŽçš„æ•ˆæžœï¼š é€šç”¨æ–¹æ³•ç›´æŽ¥æŠŠè§†é¢‘æ–‡ä»¶æ”¾åœ¨èµ„æºæ–‡ä»¶å¤¹é‡Œï¼Œç„¶åŽç›´æŽ¥å†™ HTML ä»£ç ï¼š 123&lt;video width="100%" height="400" src="movie.mp4" controls="controls"&gt;The `&lt;video&gt;` tag is not supported by your browser.&lt;/video&gt; æ•ˆæžœå¦‚ä¸‹ï¼š The &lt;video&gt; tag is not supported by your browser. æ€»ç»“å—¯â€¦â€¦ HTML å¤§æ³•å¥½ï¼Œåœ¨ Markdown é‡Œç”¨ HTML æŽ§ä»¶ç®€ç›´ç¾Žæ»‹æ»‹ã€‚]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[å›¾è®º] Dijkstra æœ€çŸ­è·¯è®¡æ•°]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%9B%BE%E8%AE%BA-Dijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢æœ€çŸ­è·¯è®¡æ•°æ˜¯ä¸€ä¸ªå¾ˆç»å…¸çš„é—®é¢˜ï¼Œä»Šå¤©åˆšå¥½åšåˆ°äº†è¿™æ ·ä¸€é“é¢˜ï¼Œå°±æ¥æ€»ç»“ä¸€ä¸‹ã€‚ æœ€çŸ­è·¯è®¡æ•°é¢˜ç›®ï¼šæ´›è°· P1144 æœ€çŸ­è·¯è®¡æ•°æœ€çŸ­è·¯è®¡æ•°æœ¬è´¨ä¸Šè¿˜æ˜¯æ±‚æœ€çŸ­è·¯ï¼Œåªä¸è¿‡åœ¨è¿­ä»£çš„åŒæ—¶æ¥æ›´æ–°æœ€çŸ­è·¯æ•°é‡ã€‚é¦–å…ˆæ¥å›žå¿†ä¸€ä¸‹ Dijkstra æ±‚æœ€çŸ­è·¯çš„æ›´æ–°æ¡ä»¶ï¼Œå¯¹äºŽä¸€æ¡æœ‰å‘è¾¹ $(u,v,w)$ï¼Œæˆ‘ä»¬æ›´æ–°åˆ° $v$ çš„æœ€çŸ­è·¯çš„æ¡ä»¶æ˜¯ï¼š$$dist[v] &gt; dist[u] + w$$åœ¨æœ€çŸ­è·¯è®¡æ•°çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥ç”¨åŠ¨æ€è§„åˆ’çš„æ€æƒ³ï¼Œè®° $num[x]$ è¡¨ç¤ºåˆ° $x$ çš„æœ€çŸ­è·¯çš„æ•°é‡ï¼Œé‚£ä¹ˆï¼š è‹¥ $dist[v] = dist[u] + w$ æˆ‘ä»¬æ›´æ–° $num[v] = num[v] + num[u]$ï¼Œå³æœ‰å¦å¤–ä¸€æ¡è·¯å¾„ã€‚ è‹¥ $dist[v] &gt; dist[u] + w$ æˆ‘ä»¬æ›´æ–° $num[v] = num[u]$ï¼Œå³æœ‰æ›´çŸ­çš„è·¯å¾„ï¼Œå‰é¢çš„å…¨éƒ¨ä½œåºŸã€‚ æ‰€ä»¥è¿™é“é¢˜çš„ä»£ç å°±å‘¼ä¹‹æ¬²å‡ºäº†ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;#define maxm 2000010#define maxn 1000010#define modn 100003#define INF 0x7f7f7f7fstruct heapNode &#123; int u, d; bool operator&lt;(const heapNode &amp;b) const &#123; return d &gt; b.d; &#125; // è¿™é‡Œä¼¼ä¹Žæ˜¯ä¸€å®šè¦åŠ  constï¼Œå¦åˆ™ä¼š CE&#125;;struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125; edges[maxm &lt;&lt; 1];int numEdges = 0, heads[maxn];priority_queue&lt;heapNode&gt; Q;int dist[maxn], num[maxn];int n, m, x, y;void init() &#123; numEdges = 0; memset(heads, -1, sizeof(heads)); memset(dist, INF, sizeof(dist)); memset(num, 0, sizeof(num)); while (!Q.empty()) Q.pop();&#125;void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125;void Dijkstra(int x) &#123; dist[x] = 0; num[x] = 1; Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int d = f.d; if (d != dist[u]) continue; for (int i = heads[u]; i != -1; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] == dist[u] + w) &#123; num[j] += num[u]; // æ›´æ–°æƒ…å†µä¸€ num[j] %= modn; // é¢˜ç›®è¦æ±‚å–æ¨¡ &#125; else if (dist[j] &gt; dist[u] + w) &#123; num[j] = num[u]; // æ›´æ–°æƒ…å†µäºŒ dist[j] = dist[u] + w; Q.push((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; init(); for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; if (x == y) continue; addDuplexEdge(x, y, 1); &#125; Dijkstra(1); for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; num[i] &lt;&lt; endl; &#125; return 0;&#125; æ€»ç»“ç”±è¿™ä¸ªæœ€çŸ­è·¯è®¡æ•°æˆ‘ä»¬å¯ä»¥çœ‹å‡ºåŠ¨æ€è§„åˆ’å®žåœ¨æ˜¯å®žç”¨å•Šï¼]]></content>
      <categories>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
        <tag>æœ€çŸ­è·¯è®¡æ•°</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[å¹³è¡¡æ ‘] Treap æ€»ç»“]]></title>
    <url>%2F2018%2F08%2F25%2F%E5%B9%B3%E8%A1%A1%E6%A0%91-Treap-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢ä¸ºäº†ç»§ç»­å®Œå–„è‡ªå·±çš„æ•°æ®ç»“æž„æœ‰å…³çš„çŸ¥è¯†ï¼Œå†³å®šå…ˆæ€»ç»“ä¸€æ³¢ Treapã€‚Treap æ˜¯æˆ‘å­¦çš„ç¬¬ä¸€ä¸ªå¹³è¡¡æ ‘ç»“æž„ï¼ŒèŠ±äº†å¾ˆé•¿æ—¶é—´æ‰æŠŠæ¿å­èƒŒä¸‹æ¥æŠŠå®ƒçœŸæ­£ç†è§£äº†ï¼Œä¸ç¦æ„Ÿå¹æ•°æ®ç»“æž„çœŸçš„æ˜¯ç¥žå¥‡å•Šï¼ BST äºŒå‰æŸ¥æ‰¾æ ‘çš„æ€§è´¨å› ä¸ºæƒ³é‡ç‚¹æ€»ç»“çš„æ˜¯ Treap è€Œä¸æ˜¯æ™®é€š BSTï¼Œæ‰€ä»¥è¿™é‡Œåªç¨å¾®æä¸€ä¸‹å®ƒçš„æ€§è´¨ï¼š è‹¥ä»»æ„èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å°äºŽå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼› è‹¥ä»»æ„èŠ‚ç‚¹çš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼å‡å¤§äºŽå®ƒçš„æ ¹èŠ‚ç‚¹çš„å€¼ï¼› ä»»æ„èŠ‚ç‚¹çš„å·¦ã€å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¸ºäºŒå‰æŸ¥æ‰¾æ ‘ï¼› æ²¡æœ‰é”®å€¼ç›¸ç­‰çš„èŠ‚ç‚¹ã€‚ BST æ˜¯ Treap å­¦ä¹ çš„åŸºç¡€ï¼Œæ›´å¤šå†…å®¹å¯ä»¥çœ‹è¿™ç¯‡åšå®¢ã€‚ä¸Šé¢è¿™äº›æ€§è´¨ï¼Œå¯ä»¥ä½¿å¾—åœ¨ BST ä¸ŠæŸ¥æ‰¾å‰é©± / åŽç»§æ›´ä¸ºæ–¹ä¾¿ã€‚è¿™äº›æ€§è´¨æ˜¯æž„å»º BST çš„åŸºç¡€ï¼Œä½†æ˜¯ä¹Ÿä½¿å¾— BST ä¸èƒ½å¾ˆå¥½åœ°ä¿æŒæ ‘çš„å¹³è¡¡ï¼Œå³å·¦å³å­æ ‘çš„å¤§å°ç›¸å·®å¤ªå¤§ï¼Œæœ€æžç«¯çš„æƒ…å†µå°±æ˜¯ä¸€æ¡é“¾ï¼Œä¸ºäº†ä¿æŒ BST çš„å¹³è¡¡ï¼Œè¯žç”Ÿäº†å„ç§å¹³è¡¡æ ‘ã€‚ TreapZig å’Œ Zagä¿æŒ Treap å¹³è¡¡çš„æ–¹å¼å°±æ˜¯æ”¹å˜ Treap çš„å½¢æ€ï¼ŒåŒæ—¶åˆå¿…é¡»ä¿è¯ Treap ä»ç„¶å…·å¤‡ BST çš„æ€§è´¨ï¼ŒäºŽæ˜¯ Zig å’Œ Zag æ“ä½œå°±è¯žç”Ÿäº† å¯è§è¿™å¹¶ä¸æ˜¯ç®€å•çš„æ—‹è½¬ï¼Œå®ƒè¿˜å°†æŸä¸ªèŠ‚ç‚¹å‘æ ¹èŠ‚ç‚¹ç§»åŠ¨ï¼Œè¿™ä¸ªè¿‡ç¨‹åªå¯æ„ä¼šä¸å¯è¨€ä¼ ï¼Œè¿˜æ˜¯å¥½å¥½ç†è§£ä¸Šå›¾ã€‚æ—‹è½¬çš„ä»£ç å®žçŽ°å¦‚ä¸‹ï¼š12345678910111213void zig(int &amp;p) &#123; int q = treap[p].lChild; treap[p].lChild = treap[q].rChild; treap[q].rChild = p; p = q;&#125;void zag(int &amp;p) &#123; int q = treap[p].rChild; treap[p].rChild = treap[q].lChild; treap[q].lChild = p; p = q;&#125; ä¿è¯ Treap çš„å¹³è¡¡ä»€ä¹ˆæ ·çš„æ—‹è½¬æ‰èƒ½ä¿è¯å®ƒçš„å¹³è¡¡å‘¢ï¼ŸTreap æ˜¯ Tree å’Œ Heap çš„å¤åˆåè¯ï¼Œæ‰€ä»¥å®ƒè¿˜æ»¡è¶³å †æ€§è´¨ã€‚å®ƒåˆ©ç”¨â€œéšæœºâ€æ¥åˆ›é€ å¹³è¡¡çš„æ¡ä»¶ï¼Œæ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªéšæœºç”Ÿæˆçš„é¢å¤–æƒå€¼ï¼ŒTreap åœ¨æ»¡è¶³ BST æ€§è´¨çš„åŒæ—¶è¿˜é€šè¿‡æ—‹è½¬ä½¿å¾—æƒå€¼æ»¡è¶³å¤§æ ¹å †çš„æ€§è´¨ã€‚ç‰¹åˆ«çš„ï¼Œåœ¨åˆ é™¤ Treap çš„èŠ‚ç‚¹æ—¶ï¼Œå¯ä»¥ç›´æŽ¥æŠŠè¿™ä¸ªèŠ‚ç‚¹æ—‹è½¬åˆ°å¶èŠ‚ç‚¹æ¥ç›´æŽ¥åˆ é™¤ï¼Œè¿™æ ·å°±å…åŽ»äº†å¾ˆå¤šå¤æ‚çš„æ“ä½œã€‚ ä»Žä¸€é“ä¾‹é¢˜çœ‹ä»£ç å®žçŽ°é¢˜ç›®åœ¨è¿™ï¼šæ´›è°· P3369 ã€æ¨¡æ¿ã€‘æ™®é€šå¹³è¡¡æ ‘ å› ä¸ºé¢˜ç›®ä¸­åŒä¸€ä¸ªèŠ‚ç‚¹å¯èƒ½æœ‰å¤šä¸ªï¼Œæ‰€ä»¥å¯ä»¥ä¸ºæ¯ä¸ªèŠ‚ç‚¹å¢žåŠ ä¸€ä¸ªâ€œå‰¯æœ¬æ•°â€ï¼ŒåŒæ—¶åœ¨èŽ·å– Rank çš„æ—¶å€™åˆ«å¿˜äº†å‡ä¸€ï¼Œå› ä¸ºåˆå§‹åŒ–çš„æ—¶å€™æœ‰ä¸€ä¸ªæ­£æ— ç©·ï¼Œä¸€ä¸ªè´Ÿæ— ç©·ï¼Œå®ƒä»¬åªæ˜¯ä¸ºäº†ä¿è¯ BST æ€§è´¨ï¼Œå¹¶ä¸æ˜¯å®žé™…çš„èŠ‚ç‚¹ã€‚ ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 100010#define INF 0x7fffffffstruct treapNode &#123; int lChild, rChild; // å·¦å³å­èŠ‚ç‚¹ä¸‹æ ‡ int value, weight; // èŠ‚ç‚¹å…³é”®ç åŠæƒå€¼ int count, size; // å‰¯æœ¬æ•°åŠå­æ ‘å¤§å°&#125; treap[maxn];int numNodes, root, n;int newNode(int val) &#123; numNodes++; treap[numNodes].value = val; treap[numNodes].weight = rand(); // éšæœºæƒå€¼ treap[numNodes].count = treap[numNodes].size = 1; return numNodes;&#125; // å»ºç«‹ä¸€ä¸ªæ–°çš„èŠ‚ç‚¹void update(int p) &#123; treap[p].size = treap[treap[p].lChild].size + treap[treap[p].rChild].size + treap[p].count;&#125; // æ›´æ–°æŸä¸€ä¸ªç‚¹çš„ size æ–¹ä¾¿èŽ·å–æŽ’åvoid build() &#123; newNode(-INF); // ä¿è¯ BST æ€§è´¨çš„ä¸¤ä¸ªç‚¹ newNode(INF); root = 1; treap[root].rChild = 2; update(root);&#125; // åˆå§‹åŒ–int getRankByVal(int p, int val) &#123; if (p == 0) return 0; if (val == treap[p].value) return treap[treap[p].lChild].size + 1; if (val &lt; treap[p].value) return getRankByVal(treap[p].lChild, val); return getRankByVal(treap[p].rChild, val) + treap[treap[p].lChild].size + treap[p].count;&#125;// ä¸Šä¸‹ä¸¤ä¸ªå‡½æ•°å¾ˆå¥½ç†è§£ï¼Œä¸ä½œèµ˜è¿°// ä¸€åˆ‡ä»Ž BST æ€§è´¨å‡ºå‘int getValByRank(int p, int rnk) &#123; if (p == 0) return INF; if (treap[treap[p].lChild].size &gt;= rnk) return getValByRank(treap[p].lChild, rnk); if (treap[treap[p].lChild].size + treap[p].count &gt;= rnk) return treap[p].value; return getValByRank(treap[p].rChild, rnk - treap[treap[p].lChild].size - treap[p].count);&#125;void zig(int &amp;p) &#123; int q = treap[p].lChild; treap[p].lChild = treap[q].rChild; treap[q].rChild = p; p = q; update(treap[p].rChild); update(p); // åˆ«å¿˜è®°æ›´æ–°&#125;void zag(int &amp;p) &#123; int q = treap[p].rChild; treap[p].rChild = treap[q].lChild; treap[q].lChild = p; p = q; update(treap[p].lChild); update(p);&#125;void insert(int &amp;p, int val) &#123; if (p == 0) &#123; p = newNode(val); return; &#125; if (val == treap[p].value) &#123; treap[p].count++; update(p); return; &#125; if (val &lt; treap[p].value) &#123; insert(treap[p].lChild, val); if (treap[p].weight &lt; treap[treap[p].lChild].weight) zig(p); &#125; else &#123; insert(treap[p].rChild, val); if (treap[p].weight &lt; treap[treap[p].rChild].weight) zag(p); &#125; // zig å’Œ zag æ“ä½œï¼Œä¿è¯æ»¡è¶³å¤§æ ¹å †æ€§è´¨ update(p);&#125; // æ’å…¥ä¸€ä¸ªç‚¹int getPre(int val) &#123; int ans = 1; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].lChild &gt; 0) &#123; p = treap[p].lChild; // å·¦å­æ ‘ä¸Šä¸æ–­å‘å³èµ°ï¼ŒèŽ·å–æœ€å¤§çš„å‰é©± while (treap[p].rChild &gt; 0) p = treap[p].rChild; ans = p; &#125; break; &#125; if (treap[p].value &lt; val &amp;&amp; treap[p].value &gt; treap[ans].value) ans = p; // å°è¯•æ›´æ–°ç­”æ¡ˆ p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125; // èŽ·å–å‰é©±int getNext(int val) &#123; int ans = 2; int p = root; while (p != 0) &#123; if (val == treap[p].value) &#123; if (treap[p].rChild &gt; 0) &#123; p = treap[p].rChild; // å³å­æ ‘ä¸Šä¸æ–­å‘å·¦èµ°ï¼ŒèŽ·å–æœ€å°çš„åŽç»§ while (treap[p].lChild &gt; 0) p = treap[p].lChild; ans = p; &#125; break; &#125; if (treap[p].value &gt; val &amp;&amp; treap[p].value &lt; treap[ans].value) ans = p; // å°è¯•æ›´æ–°ç­”æ¡ˆ p = val &lt; treap[p].value ? treap[p].lChild : treap[p].rChild; &#125; return treap[ans].value;&#125;void remove(int &amp;p, int val) &#123; if (p == 0) return; if (val == treap[p].value) &#123; if (treap[p].count &gt; 1) &#123; treap[p].count--; update(p); &#125; else if (treap[p].lChild != 0 || treap[p].rChild != 0) &#123; if (treap[p].rChild == 0 || treap[treap[p].lChild].weight &gt; treap[treap[p].rChild].weight) &#123; zig(p); remove(treap[p].rChild, val); &#125; else &#123; zag(p); remove(treap[p].lChild, val); &#125; // é€šè¿‡æ—‹è½¬æ¥åˆ é™¤èŠ‚ç‚¹ update(p); &#125; else p = 0; return; &#125; if (val &lt; treap[p].value) remove(treap[p].lChild, val); else remove(treap[p].rChild, val); update(p);&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(NULL); numNodes = 0; build(); cin &gt;&gt; n; int opt, x; while (n--) &#123; cin &gt;&gt; opt &gt;&gt; x; switch (opt) &#123; case 1: &#123; insert(root, x); break; &#125; case 2: &#123; remove(root, x); break; &#125; case 3: &#123; cout &lt;&lt; getRankByVal(root, x) - 1 &lt;&lt; endl; break; &#125; // å‡ä¸€ case 4: &#123; cout &lt;&lt; getValByRank(root, x + 1) &lt;&lt; endl; break; &#125; // åŠ ä¸€ case 5: &#123; cout &lt;&lt; getPre(x) &lt;&lt; endl; break; &#125; case 6: &#123; cout &lt;&lt; getNext(x) &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125; æ€»ç»“ç­é‡Œçš„æŸä¸ªå¤§ä½¬å’Œæˆ‘è¯´ Treap æ²¡æœ‰ ZigZagï¼Œè¿™è®©æˆ‘å¾ˆæ‡µé€¼ã€‚ä½†æ˜¯ Zig å’Œ Zag æ“ä½œçš„ç¡®æ˜¯å¾ˆé‡è¦çš„ï¼Œä¼¼ä¹Žåœ¨å­¦ Splay çš„æ—¶å€™ä¹Ÿä¼šç”¨åˆ°ï¼Œå¤šå­¦æ— å®³ã€‚Treap è¿˜æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œå…³é”®æ—¶å€™å¯ä»¥æ•‘å‘½ã€‚]]></content>
      <categories>
        <category>å¹³è¡¡æ ‘</category>
      </categories>
      <tags>
        <tag>æ ‘å½¢ç»“æž„</tag>
        <tag>Treap</tag>
        <tag>å¹³è¡¡æ ‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[æ•°è®º] OI ä¸­ç´ æ•°æœ‰å…³çš„ç®—æ³•æ•´ç†]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%95%B0%E8%AE%BA-OI-%E4%B8%AD%E7%B4%A0%E6%95%B0%E6%9C%89%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢æœ¬æ¥æ˜¯æƒ³æ€»ç»“ä¸€é“æ•°è®ºç¥žé¢˜çš„ï¼Œä½†æ˜¯æ€Žä¹ˆè¯æ˜Žä¼¼ä¹Žéƒ½ä¸æ˜¯å¾ˆå®Œç¾Žï¼Œè€Œä¸”ä»£ç çš„å®žçŽ°æ¶‰åŠåˆ°å¾ˆå¤šæ•°è®ºæœ‰å…³çš„ç®—æ³•ï¼ŒäºŽæ˜¯æƒ³çŽ°æ€»ç»“ä¸€ä¸‹ä¸Žç´ æ•°æœ‰å…³çš„ç®—æ³•ã€‚ ç´ æ•°çš„åˆ¤å®šBrute-Force æœ´ç´ ç®—æ³•é¢ï¼Œè¿™ä¸ªå°±ä¸å¤šè¯´äº†å§ï¼Œæœ€æ— è„‘çš„ï¼Œ$2\thicksim n$ æžšä¸¾æ‰€æœ‰å°äºŽ $n$ çš„æ•°æ¥è¿›è¡Œåˆ¤å®šã€‚ 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;bool isPrime(int n) &#123; if (n == 2) return true; for (int i = 2; i &lt; n; ++i) if (n % i == 0) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (isPrime(n) ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; Optimized-Brute-Force ä¼˜åŒ–è¿‡çš„æœ´ç´ ç®—æ³•å¦‚æžœä¸€ä¸ªæ•°ä¸æ˜¯ç´ æ•°æ˜¯åˆæ•°ï¼Œ é‚£ä¹ˆä¸€å®šå¯ä»¥ç”±ä¸¤ä¸ªå¤§äºŽ $1$ è‡ªç„¶æ•°ç›¸ä¹˜å¾—åˆ°ï¼Œ å…¶ä¸­ä¸€ä¸ªå¤§äºŽæˆ–ç­‰äºŽå®ƒçš„å¹³æ–¹æ ¹ï¼Œä¸€ä¸ªå°äºŽæˆ–ç­‰äºŽå®ƒçš„å¹³æ–¹æ ¹ã€‚å¹¶ä¸”æˆå¯¹å‡ºçŽ°ã€‚æ‰€ä»¥å¯ä»¥ä¼˜åŒ–æœ´ç´ ç®—æ³• 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;bool isPrime(int n) &#123; if (n == 2) return true; for (int i = 2; i * i &lt; n; ++i) if (n % i == 0) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; (isPrime(n) ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; ç­›æ³•æ±‚ç´ æ•°ä¸Šé¢ä¸¤ä¸ªèœé¸¡æ–¹æ³•åªèƒ½é’ˆå¯¹æ•°å¾ˆå°çš„æƒ…å†µï¼Œè¿™äº›æƒ…å†µåœ¨ OI ä¸­å‡ºçŽ°çš„è¯å‡ºå·è€å¸ˆä¼šæ­»å¾—å¾ˆæƒ¨å˜æˆå¹¿å¤§ OIer çš„æ©äººï¼Œç„¶è€Œè¿™ç§æƒ…å†µæ˜¯ä¸å¯èƒ½çš„ã€‚äºŽæ˜¯åˆæœ‰äº†æ›´é«˜æ•ˆçš„æ–¹æ³•â€”â€”ç­›æ³•ã€‚å®ƒçš„æ€æƒ³å°±æ˜¯å°†ä¸€ä¸ªèŒƒå›´å†…çš„ç´ æ•°å…¨éƒ¨ç­›å‡ºæ¥ï¼Œé¢„å¤„ç†ä¹‹åŽæ–¹ä¾¿æŸ¥æ‰¾å’Œåˆ¤å®šã€‚æœ€æœ´ç´ çš„ç­›æ³•èŽ«è¿‡äºŽ Eratosthenes ç­›æ³•äº†ï¼ˆä¸è¦çº ç»“è¿™ä¸ªåå­—æ€Žä¹ˆè¯»ï¼Œå› ä¸ºæˆ‘ä¹Ÿä¸ä¼šï¼‰ï¼Œå®ƒæ˜¯å°†æ‰€æœ‰ç´ æ•°çš„å€æ•°éƒ½ç»™ç­›æŽ‰ï¼Œå‰©ä¸‹çš„å°±æ˜¯ç´ æ•°äº†ã€‚æ—¶é—´å¤æ‚åº¦ä¸º $O(N\log\log N)$ æŽ¥è¿‘çº¿æ€§ 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1000010bool prime[maxn];void Eratosthenes() &#123; memset(prime, true, sizeof(prime)); prime[1] = false; for (int i = 2; i &lt;= maxn; ++i) &#123; if (!prime[i]) continue; for (int j = i; j &lt;= maxn / i; ++j) &#123; // è¿™é‡Œæ˜¯ä¸€ä¸ªå°ä¼˜åŒ–ï¼Œå› ä¸ºå°äºŽ i^2 çš„æ•°åœ¨å‰é¢è‚¯å®šå·²ç»ç­›è¿‡äº† // æ‰€ä»¥ j ä»Ž i å¼€å§‹å– prime[j * i] = false; &#125; &#125;&#125;int main() &#123; int n; Eratosthenes(); cin &gt;&gt; n; cout &lt;&lt; (prime[n] ? "Yes" : "No") &lt;&lt; endl; return 0;&#125; ç„¶è€Œï¼ŒEratosthenes ç­›ä¼šé‡å¤æ ‡è®°ç´ æ•°ï¼Œé€ æˆæ—¶é—´å¤æ‚åº¦å†—ä½™ï¼Œå¦‚æžœå¯¹äºŽæ¯ä¸ªæ•°æœ‰å”¯ä¸€çš„æ–¹æ³•ç¡®å®šå®ƒï¼Œé‚£ä¹ˆå°±å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ç”±æ­¤å¼•å‡ºäº†çº¿æ€§ç­›è¿™ä¸ªæ–¹æ³•ï¼Œå®ƒé€šè¿‡ä»Žå¤§åˆ°å°ç´¯è®¡è´¨å› å­çš„æ–¹æ³•æ ‡è®°æ¯ä¸€ä¸ªåˆæ•°ï¼Œå³è®© $12$ åªæœ‰ $2\times 2\times 3$ è¿™ç§äº§ç”Ÿæ–¹å¼ã€‚è®¾æ•°ç»„ $fac$ è®°å½•æ¯ä¸ªæ•°çš„æœ€å°è´¨å› å­ï¼Œæˆ‘ä»¬æŒ‰ç…§ä¸‹é¢çš„æ­¥éª¤æ¥ç»´æŠ¤ $fac$ï¼š ä¾æ¬¡è€ƒè™‘ $1\thicksim n$ ä¹‹è§çš„æ¯ä¸€ä¸ªæ•° $i$ è‹¥ $fac[i]=i$ è¯´æ˜Ž $i$ æ˜¯è´¨æ•°ï¼Œå°†å®ƒä¿å­˜ä¸‹æ¥ æ‰«æä¸å¤§äºŽ $fac[i]$ çš„æ¯ä¸ªè´¨æ•° $p$ï¼Œä»¤ $fac[i\times p]=p$ï¼Œå³åœ¨ $i$ çš„åŸºç¡€ä¸Šç´¯ç§¯ä¸€ä¸ªè´¨å› å­ $p$ï¼Œå› ä¸º $p\leqslant fac[i]$ï¼Œæ‰€ä»¥ $p$ ä¸ºåˆæ•° $i\times p$ çš„æœ€å°è´¨å› å­ã€‚ è¿™æ ·å­ï¼Œæ¯ä¸ªåˆæ•°åªä¼šè¢«å®ƒçš„æœ€å°è´¨å› å­ $p$ ç­›ä¸€æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºçº¿æ€§ã€‚ 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1000010int fac[maxn], prime[maxn];void LinearSieve(int n) &#123; memset(fac, 0, sizeof(fac)); int m = 0; for (int i = 2; i &lt;= n; ++i) &#123; if (fac[i] == 0) &#123; fac[i] = i; prime[++m] = i; &#125; for (int j = 1; j &lt;= m; ++j) &#123; // è·³å‡ºå¾ªçŽ¯çš„æ¡ä»¶ if (prime[j] &gt; fac[i] || prime[j] &gt; n / i) break; fac[i * prime[j]] = prime[j]; &#125; &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; prime[i] &lt;&lt; " ";&#125;int main() &#123; int n; LinearSieve(100000); return 0;&#125; çº¿æ€§ç­›åˆåæ¬§æ‹‰ç­›ã€‚ ä¼ªç´ æ•°æµ‹è¯•åœ¨å¼€å§‹ Miller-Rabin ç®—æ³•ä¹‹å‰æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹ä¼ªç´ æ•°æµ‹è¯•ï¼Œé¦–å…ˆè¦äº†è§£è´¹é©¬å°å®šç†ï¼š $a^{p-1}\equiv1(\bmod p)$ å½“ $p$ ä¸ºç´ æ•°æ—¶ä¸” $gcd(a,p)=1$ æ—¶ã€‚è´¹é©¬å°å®šç†çš„é€†å‘½é¢˜è™½ç„¶ä¸æ˜¯çœŸå‘½é¢˜ï¼Œä½†æ˜¯å‡ ä¹Žæˆç«‹ï¼Œè€Œä¸æˆç«‹çš„æ—¶å€™ï¼Œå³å¦‚æžœ $n$ æ˜¯ä¸€ä¸ªåˆæ•°ä¸” $a^{n-1}\equiv 1(\bmod n)$ï¼Œé‚£ä¹ˆç§° $n$ ä¸ºåŸºä¸º $a$ çš„ä¼ªç´ æ•°ã€‚å¦‚æžœæˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ª $a$ ä½¿å¾— $n$ ä¸æ»¡è¶³ä¸Šè¿°ç­‰å¼ï¼Œé‚£ä¹ˆ $n$ å¿…å®šä¸ºåˆæ•°ï¼Œé‚£å¦‚æžœæ»¡è¶³å‘¢ï¼Ÿ$n$ ä¸ä¸€å®šæ˜¯ç´ æ•°ï¼Œè¿™æ ·çš„æ•°è¢«ç§°ä½œ Carmicheal æ•°ï¼Œä½†æ˜¯è¿™ç§æ•°ååˆ†ç¨€å°‘ï¼Œå‰ $10000$ ä¸ª $n$ ä¸­åªæœ‰ $22â€‹$ ä¸ªæ•°ä¸º Carmicheal æ•°ï¼Œæ‰€ä»¥è¿™ç§æ–¹æ³•è¿˜æ˜¯æ¯”è¾ƒå¯é çš„ã€‚é™„ä¸Šç®—æ³•å¯¼è®ºä¸­çš„ä¼ªä»£ç ï¼š å› ä¸º Carmicheal æ•°çš„å­˜åœ¨ï¼Œäººä»¬å¯»æ±‚æ›´å¥½çš„ï¼Œæ›´å‡†ç¡®çš„ç´ æ•°åˆ¤å®šæ–¹æ³•ï¼ŒäºŽæ˜¯å°±æœ‰äº† Miller-Rabin ç®—æ³• Miller-Rabin ç®—æ³•é€šè¿‡è´¹é©¬å°å®šç†æˆ‘ä»¬å¯ä»¥å¾—å‡ºä¸€ä¸ªæŽ¨è®ºï¼Œè‹¥ $p$ ä¸ºä¸€ä¸ªå¥‡ç´ æ•°ï¼Œé‚£ä¹ˆæœ‰ï¼š$$a^p\equiv a\pmod p,1\leqslant a\leqslant p$$ æˆ‘ä»¬è®°$$p-1=2^kq,2\nmid q$$è®¾ $a$ æ˜¯ä¸è¢« $p$ æ•´é™¤çš„æ•°ï¼Œé‚£ä¹ˆä¸‹é¢ä¸¤ä¸ªæ¡ä»¶ä¹‹ä¸€å¿…ç„¶æˆç«‹ï¼š $a^q \equiv 1 \pmod p$ $a^q, a^{2q}, a^{2^2q}, \dots, a^{2^{k-1}q} \equiv -1 \pmod p$ ä¹‹ä¸­æœ‰ä¸€ä¸ªç­‰å¼æˆç«‹ æ ¹æ®å¦‚ä¸‹å‘½é¢˜ï¼š$$a^2 \equiv 1 \pmod p \Rightarrow a \equiv \pm 1 \pmod p$$åˆå› ä¸ºä¸Šé¢ç¬¬äºŒä¸ªæ¡ä»¶ä¸­çš„æ•°ï¼Œæ¯ä¸€ä¸ªéƒ½æ˜¯å‰ä¸€ä¸ªçš„å¹³æ–¹ï¼Œä¸”æœ€åŽä¸€ä¸ªæ•°çš„å¹³æ–¹æ˜¯ $1$ï¼Œæ‰€ä»¥å¦‚æžœè¡¨ä¸­ä¸€ä¸ªæ•°å®ƒæ¨¡ $p$ ä¸ä½™ $1$ï¼Œä½†æ˜¯å®ƒçš„å¹³æ–¹æ¨¡ $p$ ä½™ $1$ï¼Œé‚£ä¹ˆé‚£ä¸ªæ•°ä¸€å®šæ˜¯ $-1$ï¼Œæ‰€ä»¥åœ¨è¿™ç§æƒ…å†µä¸‹è¡¨ä¸­åŒ…å« $ -1$ï¼Œåˆæˆ–è€…è¡¨ä¸­å…¨æ˜¯ $1$ï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªæ¡ä»¶å°±ä¼šæˆç«‹ã€‚ æ‰€ä»¥æˆ‘ä»¬å¾—åˆ°äº† Miller-Rabin ç´ æ€§æµ‹è¯•çš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æžœä¸€ä¸ªæ•°ä¸æ»¡è¶³ä¸Šé¢çš„æ€§è´¨ï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯å’Œæ•°ï¼Œè¿™ä¸ª $a$ å°±æˆä¸ºè¯æ®ã€‚è€Œ Miller-Rabin çš„è¯æ®å’Œä¸Šé¢æåˆ°çš„æ–¹æ³•çš„è¯æ®ä¸åŒï¼Œå®ƒèƒ½å¤Ÿä¿è¯æ¯ä¸€ä¸ªå¥‡åˆæ•° $p$ éƒ½ä¼šæœ‰ä¸å°‘äºŽ $\frac{(pâˆ’1)}{2}$ä¸ªè¯æ®ï¼ˆå…·ä½“è¯æ˜Žè¯¦è§ç®—æ³•å¯¼è®ºï¼‰ã€‚ æˆ‘ä»¬åªè¦éšæœº $50$ ä¸ªæ•°æ¥æµ‹è¯•ï¼Œé‚£ä¹ˆæµ‹è¯•å¤±è´¥çš„æ¦‚çŽ‡ä¸€å®šå°äºŽ $2^{âˆ’50}$ï¼Œå¤§çº¦æ˜¯ $8.9â‹…10^{âˆ’16}$ï¼Œå¦‚æžœä½ è§‰å¾—ä¸å¤Ÿï¼Œè¿˜å¯ä»¥æ‰¾æ›´å¤šçš„æ•°æ¥æµ‹è¯•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long int64;inline int64 rand64() &#123; return abs((int64)rand() &lt;&lt; 32 | rand()); &#125;inline int64 random(int64 x, int64 y) &#123; return x + rand64() % (y - x + 1); &#125;// éšæœºæ•°ç”Ÿæˆå‡½æ•°int64 montgomery(int64 a, int64 b, int64 c) &#123; int64 result = 1; int64 temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;bool witness(int64 a, int64 p) &#123; int k = 0; int64 q = p - 1; while ((q &amp; 1) == 0) &#123; k++; q &gt;&gt;=1; &#125; int64 v = montgomery(a, q, p); // åˆ¤æ–­ä¸€ if (v == 1 || v == p - 1) return false; while (k--) &#123; v = v * v % p; if (v == p - 1) return false; // åˆ¤æ–­äºŒ &#125; return true;&#125;bool MillerRabin(int64 p) &#123; if (p == 1) return false; if (p == 2) return true; if (p % 2 == 0) return false; // è¿™é‡Œå…¶å®žå¯ä»¥åŠ æ›´å¤šçš„ç‰¹åˆ¤æ¥èŠ‚çº¦æ—¶é—´ for (int i = 1; i &lt;= 50; ++i) if (witness(random(1, p - 1), p)) return false; return true;&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) if (MillerRabin(i)) cout &lt;&lt; i &lt;&lt; " "; // è¾“å‡º 1 ~ n ä¹‹é—´çš„æ‰€æœ‰ç´ æ•° return 0;&#125; å¯¹äºŽå¤§çš„ç´ æ•°ï¼Œä¸ºäº†èŠ‚çº¦åˆ¤å®šçš„æ—¶é—´ï¼Œæˆ‘ä»¬åªèƒ½é€€è€Œæ±‚å…¶æ¬¡é€‰æ‹©éžå®Œç¾Žç®—æ³•æ¥è¿›è¡ŒéªŒè¯ï¼Œä¸è¿‡ä¸å¾—ä¸è¯´ï¼ŒMiller-Rabin å…¶å®žå·²ç»å¾ˆå®Œå¤‡äº†ã€‚ æ€»ç»“äº‹å®žä¸Šï¼Œå¯¹äºŽç´ æ•°çš„åˆ¤å®šè¿˜æœ‰å¾ˆå¤šç®—æ³•ï¼Œä¾‹å¦‚ Solovay-Strassen ç®—æ³•å’Œ AKS ç®—æ³•ï¼Œç„¶è€Œè¿™ä¸¤ä¸ªä¼¼ä¹Žéƒ½è¶…å‡ºäº† OI çš„èŒƒå›´ï¼Œä¸€èˆ¬ä¸ä¼šç”¨å¾—åˆ°ï¼Œè¿™é‡Œä¹Ÿå°±ä¸å†èµ˜è¿°ã€‚ è´¨å› æ•°åˆ†è§£è¯•é™¤æ³•ç»“åˆç´ æ•°åˆ¤å®šçš„â€œè¯•é™¤æ³•â€å’Œâ€œEratosthenes ç­›æ³•â€ï¼Œæˆ‘ä»¬å¯ä»¥æ‰«æ $2\thicksim\lfloor\sqrt{n}\rfloor$ ä¸­çš„æ¯ä¸ªæ•° $d$ï¼Œè‹¥ $d$ èƒ½æ•´é™¤ $n$ï¼Œåˆ™ä»Ž $n$ ä¸­é™¤æŽ‰æ‰€æœ‰çš„å› å­ $d$ï¼ŒåŒæ—¶ç´¯è®¡ä¸ªæ•°ã€‚ 12345678910111213int p[maxn], c[maxn];void divide(int n) &#123; int m = 0; for (int i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; p[++m] = i; c[m] = 0; while (n % i == 0) &#123; n /= i; c[m]++; &#125; &#125; &#125; if (n &gt; 1) &#123; p[++m] = n; c[m] = 1 &#125; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; p[i] &lt;&lt; '^' &lt;&lt; c[i] &lt;&lt; endl;&#125; Pollard-Rho ç®—æ³•Pollard-Rho ä¹Ÿæ˜¯ä¸€ä¸ªä¸å®Œç¾Žç®—æ³•ï¼Œä¸å®Œç¾Žä¹‹å¤„åœ¨æ—¶é—´å¤æ‚åº¦ä¸Šä½“çŽ°ã€‚Pollard-Rhoç®—æ³•åˆ†è§£ä¸€ä¸ªæ•° $n$ çš„è¿‡ç¨‹å¤§ä½“ä¸Šæ˜¯è¿™æ ·å­çš„ï¼š æ‰¾åˆ°ä¸€ä¸ªæ•° $p$ï¼Œä½¿å¾— $p|n$ï¼Œå°† $n$ åˆ†è§£ä¸º $p$ ä¸Ž $\frac{n}{p}$ å¦‚æžœ $p$ æˆ– $\frac{n}{p}$ ä¸ä¸ºè´¨æ•°ï¼Œå°†å…¶å¸¦å…¥é€’å½’ä¸Šè¿°è¿‡ç¨‹ å¦‚æžœå…¶æ˜¯è´¨æ•°ï¼Œå°†å…¶è®°å½•å¹¶é€€å‡º é‚£æœ‰äººå°±ä¼šé—®äº†ï¼šè¿™è·Ÿæš´åŠ›åˆ†è§£æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿå¥½åƒæ—¶é—´å¤æ‚åº¦æ¯”æš´åŠ›è¿˜é«˜å•Šï¼ï¼ï¼Ÿï¼Ÿæ‰€ä»¥ï¼Œä¸‹é¢çš„ä¼˜åŒ–æ‰æ˜¯å…³é”®ã€‚ç¬¬ä¸€ä¸ªä¼˜åŒ–ï¼Œä½¿ç”¨ Miller-Rabin åˆ¤å®šå…¶æ˜¯å¦ä¸ºè´¨æ•°ã€‚ç¬¬äºŒä¸ªä¼˜åŒ–æ‰æ˜¯æœ€å…³é”®çš„ï¼šå¯¹äºŽä¸€ä¸ªå¤§æ•´æ•°nï¼Œæˆ‘ä»¬è¦æ‰¾åˆ°ä¸€ä¸ª $p$ æ»¡è¶³ $p|n$ï¼Œè¿™å¦‚åŒå¤§æµ·æžé’ˆã€‚ä½†æ˜¯å¦‚æžœæˆ‘ä»¬è¦æ‰¾å‡º $p_1$ã€$p_2$ï¼Œä½¿å¾— $(|p_1âˆ’p_2|)|n$ï¼Œè¿™çœ‹èµ·æ¥ä¼¼ä¹Žè¦å®¹æ˜“ä¸€äº›ã€‚å®žé™…ä¸Šæˆ‘ä»¬åªéœ€è¦æ‰¾å‡º $\gcd((|p1âˆ’p2|),n)&gt;1$çš„ $p_1$ã€$p_2$ï¼Œåˆ™å…¶ $\gcd$ å€¼è‚¯å®šä¸ºnçš„çº¦æ•°ã€‚è¿™çœ‹èµ·æ¥åˆå®¹æ˜“äº†ä¸€äº›ã€‚å®žé™…ä¸Šï¼Œè¿™è®©æ•´ä¸ªç®—æ³•å®¹æ˜“è®¸å¤šã€‚æ ¹æ®ç”Ÿæ—¥æ‚–è®ºï¼Œè¿™ç§ä¸¤ä¸¤æ¯”è¾ƒçš„æ–¹å¼ï¼Œåœ¨åŠ å…¥æ¯”è¾ƒçš„æ•°è¶Šæ¥è¶Šå¤šçš„æ—¶å€™ï¼Œå…¶æ•ˆçŽ‡ä¼šå¤§å¤§æå‡ï¼Œæ¯”æ‰¾ä¸€ä¸ªæ•°çš„æ•ˆçŽ‡å¿«å¾ˆå¤šã€‚äºŽæ˜¯ï¼Œæ‰¾ $p$ çš„è¿‡ç¨‹å˜æˆäº†è¿™ä¸ªæ ·å­ï¼š æ‰¾åˆ°ä¸€ä¸ªæ•° $p_1$ é€šè¿‡æŸç§çŽ„å­¦æŽ¨å¯¼æ‰‹æ®µæ‰¾å‡ºä¸€ä¸ªä¸Ž $p_1$ å¯¹åº”çš„ $p_2$ åˆ¤æ–­ $\gcd((|p1âˆ’p2|),n)$ æ˜¯å¦å¤§äºŽ $1$ï¼Œä¸å¤§äºŽåˆ™å°† $p_2$ä½œä¸ºæ–°çš„ $p_1$ï¼Œé‡å¤è¿‡ç¨‹ï¼Œå¦åˆ™å°±æ‰¾åˆ°äº† ä¸ºä»€ä¹ˆè¦ç”¨çŽ„å­¦æ‰‹æ®µï¼Ÿå› ä¸ºåªæœ‰é€šè¿‡æŽ¨å¯¼æ‰‹æ®µï¼Œæ‰èƒ½ä¿è¯ä¸åšé‡å¤åˆ¤æ–­ã€‚ç†è®ºä¸Šçš„æŽ¨å¯¼æ‰‹æ®µå¯ä»¥æœ‰å¾ˆå¤šï¼Œä½†å®žé™…ä½¿ç”¨ä¸­ä¸€èˆ¬ä½¿ç”¨å¦‚ä¸‹å…¬å¼æŽ¨å¯¼ï¼š$$p_2=(p_1^2+c)\bmod n$$å…¶ä¸­ $c$ ä¸ºéšæœºå¸¸æ•°ã€‚è¿™ä¸ªå…¬å¼çš„å¥½å¤„: æŽ¨å¯¼å‡ºæ¥çš„ $p_2-p_1$ å·®å€¼åŸºæœ¬ä¸ä¼šç›¸ç­‰ã€‚ å¯ä»¥è¯æ˜Žï¼Œè¯¥æŽ¨å¯¼ç»“æžœä¼šå‡ºçŽ°å¾ªçŽ¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨å‡ºçŽ°å¾ªçŽ¯ä¹‹å‰ï¼Œç»“æžœä¸ä¼šé‡å¤ï¼Œå°‘åšäº†è®¸å¤šæ— ç”¨çš„åˆ¤æ–­ã€‚ å‡ºçŽ°å¾ªçŽ¯äº†æ€Žä¹ˆåŠžï¼Ÿæ¢ä¸€ä¸ªéšæœºå¸¸æ•°å†æžã€‚è¿™å°±æ˜¯è¯¥ç®—æ³•â€œéžå®Œç¾Žâ€çš„åœ°æ–¹ï¼Œæ—¶é—´å¤æ‚åº¦è¦çœ‹è„¸çš„ã€‚é‚£ä¹ˆå¦‚ä½•åˆ¤çŽ¯å‘¢ï¼Ÿè¿™é‡Œä»‹ç»ä¸€ä¸ªç®—æ³•ï¼šFloyd åˆ¤åœˆã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¹‹æ‰€ä»¥ä¸èƒ½ä¸€ä¸ªæ ‡è®°å®šåœ¨åŽŸåœ°ï¼Œæ˜¯å› ä¸ºå¾ªçŽ¯èŠ‚ä¸ä¸€å®šåœ¨å¼€å¤´å°±äº§ç”Ÿï¼Œå¯èƒ½èµ°ç€èµ°ç€æ‰é‡åˆ°å¾ªçŽ¯ã€‚è¿™æ¡è·¯å¾„å°±ç±»ä¼¼äºŽ $\rho$ï¼ŒPollard-Rho ç®—æ³•ä¹Ÿæ˜¯å› æ­¤å¾—åçš„ã€‚é¡ºä¾¿é™„ä¸Šç®—æ³•å¯¼è®ºä¸­çš„ä¸€å¼ çŽ„å­¦å›¾ï¼š æ³¨æ„ï¼Œåœ¨å°æ•°åˆ†è§£çš„æ—¶å€™å°±åˆ«ç”¨è¿™ä¸ªäº†ï¼Œè€è€å®žå®žç”¨è¯•é™¤æ³•å§ã€‚ æœªå®Œå¾…ç»­â€¦â€¦]]></content>
      <categories>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>æ•°è®º</tag>
        <tag>ç´ æ•°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[æ•°è®º] OI ä¸­çš„æ¨¡è¿ç®—è®¡ç®—æ–¹æ³•]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%95%B0%E8%AE%BA-OI-%E4%B8%AD%E7%9A%84%E6%A8%A1%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢æ¨¡è¿ç®—åœ¨ OI ä¸­æ˜¯éžå¸¸ç¥žå¥‡çš„å­˜åœ¨ï¼Œæœ‰æ—¶å€™é¢˜ç›®ä¼šéžå¸¸å¥½ï¼ˆmï¼‰å¿ƒï¼ˆmï¼‰åœ°ï¼ˆpï¼‰è®©æˆ‘ä»¬å°†ç­”æ¡ˆå–æ¨¡ï¼Œç„¶è€Œè®¡ç®—æ¨¡çš„æ–¹æ³•éšç€é¢˜ç›®çš„å˜åŒ–è€Œå˜åŒ–ï¼Œç½‘ä¸Šå¾ˆå¤šåšå®¢åˆå¤ªé›¶æ•£ï¼Œè¿™é‡Œç—›ä¸‹å†³å¿ƒæ€»ç»“ä¸€ä¸‹ã€‚ é¢„å¤‡çŸ¥è¯† æ’ç­‰å¼ï¼š $(a\bmod n)\bmod n=a\bmod n$ å¯¹äºŽæ‰€æœ‰çš„æ­£æ•° $x$ æœ‰ï¼š$n^x\bmod n = 0$ å¦‚æžœ p æ˜¯ä¸€ä¸ªè´¨æ•°ï¼Œä¸”ä¸ä¸º b çš„å› æ•°ï¼Œæ­¤æ—¶ç”±è´¹é©¬å°å®šç†æœ‰ï¼š$ab^{pâˆ’1}\bmod p=a\bmod p$ åˆ†é…å¾‹ $(a-b)\bmod n=(a\bmod n-b\bmod n)\bmod n$ $(a+b)\bmod n=(a\bmod n+b\bmod n)\bmod n$ $ab\bmod n=(a\bmod n)(b\bmod n)\bmod n$ é«˜æ¬¡å¹‚å‡½æ•°çš„å–æ¨¡æš´åŠ›å–æ¨¡æ³•ç”±äºŽæˆ‘ä»¬çš„é«˜æ¬¡å¹‚å‡½æ•°å¾€å¾€æ‹¥æœ‰å¾ˆé«˜çš„å¹‚ï¼Œè€Œæˆ‘ä»¬åœ¨è®¡ç®—æœºä¸­åªæœ‰intã€floatã€doubleã€long longè¿™å‡ ç§å˜é‡ç±»åž‹ï¼Œè¿œè¿œä¸èƒ½æ»¡è¶³æˆ‘ä»¬å¯¹äºŽå¤§æ•°å­—è¿ç®—çš„è¦æ±‚ï¼Œä»Žè€Œå¯¼è‡´æ•°æ®æº¢å‡ºæ— æ³•å®Œæˆè¿ç®—ã€‚æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬éœ€è¦åœ¨æ¯æ¬¡è¿­ä»£å–æ¨¡çš„è¿‡ç¨‹ä¸­è¿›è¡Œå–æ¨¡è¿ç®—ï¼Œä»Žè€Œä¿è¯æ•°æ®ä¸ä¼šæº¢å‡ºã€‚ä»£ç å¦‚ä¸‹ï¼š1234567long long pow(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; while (b--) result = result * a % c; return result;&#125;// è®¡ç®— a^b % c è¿™ç§ç®—æ³•çš„æ­£ç¡®æ€§æ¯‹åº¸ç½®ç–‘ï¼Œä½†æ˜¯å¦‚æžœå¹‚æŒ‡æ•°å¤ªå¤§çš„è¯ï¼Œéœ€è¦è€—è´¹çš„æ—¶é—´å°±æ›´éžå¸¸å¤šï¼Œç›´æŽ¥å¯¼è‡´è¿ç®—æ•ˆçŽ‡ä½Žä¸‹ï¼Œæ‰€ä»¥åªé€‚ç”¨äºŽæŒ‡æ•°ä¸å¤§çš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚ äºŒåˆ†å¹‚è¦æ±‚ $a^n$ï¼Œå¦‚æžœçŸ¥é“äº† $a^{\frac{n}{2}}$ é‚£ä¹ˆå†å¹³æ–¹å°±è¡Œäº†ã€‚ä»¤ $A=a^{\lfloor\frac{n}{2}\rfloor}$è‹¥ $n$ ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆ $Result=A^2$è‹¥ $n$ ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆ $Result=a\times A^2$è¿™æ ·å­å¤æ‚åº¦ä»Ž $O(n)$ é™åˆ°äº† $O(\log n)$ 12345678long long pow(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; if (b == 0) return 1; long long x = pow(a, b / 2, c); long long ans = (long long)x * x % m; if (b % 2 == 1) ans = ans * a % m; return (long long)ans;&#125; è’™å“¥é©¬åˆ©ç®—æ³•å…·ä½“è¯¦ç»†ä»‹ç»è§ç»´åŸºç™¾ç§‘ï¼Œè¿™é‡Œç›´æŽ¥ä¸Šä»£ç ï¼š 1234567891011long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125; ç»„åˆæ•°å–æ¨¡æ–¹æ³•ä¸€ï¼šæ¨è¾‰ä¸‰è§’é€’æŽ¨ä½¿ç”¨é€’æŽ¨å…¬å¼ï¼š$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$å†™æˆæ•°ç»„ï¼š$C[n][m]=C[n-1][m]+C[n-1][m-1]$è¿™ä¹Ÿæ˜¯æ¨è¾‰ä¸‰è§’çš„é€’æŽ¨å…¬å¼ï¼Œæ‰€ä»¥è¾¹ç•Œä¸º $C[0][0]=1$ã€‚ä¸‹é¢ç»™å‡ºæ±‚ä¸€ä¸ªç»„åˆæ•°çš„æ–¹æ³•ï¼š123456789101112131415161718#include &lt;iostream&gt;using namespace std;int n, m;long long c[10010];int main() &#123; cin &gt;&gt; n &gt;&gt; m; m = min(m, n - m); // å› ä¸º c[n][m] == c[n][n - m] // æ‰€ä»¥å–æœ€å°å€¼å‡å°‘è¿ç®—ã€‚ c[0] = 1; for (int i = 1; i &lt;= n; ++i) for (int j = m; j &gt;= 1; --j) c[j] = c[j] + c[j - 1]; cout &lt;&lt; c[m]; return 0;&#125;// å› ä¸ºåªæ±‚ä¸€ä¸ªç»„åˆæ•°ï¼Œæ‰€ä»¥ä½¿ç”¨äº†æ»šåŠ¨æ•°ç»„çš„æ–¹å¼ ç”±äºŽé€’æŽ¨æ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œæ‰€ä»¥åªé€‚ç”¨äºŽå°æ•°æ®çš„æƒ…å†µã€‚ æ–¹æ³•äºŒï¼šä¹˜æ³•é€†å…ƒåœ¨æ•°æ®å¾ˆå¤§çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯¹ç»„åˆæ•°å–æ¨¡å°±ä¼šæ¯”è¾ƒéº»çƒ¦ï¼Œå› ä¸ºæ•°æ®ä¸ä¸€å®šèƒ½å­˜ä¸‹ï¼Œè€Œä¸”é€šè¿‡è§‚å¯Ÿç»„åˆæ•°çš„å…¬å¼ï¼š$$C_n^m=\frac{n!}{m!(n-m)!}=\frac{n\times (n-1)\timesâ€¦\times(n-m+1)}{m!}$$æˆ‘ä»¬å‘çŽ°ç»„åˆæ•°æ˜¯å¸¦æœ‰é™¤æ³•çš„ï¼Œä¸èƒ½èµ°ä¸€æ­¥å–ä¸€æ¬¡æ¨¡ï¼Œä¸ºäº†è§£å†³é™¤æ³•å–æ¨¡çš„é—®é¢˜ï¼Œäººä»¬å‘æ˜Žäº†é€†å…ƒè¿™ä¸ªä¸œè¥¿ã€‚è‹¥ $a\times b\equiv1\pmod p$ åˆ™ç§° $b$ ä¸º $a$ åœ¨æ¨¡ $p$ ä¸‹çš„ä¹˜æ³•é€†å…ƒï¼Œä¸€èˆ¬è®¤ä¸ºï¼Œ$b &lt; p$ï¼Œ$b$ è®°ä¸º $a^{-1}$ã€‚æ³¨æ„ï¼Œæ­¤å¤„ $a$ ä¸Ž $p$ å¿…é¡»äº’è´¨ï¼Œå¦åˆ™ä¹˜æ³•é€†å…ƒä¸å­˜åœ¨ã€‚é‚£ä¹ˆé€†å…ƒè¯¥æ€Žä¹ˆç”¨å‘¢ï¼Ÿå½“ç„¶æ˜¯å€ŸåŠ©å®ƒå°†é™¤æ³•è½¬ä¸ºä¹˜æ³•ï¼Œå†ç”¨åˆ†é…å¾‹æ¥è®¡ç®—äº†ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªå¼å­ï¼š$$\frac{a}{b}\equiv\frac{a}{b}\times b\times b^{-1}\equiv a\times b^{-1}\pmod p$$è¿™æ ·å°±å¯ä»¥æŠŠé—®é¢˜è½¬åŒ–ä¸ºæ±‚ä¸€ä¸ªæ•°çš„é€†å…ƒï¼Œå†è½¬åŒ–ä¸ºä¹˜æ³•è¿ç®—ã€‚ é€’æŽ¨æ±‚é€†å…ƒæ±‚ $iâ€‹$ åœ¨æ¨¡ $pâ€‹$ ä¸‹çš„ä¹˜æ³•é€†å…ƒï¼Œæ»¡è¶³ $gcd(i, p)=1, i&lt; pâ€‹$ä½¿ç”¨æ¬§å‡ é‡Œå¾—é™¤æ³•çš„å½¢å¼ï¼Œä»¤ $p=k\times i+râ€‹$ï¼Œåˆ™ $k=\lfloor\frac{p}{i}\rfloor,r=p\bmod iâ€‹$æ˜¾ç„¶ï¼Œ$k\times i+r\equiv 0(\bmod p)â€‹$ä¸¤è¾¹åŒä¹˜ $i^{-1}\times r^{-1}â€‹$ï¼Œå¾— $k\times r^{-1}+i^{-1}\equiv 0\pmod pâ€‹$ç§»é¡¹ï¼Œæ•´ç†ï¼š$i^{-1}\equiv -k\times r^{-1}\equiv (p-k)\times r^{-1}\pmod pâ€‹$å°† $kâ€‹$ å’Œ $râ€‹$ ç”¨ $pâ€‹$ æ¥æ›¿æ¢ï¼š$i^{-1}\equiv (p-\lfloor\frac{p}{i}\rfloor)\times (p\bmod i)^{-1}\pmod pâ€‹$ä½¿ç”¨ inv[i] æ¥è¡¨ç¤º i çš„é€†å…ƒï¼Œæœ‰ inv[i] = (p - p / i) * inv[p % i]æ—¶é—´å¤æ‚çš„ä¸ºçº¿æ€§ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456long long inv[10000010];long long getInverse(long long x, long long p) &#123; if (inv[x] != 0) return inv[x]; inv[x] = (p - p / i) * getInverse(p % x, p) % p; return inv[x];&#125; è´¹é©¬å°å®šç†æ±‚é€†å…ƒè´¹é©¬å°å®šç†ï¼šå¦‚æ­¤å¯çˆ±çš„å®šç†åç§° $a^{p-1}\equiv1\pmod p$ å½“ $p$ ä¸ºç´ æ•°æ—¶ä¸” $gcd(a,p)=1$ æ—¶ã€‚æ‰€ä»¥æ±‚ $a$ çš„é€†å…ƒæ—¶ï¼Œåªè¦æ±‚å‡º $a^{p-2}$ çš„å€¼å°±å¯ä»¥äº†ã€‚ 1234567891011121314long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getinverse(long long x, long long p) &#123; return Montgomery(x, p - 2, p);&#125; é€†å…ƒæ±‚ç»„åˆæ•°ä»Žç»„åˆæ•°åŽŸå…¬å¼å‡ºå‘$$C_n^m=\frac{n!}{m!(n-m)!}=\frac{n\times (n-1)\timesâ€¦\times(n-m+1)}{m!}$$ å¯¹äºŽåˆ†å­ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¼ ç»Ÿæ–¹æ³•ï¼Œè¾¹ä¹˜è¾¹æ¨¡ï¼Œå¯¹äºŽåˆ†æ¯ï¼Œæˆ‘ä»¬å¯ä»¥æ±‚é€†å…ƒå†ä¹˜åˆ†å­ã€‚ 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getInverse(long long x, long long p) &#123; return Montgomery(x, p - 2, p);&#125;long long c(long long n, long long m, long long p) &#123; long long x = 1, y = 1; for (long long i = n; i &gt;= n - m + 1; --i) x = x * i % p; for (long long i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; long long n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; æ³¨ï¼š$p$ ä¸€å®šè¦æ˜¯å¤§è´¨æ•°ï¼Œèµ·ç å¾—å¤§äºŽ $m$ã€‚è‹¥è¦æ±‚ $a$ åœ¨æ¨¡ $p$ ä¸‹çš„ä¹˜æ³•é€†å…ƒï¼Œå¿…é¡»è¦ä¿è¯ $a$ ä¸Ž $p$ äº’è´¨ã€‚åœ¨æ­¤é¢˜ä¸­ï¼Œè¦æ±‚ $m!$ çš„ä¹˜æ³•é€†å…ƒï¼Œé‚£ä¹ˆ $p$ å¿…é¡»ä¸Ž $m!$ äº’è´¨ï¼Œæ‰€ä»¥ $p$ è¦å¤§äºŽ $m$ï¼Œä¸”æ˜¯ä¸ªè´¨æ•°ã€‚æˆ‘ä¸€å¼€å§‹å¿˜è®°äº†è¿™ç‚¹ï¼Œå¯¼è‡´è°ƒäº†ä¸€å¹´ æ–¹æ³•ä¸‰ï¼šå¢å¡æ–¯å®šç†é€‚ç”¨äºŽå¯¹ç­”æ¡ˆæ¨¡ä¸€ä¸ªè´¨æ•°çš„æƒ…å†µã€‚ä¸Žé€†å…ƒä¸åŒçš„æ˜¯ï¼Œè¿™ä¸ªæ–¹æ³•ä¸è¦æ±‚ $p$ æ˜¯ä¸ªå¾ˆå¤§çš„ç´ æ•°ï¼Œå› æ­¤ï¼Œé€‚ç”¨èŒƒå›´æ›´å¹¿ï¼ˆä¹Ÿè®¸å§ï¼‰ã€‚å¢å¡æ–¯å®šç†ï¼šå¯¹äºŽéžè´Ÿæ•´æ•° $m$ å’Œ $n$ åŠç´ æ•° $p$ï¼Œæœ‰åŒä½™å¼ï¼š$$\binom{n}{m}\equiv\prod_{i=0}^k\binom{n_i}{m_i} \pmod p$$æˆç«‹ã€‚å…¶ä¸­ï¼š$$n=n_kp^k+n_{k-1}p^{k-1}+â€¦+n_1p+n_0$$å¹¶ä¸”$$m=m_kp^k+m_{k-1}p^{k-1}+â€¦+m_1p+m_0$$ä»¥ä¸Šä¸¤ä¸ªå¼å­æ˜¯ $n$ å’Œ $m$ çš„ $p$ è¿›åˆ¶å±•å¼€ã€‚å½“ $m &lt; n$ æ—¶ï¼ŒäºŒé¡¹å¼ç³»æ•° $\binom{n}{m}=0$ã€‚å¯ä»¥é€šè¿‡ä¸€ç³»åˆ—çš„æŽ¨å¯¼å¾—å‡ºä¸‹é¢è¿™ä¸ªç»“è®ºï¼š$$\binom{n}{m}\equiv\binom{\lfloor\frac{n}{p}\rfloor}{\lfloor\frac{m}{p}\rfloor}\times \binom{n\bmod p}{m\bmod p} \pmod p$$ç”±è¿™ä¸ªå…¬å¼æˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®ºï¼šåœ¨ $n$ å’Œ $m$ éƒ½å°äºŽ $p$ æ—¶ï¼Œå…¬å¼ä¸€ç‚¹ç”¨éƒ½æ²¡æœ‰ã€‚ï¼ˆå•¥ï¼Ÿä½ é—®æˆ‘ä¸ºä»€ä¹ˆï¼Ÿ$\binom{0}{0}=1$ å•Šï¼ï¼‰æ‰€ä»¥è¿™ä¸ªå…¬å¼æ˜¯åœ¨ $n\geqslant p$ æˆ– $m\geqslant p$ çš„æƒ…å†µä¸‹ä½¿ç”¨çš„ã€‚è¿™æ ·å¯ä»¥å‡å° $n$ å’Œ $m$ï¼Œä½¿ä¹‹å°äºŽ $p$ï¼Œå†ç”¨ä¹˜æ³•é€†å…ƒåŽ»æ±‚ç»„åˆæ•°ã€‚ 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;long long Montgomery(long long a, long long b, long long c) &#123; if (b == 0) return 1 % c; long long result = 1; long long temp = a; while (b &gt; 0) &#123; if (b &amp; 1) result = (result * temp) % c; temp = (temp * temp) % c; b &gt;&gt;= 1; &#125; return result;&#125;long long getInverse(long long a, long long b) &#123; return Montgomery(a, b - 2, b);&#125;long long c(int n, int m, int p) &#123; if (m == 0) return 1 % p; if (n == 0) return 0; if (n &gt;= p || m &gt;= p) return c(n / p, m / p, p) * c(n % p, m % p, p) % p; // æ ¸å¿ƒè¯­å¥ long long x = 1, y = 1; for (int i = n; i &gt;= n - m + 1; --i) x = x * i % p; for (int i = 1; i &lt;= m; ++i) y = y * i % p; return x * getInverse(y, p) % p;&#125;int main() &#123; long long n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; cout &lt;&lt; c(n, m, p); return 0;&#125; æœªå®Œå¾…ç»­â€¦â€¦]]></content>
      <categories>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>æ•°è®º</tag>
        <tag>æ¨¡è¿ç®—</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[C++ å¥‡æŠ€æ·«å·§] æµè¿­ä»£å™¨ä½¿ç”¨]]></title>
    <url>%2F2018%2F08%2F17%2FC-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7-%E6%B5%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢è‡ªä»Žç†ŸçŸ¥äº† STL åº“è¿™ä¸ªä¸œè¥¿ï¼Œæˆ‘å°±å†ä¹Ÿç¦»ä¸å¼€å®ƒäº†ï¼Œä»¥å‰ä¸€ç›´ä»¥ä¸ºåªæœ‰å®¹å™¨æ‰ä¼šæœ‰è¿­ä»£å™¨å¯ä»¥ç”¨ï¼Œç„¶è€Œè¿™æ˜¯å› ä¸ºè‡ªå·±çš„çŸ¥è¯†æ°´å¹³è¿˜ä¸å¤Ÿé«˜ï¼Œä»Šå¤©å°±ä»‹ç»ä¸€ä¸‹æµè¿­ä»£å™¨è¿™ç§ç¥žå¥‡çš„å­˜åœ¨ã€‚ æµè¿­ä»£å™¨iostream è¿­ä»£å™¨ï¼ˆiostream iteratorï¼‰ï¼šä¸Žè¾“å…¥æˆ–è¾“å‡ºæµç»‘å®šåœ¨ä¸€èµ·ï¼Œç”¨äºŽè¿­ä»£éåŽ†æ‰€å…³è”çš„ IO æµã€‚ è™½ç„¶ iostream ç±»åž‹ä¸æ˜¯å®¹å™¨ï¼Œä½†æ ‡å‡†åº“åŒæ ·æä¾›äº†åœ¨ iostream å¯¹è±¡ä¸Šä½¿ç”¨çš„è¿­ä»£å™¨ï¼šistream_iterator ç”¨äºŽè¯»å–è¾“å…¥æµï¼Œè€Œ ostream_iterator åˆ™ç”¨äºŽå†™è¾“å‡ºæµã€‚è¿™äº›è¿­ä»£å™¨å°†å®ƒä»¬æ‰€å¯¹åº”çš„æµè§†ä¸ºç‰¹å®šç±»åž‹çš„å…ƒç´ åºåˆ—ã€‚ ä¸‹é¢åˆ—å‡ºæµè¿­ä»£å™¨çš„ä½¿ç”¨æ–¹æ³•ï¼š iostream è¿­ä»£å™¨çš„æž„é€ å‡½æ•° å¯¹åº”çš„æ„ä¹‰ istream_iterator&lt;T&gt; in(strm) åˆ›å»ºä»Žè¾“å…¥æµ strm ä¸­è¯»å–Tç±»åž‹å¯¹è±¡çš„ istream_iterator å¯¹è±¡ istream_terator&lt;T&gt; in istream_iterator å¯¹è±¡çš„è¶…å‡ºæœ«ç«¯è¿­ä»£å™¨ ostream_iterator&lt;T&gt; out(strm) åˆ›å»ºå°†Tç±»åž‹çš„å¯¹è±¡å†™åˆ°è¾“å‡ºæµ strm çš„ ostream_iterator å¯¹è±¡ ostream_iterator&lt;T&gt; out(str, delim) åˆ›å»ºå°† T ç±»åž‹çš„å¯¹è±¡å†™åˆ°è¾“å‡ºæµ strm çš„ ostream_iterator å¯¹è±¡ï¼Œåœ¨å†™å…¥è¿‡ç¨‹ä¸­ä½¿ç”¨ delim ä½œä¸ºå…ƒç´ çš„åˆ†éš”ç¬¦ã€‚delim æ˜¯ä»¥ç©ºå­—ç¬¦ç»“æŸçš„å­—ç¬¦æ•°ç»„ï¼ˆCé£Žæ ¼å­—ç¬¦ä¸²ï¼‰ã€‚ istream_iterator çš„æ“ä½œ å¯¹åº”çš„æ„ä¹‰ it1 == it2; it1 != it2 æ¯”è¾ƒä¸¤ä¸Š istream_iterator å¯¹è±¡æ˜¯å¦ç›¸ç­‰ï¼ˆä¸ç­‰ï¼‰ã€‚è¿­ä»£å™¨è¯»å–çš„å¿…é¡»æ˜¯ç›¸åŒçš„ç±»åž‹ã€‚å¦‚æžœä¸¤ä¸ªè¿­ä»£å™¨éƒ½æ˜¯ end å€¼ï¼Œåˆ™å®ƒä»¬ç›¸ç­‰ã€‚å¯¹äºŽä¸¤ä¸ªéƒ½ä¸æŒ‡å‘æµç»“æŸä½ç½®çš„è¿­ä»£å™¨ï¼Œå¦‚æžœå®ƒä»¬ä½¿ç”¨åŒä¸€ä¸ªè¾“å…¥æµæž„é€ ï¼Œåˆ™å®ƒä»¬ä¹Ÿç›¸ç­‰ *it è¿”å›žä»Žæµä¸­è¯»å–çš„å€¼ it-&gt;mem æ˜¯ (*it).mem çš„åŒä¹‰è¯ã€‚è¿”å›žä»Žæµä¸­è¯»å–çš„å¯¹è±¡çš„ mem æˆå‘˜ ++it; it++ é€šè¿‡ä½¿ç”¨å…ƒç´ ç±»åž‹æä¾›çš„ &gt;&gt; æ“ä½œä»Žè¾“å…¥æµä¸­è¯»å–ä¸‹ä¸€ä¸ªå…ƒç´ å€¼ï¼Œä½¿è¿­ä»£å™¨å‘å‰ç§»åŠ¨ã€‚é€šå¸¸ï¼Œå‰ç¼€ç‰ˆæœ¬ä½¿ç”¨è¿­ä»£å™¨åœ¨æµä¸­å‘å‰ç§»åŠ¨ï¼Œå¹¶è¿”å›žå¯¹åŠ  $1$ åŽçš„è¿­ä»£å™¨çš„å¼•ç”¨ã€‚è€ŒåŽç¼€ç‰ˆæœ¬ä½¿è¿­ä»£å™¨åœ¨æµä¸­å‘å‰ç§»åŠ¨åŽï¼Œè¿”å›žåŽŸå€¼ æ³¨ï¼šæµè¿­ä»£å™¨éƒ½æ˜¯ç±»æ¨¡æ¿ï¼šä»»ä½•å·²å®šä¹‰è¾“å…¥æ“ä½œç¬¦ï¼ˆ&gt;&gt; æ“ä½œç¬¦ï¼‰çš„ç±»åž‹éƒ½å¯ä»¥å®šä¹‰istream_iteratorã€‚ä»»ä½•å·²å®šä¹‰è¾“å‡ºæ“ä½œç¬¦ï¼ˆ&lt;&lt; æ“ä½œç¬¦ï¼‰çš„ç±»åž‹å¯å®šä¹‰ ostream_iteratorã€‚ æµè¿­ä»£å™¨ä½¿ç”¨æ³¨ï¼šè¿­ä»£å™¨çš„å¤´æ–‡ä»¶åˆ«å¿˜è®°å¼•å…¥ã€‚ #include &lt;iterator&gt; 1234567891011121314151617#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;iterator&gt;using namespace std;int main() &#123; istream_iterator&lt;int&gt; cinIter(cin); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec; while (cinIter != endOfStream) //æ³¨æ„++å…ˆå¼•ç”¨åŽå¢žå€¼ï¼Œä¸èƒ½å†™å‡ºå‰ç¼€ vec.push_back(*cinIter++); //ä¹Ÿå¯ä»¥å†™æˆ vector&lt;int&gt; vec(cinIter, endOfStream); for (int i = 0; i != vec.size(); ++i) cout &lt;&lt; vec[i]; return 0;&#125; æ³¨ï¼šå…¶ä¸­ end_of_stream å®šä¹‰ä¸ºç©ºçš„è¿­ä»£å™¨å¯¹è±¡ï¼Œç”¨ä½œç»“æŸè¿­ä»£å™¨ã€‚ç»‘å®šæµä¸Šçš„è¿­ä»£å™¨åœ¨é‡åˆ°æ–‡ä»¶ç»“æŸæˆ–æŸä¸ªé”™è¯¯æ—¶ï¼Œå°†ç­‰äºŽç»“æŸè¿­ä»£å™¨çš„å€¼ã€‚ 1234567int main(int argc, char **argv) &#123; ostream_iterator&lt;string&gt; outIter(cout, "\n"); istream_iterator&lt;string&gt; inIter(cin), endOfStream; while(endOfStream != inIter) *outIter++ = *inIter++; return 0;&#125; æ³¨ï¼šæ‰§è¡Œé¡ºåºæ˜¯å…ˆ iter++ï¼Œè¿”å›ž iterï¼Œæœ€åŽ *iterã€‚æ³¨æ„è¾“å‡ºï¼Œè¾“å…¥ 1 2 3 4 5ï¼ŒæŒ‰ enter è¾“å‡º 1\n2\n3\n4\nï¼ŒæŒ‰ ctrl+z è¾“å‡º 5ã€‚ 12345678910111213141516#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;using namespace std; int main(int argc, char **argv) &#123; ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); sort(vec.begin(), vec.end()); ostream_iterator&lt;int&gt; output(cout, " "); unique_copy(vec.begin(), vec.end(), output); return 0;&#125; ç¤ºä¾‹è¾“å…¥/è¾“å‡ºï¼š INPUT(in.txt): 1 2 2 2 5 5 6 6 7 8 9 10 9 100 OUTPUT: 1 2 5 6 7 8 9 10 100 æµè¿­ä»£å™¨çš„é™åˆ¶ ä¸å¯èƒ½ä»Ž ostream_iterator å¯¹è±¡è¯»å…¥ï¼Œä¹Ÿä¸å¯èƒ½å†™åˆ° istream_iterator å¯¹è±¡ä¸­ã€‚ ä¸€æ—¦ç»™ ostream_iteratorå¯¹è±¡èµ‹äº†ä¸€ä¸ªå€¼ï¼Œå†™å…¥å°±æäº¤äº†ã€‚èµ‹å€¼åŽï¼Œæ²¡æœ‰åŠžæ³•å†æ”¹å˜è¿™ä¸ªå€¼ã€‚æ­¤å¤–ï¼Œostream_iterator å¯¹è±¡ä¸­æ¯ä¸ªä¸åŒçš„å€¼éƒ½åªèƒ½æ­£å¥½è¾“å‡ºä¸€æ¬¡ã€‚ ostream_iterator æ²¡æœ‰ -&gt; æ“ä½œç¬¦ã€‚ æµè¿­ä»£å™¨çš„é€Ÿåº¦ä¸ºäº†æµ‹è¯•æµè¿­ä»£å™¨çš„é€Ÿåº¦ï¼Œæˆ‘å…ˆéšæœºç”Ÿæˆäº† $10000000$ ä¸ªæ•°æ®ï¼Œç”Ÿæˆä»£ç å¦‚ä¸‹ï¼š 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ofstream test("in.txt"); srand((unsigned)time(NULL) * 19260817); // +1s for (int i = 1; i &lt;= 10000000; ++i) test &lt;&lt; rand() &lt;&lt; " "; return 0;&#125; è¿­ä»£å™¨æµ‹è¯•12345678910111213141516171819202122#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono; int main(int argc, char **argv) &#123; auto start = system_clock::now(); ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; ç»“æžœï¼š cost: 10.7543 seconds æ³¨ï¼šä¸ºäº†æµ‹è¯•æ—¶é—´å°½é‡ç²¾å‡†ï¼Œè¿™é‡Œå¼•å…¥äº† chrono åº“ï¼Œä½¿ç”¨äº†æ”¯æŒ C++ 11 çš„ gcc 7.3.0ï¼Œå¹¶ä¸”æ˜¯åœ¨ Linux(Ubuntu) ä¸Šç¼–è¯‘è¿è¡Œçš„ï¼Œé‰´äºŽç¼–è¯‘å™¨çš„ä¼˜åŒ–èƒ½åŠ›ä¸€ä¸ªç‰ˆæœ¬æ¯”ä¸€ä¸ªç‰ˆæœ¬å¼ºï¼Œæ­¤å¤„æ²¡æœ‰å¼€ä¼˜åŒ–ä½†ç»“æžœä»å¯èƒ½æœ‰è¯¯å·®ï¼Œä¸Ž OI ä¸­ä½¿ç”¨è¿­ä»£å™¨çš„é€Ÿåº¦ä¸ä¸€æ ·ï¼Œè¯»è€…å¯ä»¥ä½¿ç”¨åˆ«çš„åº“å†è¿›è¡Œå®žéªŒã€‚ å¼€äº† $O_2$ ä¼˜åŒ–çš„æµè¿­ä»£å™¨123456789101112131415161718192021222324#pragma GCC optimize(2)#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono; int main(int argc, char **argv) &#123; auto start = system_clock::now(); ifstream infile("in.txt"); istream_iterator&lt;int&gt; cinIter(infile); istream_iterator&lt;int&gt; endOfStream; vector&lt;int&gt; vec(cinIter, endOfStream); auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; ç»“æžœï¼š cost: 2.31234 seconds æ³¨ï¼šå¼€äº†ä¼˜åŒ–çš„ç»“æžœï¼Œè¯»è€…è‡ªè¡Œåˆ¤æ–­ OI ä¸­å¿«è¯»çš„æ—¶é—´æµ‹è¯•1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;chrono&gt;#include &lt;cctype&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;using namespace std::chrono;inline void read(int &amp;x) &#123; x = 0; bool sign = false; char ch = 0; while (!isdigit(ch)) &#123; sign |= (ch == '-'); ch = getchar(); &#125; while (isdigit(ch)) &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); ch = getchar(); &#125; x = sign ? -x : x;&#125;int main(int argc, char **argv) &#123; auto start = system_clock::now(); freopen("in.txt", "r", stdin); int x; vector&lt;int&gt; a; for (int i = 0; i &lt; 10000000; ++i) &#123; read(x); a.push_back(x); &#125; auto end = system_clock::now(); auto duration = duration_cast&lt;microseconds&gt;(end - start); cout &lt;&lt; "cost: " &lt;&lt; double(duration.count()) * microseconds::period::num / microseconds::period::den &lt;&lt; " seconds" &lt;&lt; endl; return 0;&#125; ç»“æžœ cost: 2.61905 seconds æ³¨ï¼šå¿«è¯»çš„å†™æ³•ä¹Ÿè®¸ä¸æ˜¯æœ€ä¼˜ï¼Œè¯»è€…å¯ä»¥è‡ªè¡Œå®žéªŒã€‚ æ€»ç»“äº‹å®žä¸Šï¼ŒæŠ›å¼€ OI æ¯”èµ›ä¸è¯´ï¼ŒSTL çš„åº“ä½¿ç”¨ä¼˜åŒ–è¿˜æ˜¯å¾ˆå¼ºçš„ï¼Œä½†æ˜¯ OI ä¸­å˜›ï¼Œå¦‚æžœä½œå¤§æ­»ç”¨è¿™ä¸ªä¹Ÿè®¸çœŸçš„ä¼šå´©ã€‚è‡³äºŽæœ‰å…³ STL é€Ÿåº¦çš„è®¨è®ºå¯ä»¥çœ‹è¿™é‡Œã€‚]]></content>
      <categories>
        <category>å¥‡æŠ€æ·«å·§</category>
      </categories>
      <tags>
        <tag>C++ å¥‡æŠ€æ·«å·§</tag>
        <tag>è¿­ä»£å™¨</tag>
        <tag>iostream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ç®—æ³•] Manacher ç®—æ³•æ±‚æœ€é•¿å›žæ–‡å­ä¸²]]></title>
    <url>%2F2018%2F08%2F14%2F%E7%AE%97%E6%B3%95-Manacher-%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢æœ€è¿‘å‡ æ¬¡è€ƒè¯•éƒ½æ¶‰åŠåˆ°äº†å­—ç¬¦ä¸²å¤„ç†è¿™ä¸ªè¯é¢˜ï¼Œæ‰€ä»¥è‡ªå·±æ‰“ç®—æ¶è¡¥å­—ç¬¦ä¸²æœ‰å…³çš„ç®—æ³•ï¼ŒåŒæ—¶åˆåˆšå¥½åšåˆ°äº† LeetCode ä¸Šè¿™ä¹ˆä¸€é“é¢˜ï¼Œæ‰€ä»¥å¹²è„†ä¸€åŒè§£å†³æŽ‰ã€‚ æœ€é•¿å›žæ–‡å­—ä¸²é—®é¢˜æœ€é•¿å›žæ–‡å­ä¸²é—®é¢˜ï¼šç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å®ƒçš„æœ€é•¿å›žæ–‡å­ä¸²é•¿åº¦ã€‚å¦‚æžœä¸€ä¸ªå­—ç¬¦ä¸²æ­£ç€è¯»å’Œåç€è¯»æ˜¯ä¸€æ ·çš„ï¼Œé‚£å®ƒå°±æ˜¯å›žæ–‡ä¸²ã€‚ä¸‹é¢æ˜¯ä¸€äº›å›žæ–‡ä¸²çš„å®žä¾‹ï¼š 12321 a aba abba aaaa tattarrattatï¼ˆç‰›æ´¥è‹±è¯­è¯å…¸ä¸­æœ€é•¿çš„å›žæ–‡å•è¯ é‚£ä¹ˆå¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿæœ‰å¾ˆå¤šç§æ–¹æ³•ï¼š Brute-Force æš´åŠ›æ±‚è§£ï¼šæ‰¾åˆ°æ‰€æœ‰å­—ä¸²ï¼Œä¸€ä¸€éªŒè¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n^3)$ æ”¹è¿›ç‰ˆ Brute-Forceï¼šéåŽ†æ•´ä¸ªå­—ç¬¦ä¸²çš„ä¸­é—´å­—ç¬¦åŠç©ºéš™ï¼Œç„¶åŽå‘ä¸¤ç«¯æ‰«æï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚ åŠ¨æ€è§„åˆ’ï¼Œæ­¤å¤„æš‚æ—¶ä¸ä»‹ç» ä¸‹é¢å°†è¦ä»‹ç»çš„ Manacher ç®—æ³•ï¼Œåˆåé©¬æ‹‰è½¦ã€‚ Manacher ç®—æ³•æš´åŠ›è§£æ³•çš„ç¼ºé™·æ‰€åœ¨ å›žæ–‡ä¸²å¥‡å¶æ€§ä¸å®šï¼Œä½¿ç”¨ä¸Šè¿°æ–¹æ³•äºŒéœ€è¦åˆ†ç±»è®¨è®ºï¼Œé™ä½Žæ•ˆçŽ‡ã€‚ å­—ä¸²é‡å¤è®¿é—®ï¼Œæ—¶é—´å¤æ‚åº¦å†—ä½™ã€‚ ä¸¾ä¸ªä¾‹å­ï¼š char: a b a b a i: 0 1 2 3 4 åœ¨ $i=1$ å’Œ $i=2$ æ—¶ï¼Œå­—ä¸² aba è¢«åˆ†åˆ«éåŽ†äº†ä¸€æ¬¡ã€‚Manacher ç®—æ³•æ­£å¼é’ˆå¯¹è¿™äº›ç®—æ³•è¿›è¡Œæ”¹è¿›çš„ç®—æ³•ï¼Œå¯ä»¥å¤§å¤§æé«˜ç®—æ³•çš„è¿è¡Œæ•ˆçŽ‡ã€‚ è§£å†³é•¿åº¦å¥‡å¶æ€§é—®é¢˜Manacher ç®—æ³•é€šè¿‡ä¸€ç§é¢„å¤„ç†æ–¹å¼æ¥è§£å†³ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œå®ƒåœ¨å­—ç¬¦ä¸²é¦–å°¾åŠä¸­é—´ç©ºéš™æ’å…¥ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”æ»¡è¶³è¿™ä¸ªç¬¦å·ä¸åœ¨å­—ç¬¦ä¸²ä¸­å‡ºçŽ°ï¼Œè¿™æ ·å°±å¯ä»¥è®©æ‰€æœ‰çš„å­—ç¬¦ä¸²é•¿åº¦å˜ä¸ºå¥‡æ•°ã€‚ä»¥æ’å…¥#ä¸ºä¾‹ï¼š aba --&gt; #a#b#a# abba --&gt; #a#b#b#a# æ’å…¥çš„æ˜¯åŒæ ·çš„ç¬¦å·ï¼Œä¸”ç¬¦å·ä¸å­˜åœ¨äºŽåŽŸä¸²ï¼Œå› æ­¤å­ä¸²çš„å›žæ–‡æ€§ä¸å—å½±å“ï¼ŒåŽŸæ¥æ˜¯å›žæ–‡çš„ä¸²ï¼Œæ’å®Œä¹‹åŽè¿˜æ˜¯å›žæ–‡çš„ï¼ŒåŽŸæ¥ä¸æ˜¯å›žæ–‡çš„ï¼Œä¾ç„¶ä¸ä¼šæ˜¯å›žæ–‡ è§£å†³é‡å¤è®¿é—®é—®é¢˜æˆ‘ä»¬æŠŠä¸€ä¸ªå›žæ–‡ä¸²ä¸­æœ€å·¦æˆ–æœ€å³ä½ç½®çš„å­—ç¬¦ä¸Žå…¶å¯¹ç§°è½´çš„è·ç¦»ç§°ä¸ºå›žæ–‡åŠå¾„ã€‚Manacherå®šä¹‰äº†ä¸€ä¸ªå›žæ–‡åŠå¾„æ•°ç»„ $RL$ï¼Œç”¨ $RL[i]$ è¡¨ç¤ºä»¥ç¬¬ $i$ ä¸ªå­—ç¬¦ä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²çš„å›žæ–‡åŠå¾„ã€‚æˆ‘ä»¬ä¸€èˆ¬å¯¹å­—ç¬¦ä¸²ä»Žå·¦å¾€å³å¤„ç†ï¼Œå› æ­¤è¿™é‡Œå®šä¹‰ $RL[i]$ ä¸ºç¬¬ $i$ ä¸ªå­—ç¬¦ä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²çš„æœ€å³ä¸€ä¸ªå­—ç¬¦ä¸Žå­—ç¬¦ $i$ çš„è·ç¦»ã€‚å¯¹äºŽä¸Šé¢æ’å…¥åˆ†éš”ç¬¦ä¹‹åŽçš„ä¸¤ä¸ªä¸²ï¼Œå¯ä»¥å¾—åˆ° $RL$ æ•°ç»„ï¼š $char$ # $a$ # $b$ # $a$ # $RL$ $1$ $2$ $1$ $4$ $1$ $2$ $1$ $RL-1$ $0$ $1$ $0$ $3$ $0$ $1$ $0$ $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ ä¸Šé¢æˆ‘ä»¬è¿˜æ±‚äº†ä¸€ä¸‹ $RL[i]-1$ã€‚é€šè¿‡è§‚å¯Ÿå¯ä»¥å‘çŽ°ï¼Œ$RL[i]-1$çš„å€¼ï¼Œæ­£æ˜¯åœ¨åŽŸæœ¬é‚£ä¸ªæ²¡æœ‰æ’å…¥è¿‡åˆ†éš”ç¬¦çš„ä¸²ä¸­ï¼Œä»¥ä½ç½®iä¸ºå¯¹ç§°è½´çš„æœ€é•¿å›žæ–‡ä¸²çš„é•¿åº¦ã€‚é‚£ä¹ˆåªè¦æˆ‘ä»¬æ±‚å‡ºäº† $RL$ æ•°ç»„ï¼Œå°±èƒ½å¾—åˆ°æœ€é•¿å›žæ–‡å­ä¸²çš„é•¿åº¦ã€‚ äºŽæ˜¯é—®é¢˜å˜æˆäº†ï¼Œå¦‚ä½•é«˜æ•ˆåœ°æ±‚çš„ $RL$ æ•°ç»„ã€‚åŸºæœ¬æ€è·¯æ˜¯åˆ©ç”¨å›žæ–‡ä¸²çš„å¯¹ç§°æ€§ï¼Œæ‰©å±•å›žæ–‡ä¸²ã€‚ æˆ‘ä»¬å†å¼•å…¥ä¸€ä¸ªè¾…åŠ©å˜é‡ $MaxRight$ï¼Œè¡¨ç¤ºå½“å‰è®¿é—®åˆ°çš„æ‰€æœ‰å›žæ–‡å­ä¸²ï¼Œæ‰€èƒ½è§¦åŠçš„æœ€å³ä¸€ä¸ªå­—ç¬¦çš„ä½ç½®ã€‚å¦å¤–è¿˜è¦è®°å½•ä¸‹ $MaxRight$ å¯¹åº”çš„å›žæ–‡ä¸²çš„å¯¹ç§°è½´æ‰€åœ¨çš„ä½ç½®ï¼Œè®°ä¸º $pos$ï¼Œå®ƒä»¬çš„ä½ç½®å…³ç³»å¦‚ä¸‹ï¼š æˆ‘ä»¬ä»Žå·¦å¾€å³åœ°è®¿é—®å­—ç¬¦ä¸²æ¥æ±‚ $RL$ï¼Œå‡è®¾å½“å‰è®¿é—®åˆ°çš„ä½ç½®ä¸º $i$ï¼Œå³è¦æ±‚ $RL[i]$ï¼Œåœ¨å¯¹åº”ä¸Šå›¾ï¼Œ$i$ å¿…ç„¶æ˜¯åœ¨ $pos$ å³è¾¹çš„ã€‚ä½†æˆ‘ä»¬æ›´å…³æ³¨çš„æ˜¯ï¼Œ$i$ æ˜¯åœ¨ $MaxRight$ çš„å·¦è¾¹è¿˜æ˜¯å³è¾¹ã€‚æˆ‘ä»¬åˆ†æƒ…å†µæ¥è®¨è®ºï¼š æƒ…å†µä¸€ï¼š$i$ åœ¨ $MaxRight$ å·¦è¾¹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æˆ‘ä»¬çŸ¥é“ï¼Œå›¾ä¸­ä¸¤ä¸ªçº¢è‰²å—ä¹‹é—´ï¼ˆåŒ…æ‹¬çº¢è‰²å—ï¼‰çš„ä¸²æ˜¯å›žæ–‡çš„ï¼›å¹¶ä¸”ä»¥ $i$ ä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²ï¼Œæ˜¯ä¸Žçº¢è‰²å—é—´çš„å›žæ–‡ä¸²æœ‰æ‰€é‡å çš„ã€‚æˆ‘ä»¬æ‰¾åˆ° $i$ å…³äºŽ $pos$ çš„å¯¹ç§°ä½ç½® $j$ï¼Œè¿™ä¸ª $j$ å¯¹åº”çš„ $RL[j]$ æˆ‘ä»¬æ˜¯å·²ç»ç®—è¿‡çš„ã€‚æ ¹æ®å›žæ–‡ä¸²çš„å¯¹ç§°æ€§ï¼Œä»¥iä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²å’Œä»¥jä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²ï¼Œæœ‰ä¸€éƒ¨åˆ†æ˜¯ç›¸åŒçš„ã€‚è¿™é‡Œåˆæœ‰ä¸¤ç§ç»†åˆ†çš„æƒ…å†µ: ä»¥ $j$ ä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²è¾ƒçŸ­å¦‚ä¸‹å›¾ï¼š è¿™æ—¶æˆ‘ä»¬çŸ¥é“ $RL[i]$ è‡³å°‘ä¸ä¼šå°äºŽ $RL[j]$ï¼Œå¹¶ä¸”å·²ç»çŸ¥é“äº†éƒ¨åˆ†çš„ä»¥iä¸ºä¸­å¿ƒçš„å›žæ–‡ä¸²ï¼ŒäºŽæ˜¯å¯ä»¥ä»¤ $RL[i]=RL[j]$ã€‚ä½†æ˜¯ä»¥iä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²å¯èƒ½å®žé™…ä¸Šæ›´é•¿ï¼Œå› æ­¤æˆ‘ä»¬è¯•ç€ä»¥ $i$ ä¸ºå¯¹ç§°è½´ï¼Œç»§ç»­å¾€å·¦å³ä¸¤è¾¹æ‰©å±•ï¼Œç›´åˆ°å·¦å³ä¸¤è¾¹å­—ç¬¦ä¸åŒï¼Œæˆ–è€…åˆ°è¾¾è¾¹ç•Œã€‚ ä»¥ $j$ ä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²è¾ƒé•¿å¦‚ä¸‹å›¾ï¼š è¿™æ—¶ï¼Œæˆ‘ä»¬åªèƒ½ç¡®å®šï¼Œä¸¤æ¡è“çº¿ä¹‹é—´çš„éƒ¨åˆ†ï¼ˆå³ä¸è¶…è¿‡ $MaxRight$ çš„éƒ¨åˆ†ï¼‰æ˜¯å›žæ–‡çš„ï¼ŒäºŽæ˜¯ä»Žè¿™ä¸ªé•¿åº¦å¼€å§‹ï¼Œå°è¯•ä»¥iä¸ºä¸­å¿ƒå‘å·¦å³ä¸¤è¾¹æ‰©å±•ï¼Œï¼Œç›´åˆ°å·¦å³ä¸¤è¾¹å­—ç¬¦ä¸åŒï¼Œæˆ–è€…åˆ°è¾¾è¾¹ç•Œã€‚ å°ç»“ä¸è®ºä»¥ä¸Šå“ªç§æƒ…å†µï¼Œä¹‹åŽéƒ½è¦å°è¯•æ›´æ–°MaxRightå’Œposï¼Œå› ä¸ºæœ‰å¯èƒ½å¾—åˆ°æ›´å¤§çš„MaxRightã€‚ å…·ä½“æ“ä½œå¦‚ä¸‹ï¼š ä»¤ $RL[i]=min\lbrace RL[2\times pos-i], MaxRight-i\rbrace$ ä»¥ $i$ ä¸ºä¸­å¿ƒæ‰©å±•å›žæ–‡ä¸²ï¼Œç›´åˆ°å·¦å³ä¸¤è¾¹å­—ç¬¦ä¸åŒï¼Œæˆ–è€…åˆ°è¾¾è¾¹ç•Œ æ›´æ–° $MaxRight$ å’Œ $pos$ æƒ…å†µäºŒï¼š$i$ åœ¨ $MaxRight$ å³è¾¹å¦‚ä¸‹å›¾ï¼š é‡åˆ°è¿™ç§æƒ…å†µï¼Œè¯´æ˜Žä»¥ $i$ ä¸ºå¯¹ç§°è½´çš„å›žæ–‡ä¸²è¿˜æ²¡æœ‰ä»»ä½•ä¸€ä¸ªéƒ¨åˆ†è¢«è®¿é—®è¿‡ï¼ŒäºŽæ˜¯åªèƒ½ä»Ž $i$ çš„å·¦å³ä¸¤è¾¹å¼€å§‹å°è¯•æ‰©å±•äº†ï¼Œå½“å·¦å³ä¸¤è¾¹å­—ç¬¦ä¸åŒï¼Œæˆ–è€…åˆ°è¾¾å­—ç¬¦ä¸²è¾¹ç•Œæ—¶åœæ­¢ã€‚ç„¶åŽæ›´æ–° $MaxRight$ å’Œ $pos$ã€‚ ä»£ç å®žçŽ°æ­¤å¤„ä»¥ LeetCode ä¸Šçš„é¢˜ä¸ºä¾‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: string longestPalindrome(string s) &#123; int len = s.size(); if (len &lt;= 1) return s; string str = preProcess(s); int n = str.size(), pos = 0, MaxRight = 0; vector&lt;int&gt; RL(n, 0); for (int i = 1; i &lt; n - 1; ++i) &#123; RL[i] = MaxRight &gt; i ? min(RL[2 * pos - i], MaxRight - i) : 1; while (str[i + RL[i]] == str[i - RL[i]]) ++RL[i]; if (i + RL[i] &gt; MaxRight) &#123; MaxRight = i + RL[i]; pos = i; &#125; &#125; int maxLen = 0, index = 0; for(int i = 1; i &lt; n - 1; ++i) &#123; if(RL[i] &gt; maxLen) &#123; maxLen = RL[i]; index = i; &#125; &#125; // è¿™é‡Œå¯ä»¥å’Œä¸Šé¢å¹¶åœ¨ä¸€èµ· return s.substr((index - maxLen) / 2, maxLen - 1); &#125; //é¢„å¤„ç†å­—ç¬¦ä¸²ï¼Œabcé¢„å¤„ç†åŽå˜æˆ$#a#b#c#^ string preProcess(const string &amp;s) &#123; int n = s.size(); string res; res.push_back('$'); res.push_back('#'); for(int i = 0; i &lt; n; i++) &#123; res.push_back(s[i]); res.push_back('#'); &#125; res.push_back('^'); return res; &#125; // æ³¨ï¼šæ­¤å¤„å­—ç¬¦ä¸²é¢„å¤„ç†åœ¨å¤´ä¸ŠåŠ å…¥ '$' æ˜¯ä¸ºäº†æ–¹ä¾¿å¤„ç† // å¦‚æžœæ˜¯ç©ºé—´ç˜¤æ‚£è€…ï¼Œç›´æŽ¥åœ¨æœ‰å…³çš„åœ°æ–¹å‡ä¸€å°±è¡Œäº†&#125;; æ€»ç»“Manacher ç®—æ³•å…¶å®žå¯ä»¥ç®—å¥‡æŠ€æ·«å·§å§ï¼Œä¸»è¦è¿˜æ˜¯æŽŒæ¡å®ƒçš„æ€è·¯ï¼Œå……åˆ†åˆ©ç”¨å¾…æ±‚è§£é—®é¢˜çš„æ€§è´¨ï¼Œä»Žè€Œé™ä½Žæ±‚è§£çš„å¤æ‚åº¦ã€‚è¿™ä¸ªä¹Ÿæ˜¯åœ¨ç«žèµ›ä¸­ä¼šç”¨åˆ°çš„æŠ€å·§ã€‚]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>å­—ç¬¦ä¸²</tag>
        <tag>ç®—æ³•</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode åˆ·é¢˜æ—¥å¿—] LeetCode-3 æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²]]></title>
    <url>%2F2018%2F08%2F12%2FLeetCode-%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97-LeetCode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢ä»Šå¤©å¼€å§‹åˆ· LeetCodeï¼Œè™½ç„¶è¯´é‡Œé¢éƒ½æ˜¯å¤§å…¬å¸çš„é¢è¯•é¢˜ï¼Œä½†æ˜¯ä½œä¸ºä¸€ä¸ª OIerï¼Œåˆ·åˆ·ä¹Ÿæ— å¦¨ï¼Œè¿˜èƒ½å¤Ÿæé«˜è‡ªå·±çš„ä»£ç èƒ½åŠ›ã€‚æœ¬æ¥å¸Œæœ›èŠ±ä¸ª 3 å¤©åˆ·å®Œ LeetCodeï¼Œç»“æžœå‘çŽ°è¿™æ˜¯å®Œå…¨ä¸å¯èƒ½çš„ï¼Œä»Šå¤©å°±è¢«å¾ˆåŸºç¡€çš„ç¬¬ä¸‰é¢˜ç»™å¡ä½äº†â€¦â€¦ LeetCode-3 é¢˜è§£â€”â€”å‘äººçš„å¤§æ°´é¢˜ é¢˜ç›®æè¿°ï¼š ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºä¸å«æœ‰é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚ ç¤ºä¾‹ï¼š ç»™å®š &quot;abcabcbb&quot; ï¼Œæ²¡æœ‰é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ &quot;abc&quot; ï¼Œé‚£ä¹ˆé•¿åº¦å°±æ˜¯3ã€‚ ç»™å®š &quot;bbbbb&quot; ï¼Œæœ€é•¿çš„å­ä¸²å°±æ˜¯ &quot;b&quot; ï¼Œé•¿åº¦æ˜¯1ã€‚ ç»™å®š &quot;pwwkew&quot; ï¼Œæœ€é•¿å­ä¸²æ˜¯ &quot;wke&quot; ï¼Œé•¿åº¦æ˜¯3ã€‚è¯·æ³¨æ„ç­”æ¡ˆå¿…é¡»æ˜¯ä¸€ä¸ªå­ä¸²ï¼Œ&quot;pwke&quot; æ˜¯ å­åºåˆ— è€Œä¸æ˜¯å­ä¸²ã€‚ [é¢˜è§£] ç›´æŽ¥ä¸Šä»£ç ï¼Œå…·ä½“è¯´æ˜Žçœ‹æ³¨é‡Šã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public: int lengthOfLongestSubstring(string s) &#123; int maxLen = 0; int currLen = 0; // table ç”¨äºŽè®°å½•å­—ç¬¦å‡ºçŽ°çš„æ¬¡æ•°ï¼Œä¹‹æ‰€ä»¥è®¾ä¸º 128 æ˜¯ä¸ºäº†é€‚é… ASCII ç  int table[128], start = 0; // å…¨éƒ¨åˆå§‹åŒ–ä¸º 0 memset(table, 0, sizeof(table)); for (int i = 0; i &lt; s.length(); ++i) &#123; // å¦‚æžœ ++table[s[i]] ä¸º 2ï¼Œåˆ™è¯´æ˜Žè¿™ä¸ªæ•°åœ¨æ‰€é€‰çš„å­ä¸²ä¸­å·²ç»å‡ºçŽ°è¿‡äº† // å½“ç„¶è¿™é‡Œè¿˜æœ‰å¥½å¤šå†™æ³• if (++table[s[i]] == 2) &#123; // å› ä¸ºé‡åˆ°é‡å¤çš„å­—ç¬¦äº†ï¼Œæ‰€ä»¥è¦å…ˆæ›´æ–° maxLen if (currLen &gt; maxLen) maxLen = currLen; // æŽ¥ä¸‹æ¥æŸ¥æ‰¾é‡å¤çš„æ•°å­—å‡ºçŽ°çš„åœ°æ–¹ï¼Œå¹¶ä¸”æ›´æ–°å­—ä¸²èµ·å§‹ä½ç½® // è¿™é‡Œå¯ä»¥ä¼˜åŒ–ï¼šä½¿ç”¨ä¸€ä¸ª map&lt;char, int&gt; // æˆ– table0[128] æ¥è®°å½•å­—ç¬¦çš„å‡ºçŽ°ä½ç½® // åŒæ—¶ä¹Ÿå¯ä»¥ä¸Žå‰é¢çš„ table æ•°ç»„åˆå¹¶ï¼Œæ—¢åŠ å¿«é€Ÿåº¦åˆå‡å°‘ç©ºé—´ // è¿™é‡Œå› ä¸ºä¸éœ€è¦ï¼ˆæ‡’ï¼‰ï¼Œæ‰€ä»¥å°±æ‰“äº†è¿™ä¸ªæœªä¼˜åŒ–çš„ç®—æ³• // æœ‰å…´è¶£çš„è¯»è€…å¯ä»¥åŽ»è¯•ä¸€è¯•ä¼˜åŒ–ç®—æ³•ã€‚ for (int j = start; j &lt; i; ++j) &#123; if (s[j] == s[i]) &#123; table[s[j]] = 1; start = j + 1; break; // å› ä¸ºæœ€å¤šå‡ºçŽ°ä¸€æ¬¡ï¼Œæ‰€ä»¥ç›´æŽ¥ break &#125; else &#123; // æ²¡æ‰¾åˆ°çš„è¯å¿…é¡»å‡å°ç­”æ¡ˆ --currLen; // é‡ç½® table[s[j]] = 0; &#125; &#125; &#125; else ++currLen; // æ²¡æœ‰é‡å¤å°±ç›´æŽ¥è‡ªåŠ ä¸€ &#125; // æœ€åŽçš„åˆ¤æ–­å¿…ä¸å¯å°‘ if (currLen &gt; maxLen) maxLen = currLen; return maxLen; &#125;&#125;;// ç”±äºŽæœ¬äººæ˜¯ä¸€ä¸ª OIerï¼Œè¿˜æ˜¯ Google èµ„æ·±è€ç²‰ä¸ï¼Œæ‰€ä»¥ä»£ç é£Žæ ¼æ¯”è¾ƒæ··æ­ï¼ˆé€ƒï¼‰ã€‚ é‚£ä¹ˆï¼Œæ˜¯ä»€ä¹ˆå¡äº†æˆ‘é‚£ä¹ˆé•¿æ—¶é—´å‘¢ï¼Ÿä¸€å¼€å§‹çš„ä»£ç é‡åˆ°é‡å¤çš„å­—ç¬¦ï¼Œç›´æŽ¥æ›´æ–°èµ·å§‹ä½ç½®åˆ°å½“å‰å­—ç¬¦ï¼Œæ®Šä¸çŸ¥ä¼šæœ‰ abcdaefg è¿™ç§æƒ…å†µï¼ŒäºŽæ˜¯ä¸€ç›´ WAã€‚è®ºå……åˆ†æ€è€ƒçš„é‡è¦æ€§â€¦.. æ€»ç»“LeetCode çš„é¢˜ç›®éš¾åº¦å¹¶ä¸æ˜¯å¾ˆå¤§çš„ï¼Œå¾ˆå¤šé¢˜å·®ä¸å¤šæ˜¯æé«˜-çš„éš¾åº¦ï¼Œä½†æ˜¯ç»†èŠ‚å¤ªå¤šï¼ŒåŒæ—¶å¯¹ä»£ç èƒ½åŠ›çš„è¦æ±‚æ¯”è¾ƒé«˜ï¼ŒæŸäº›æ•°æ®ç»“æž„ä¹Ÿä¸Ž OI ä¸­æ‰€å†™åœ°ä¸å¤ªä¸€æ ·ã€‚ä½†æ˜¯å½“ä½œç®—æ³•è®­ç»ƒåœºæ¥åšä¹Ÿæ²¡ä»€ä¹ˆåå¤„ã€‚]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>å­—ç¬¦ä¸²</tag>
        <tag>ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ç®—æ³•] RMQ é—®é¢˜ä¸Ž ST ç®—æ³•]]></title>
    <url>%2F2018%2F08%2F11%2F%E7%AE%97%E6%B3%95-RMQ-%E9%97%AE%E9%A2%98%E4%B8%8E-ST-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢å› ä¸ºå¾ˆå¤šæ¬¡æ¨¡æ‹Ÿæµ‹è¯•éƒ½è´¥åœ¨åŒºé—´æœ€å€¼é—®é¢˜ï¼ˆRMQï¼‰ä¸Šï¼Œæ‰€ä»¥å†³å®šå¼€ä¸€ç¯‡åšå®¢å¥½å¥½æ€»ç»“ä¸€ä¸‹ã€‚æœ¬ç¯‡æ–‡ç« ç€é‡ä»‹ç» RMQ é—®é¢˜ä¸­æœ€è‘—åçš„ ST ç®—æ³•ã€‚ RMQ é—®é¢˜ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $N$ çš„æ•°åˆ— $A$ï¼Œç„¶åŽè¿›è¡Œè‹¥å¹²æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡ç»™å®šä¸€ä¸ªåŒºé—´ $[l_i,r_i]$ æ±‚è¿™ä¸ªåŒºé—´ä¸­çš„æœ€å¤§æˆ–æœ€å°å€¼ï¼Œè¿™å°±æ˜¯åŒºé—´æœ€å€¼é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯ RMQ é—®é¢˜ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¿™æ ·çš„é—®é¢˜éƒ½è¦æ±‚åŒºé—´çš„æŸ¥è¯¢æ˜¯åœ¨çº¿çš„ï¼Œä¹Ÿå°±æ˜¯æå‡ºä¸€ä¸ªæŸ¥è¯¢å›žç­”ä¸€æ¬¡ï¼Œä¸èƒ½å…¨éƒ¨æ”¶åˆ°åŽç»Ÿä¸€å›žç­”ã€‚å¯¹äºŽæŸäº›ç¡®å®šåŒºé—´æ±‚æœ€å€¼çš„é—®é¢˜ï¼Œé€šå¸¸é‡‡ç”¨å€å¢žçš„æ–¹æ³•æ¥æ±‚è§£ã€‚è€Œ ST ç®—æ³•å…¶å®žå°±æ˜¯å€å¢žçš„äº§ç‰©ï¼ŒåŒæ—¶åŠ å…¥äº†åŠ¨æ€è§„åˆ’çš„æ€æƒ³ã€‚ ST ç®—æ³•åœ¨ RMQ é—®é¢˜ä¸­ï¼ŒST ç®—æ³•å¯ä»¥åœ¨ $O(NlogN)$ çš„æ—¶é—´é¢„å¤„ç†æ•°æ®åŽï¼Œä»¥ $O(1)$ çš„æ—¶é—´åœ¨çº¿å›žç­”æŸ¥è¯¢ã€‚ä¸€ä¸ªåºåˆ—çš„å­ç©ºé—´ä¸ªæ•°æ˜¾ç„¶æœ‰ $O(N^2)$ ä¸ªï¼Œæˆ‘ä»¬é¦–å…ˆåœ¨è¿™ä¸ªè§„æ¨¡ä¸º $O(N^2)$ çš„çŠ¶æ€ç©ºé—´ä¸­é€‰æ‹©ä¸€äº› $2$ çš„æ•´æ•°æ¬¡å¹‚çš„ä½ç½®ä½œä¸ºä»£è¡¨å€¼ã€‚ è®¾ $F[i,j]$ è¡¨ç¤ºå­ç©ºé—´ $A$ ä¸­ä¸‹æ ‡åœ¨åœ¨å­åŒºé—´ $[i,i+2^j-1]$ é‡Œæ•°çš„æœ€å¤§å€¼ï¼Œå³ä»Ž $i$ å¼€å§‹çš„ $2^j$ ä¸ªæ•°çš„æœ€å¤§å€¼ã€‚æ˜¾ç„¶ $F[i,0]=A[i]$ï¼Œå³æ•°åˆ— $A$ åœ¨å­åŒºé—´ $[i,i]$ ä¸­çš„æœ€å¤§å€¼ã€‚ é€’æŽ¨æ—¶ï¼Œæˆ‘ä»¬å°†å­åŒºé—´é•¿åº¦æˆå€å¢žé•¿ï¼Œå…¬å¼å¦‚ä¸‹ï¼š $$F[i,j]=max\lbrace F[i,j-1],F[i+2^{j-1},j-1] \rbrace$$ å³é•¿åº¦ä¸º $2^j$ çš„å­åŒºé—´çš„æœ€å¤§å€¼æ˜¯å·¦å³ä¸¤åŠé•¿åº¦ä¸º $2^{j-1}$ çš„å­åŒºé—´çš„æœ€å¤§å€¼ä¸­è¾ƒå¤§çš„é‚£ä¸€ä¸ªã€‚æ‰€ä»¥æˆ‘ä»¬å…ˆé¢„å¤„ç†æˆ‘ä»¬è¦ç”¨åˆ°çš„æ•°ç»„ï¼š 1234567void STprework() &#123; for (int i = 1; i &lt;= n; ++i) f[i][0] = a[i]; int t = log(n) / log(2) + 1; for (int j = 1; j &lt; t; ++j) for (int i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; ++i) f[i][j] = max(f[i][j - 1], f[i + (1 &lt;&lt; (j - 1))][j - 1]);&#125; å½“æˆ‘ä»¬è¦æŸ¥è¯¢åŒºé—´ $[l,r]$ çš„æœ€å€¼æ—¶ï¼Œæˆ‘ä»¬å…ˆè®¡ç®—å‡ºä¸€ä¸ª $k$ï¼Œæ»¡è¶³ $2^k &lt; r-l+1 \leqslant 2^{k+1}$ï¼Œä¹Ÿå°±æ˜¯ä½¿äºŒçš„ $k$ æ¬¡å¹‚å°äºŽåŒºé—´é•¿åº¦çš„å‰æä¸‹æœ€å¤§çš„ $k$ã€‚é‚£ä¹ˆâ€œä»Ž $l$ å¼€å§‹çš„ $2^k$ ä¸ªæ•°â€å’Œâ€œä»¥ $r$ ç»“å°¾çš„ $2^k$ ä¸ªæ•°â€ è¿™ä¸¤æ®µä¸€å®šè¦†ç›–äº†åŽŸæ¥çš„æ•´ä¸ªåŒºé—´ï¼Œè¿™ä¸¤æ®µçš„æœ€å¤§å€¼åˆ†åˆ«ä¸º $F[l,k]$ å’Œ $F[r-2^k+1,k]$ï¼ŒäºŒè€…ä¸­è¾ƒå¤§çš„å°±æ˜¯æ•´ä¸ªåŒºé—´çš„æœ€å€¼ã€‚å› ä¸ºæ±‚çš„æ˜¯æœ€å¤§å€¼ï¼Œæ‰€ä»¥åªè¦è¦†ç›–åŒºé—´å°±è¡Œï¼Œé‡å æ˜¯æ²¡æœ‰å…³ç³»çš„ã€‚ 1234int STquery(int l, int r) &#123; int k = log(r - l + 1) / log(2); return max(f[l][k], f[r - (1 &lt;&lt; k) + 1][k]);&#125; å¦‚æžœè¦è¿›ä¸€æ­¥æé«˜æ‰§è¡Œæ•ˆçŽ‡ï¼Œå¯ä»¥å°† $f$ æ•°ç»„çš„ä¸¤ä¸ªç»´åº¦äº¤æ¢ï¼Œè¿™æ ·å¯¹ç¼“å­˜æ›´åŠ å‹å¥½ã€‚å¹¶ä¸”å¯ä»¥é¢„å¤„ç†å‡º $1 \thicksim n$ ä¸­ $log_2 n$ çš„å€¼ï¼Œç”šè‡³æ˜¯å„ä¸ªåŒºé—´å¯¹åº”çš„ $k$ çš„å€¼ï¼Œå…·ä½“æ–¹æ³•è§†æƒ…å†µè€Œå®šã€‚ æ€»ç»“ ä¸ºä»€ä¹ˆä½¿ç”¨ log() å‡½æ•°è€Œä¸æ˜¯ log2() å‘¢ï¼ŒåŽŸå› æ˜¯å‰è€…æ•ˆçŽ‡æ›´å¿«ï¼Œè€Œä¸”ä¼—æ‰€å‘¨çŸ¥ï¼Œå¯¹æ•°æ˜¯æœ‰æ¢åº•å…¬å¼çš„ï¼ˆå•¥ï¼Ÿä½ ä¸çŸ¥é“ï¼Ÿèµ¶ç´§è¡¥ä¸€ä¸‹é«˜ä¸­æ•°å­¦å¿…ä¿®ä¸€å§ï¼ï¼‰ï¼Œæ‰€ä»¥è¿™é‡Œæ•ˆçŽ‡ä¼šé«˜ä¸€ç‚¹ ST è¡¨çš„æ¨¡æ¿é¢˜åœ°å€â€”â€”æ´›è°· p3865 é™„ä¸Šå®Œæ•´ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define max(a, b) (a &gt; b ? a : b)#define G(a) putchar(a + 48)int n, m, A[maxn];int li, ri;int f[21][maxn];int logn[maxn];inline int read() &#123; int ans = 0; char c; bool sign = false; while (!isdigit(c = getchar()) &amp;&amp; c != '-'); if (c == '-') &#123; sign = true; c = getchar(); &#125; do &#123; ans = (ans &lt;&lt; 3) + (ans &lt;&lt; 1) + (c - '0'); &#125; while (isdigit(c = getchar())); return sign ? -ans : ans;&#125;inline void write(int s)&#123; if (s &lt; 0) &#123; G(-3); s = -s; &#125; if (s &gt; 9) write(s / 10); G(s % 10);&#125;void STprework() &#123; for (int i = 1; i &lt;= n; ++i) f[0][i] = A[i]; int t = logn[n] + 1; for (int j = 1; j &lt; t; ++j) for (int i = 1; i &lt;= n - (1 &lt;&lt; j) + 1; ++i) f[j][i] = max(f[j - 1][i], f[j - 1][i + (1 &lt;&lt; (j - 1))]);&#125;int STquery(int l, int r) &#123; int k = logn[r - l + 1]; return max(f[k][l], f[k][r - (1 &lt;&lt; k) + 1]);&#125;void pre() &#123; logn[1] = 0; logn[2] = 1; for (int i = 3; i &lt;= n; ++i) logn[i] = logn[i / 2] + 1;&#125;int main() &#123; n = read(); m = read(); for (int i = 1; i &lt;= n; ++i) A[i] = read(); pre(); STprework(); for (int i = 1; i &lt;= m; ++i) &#123; li = read(); ri = read(); write(STquery(li, ri)); putchar('\n'); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ç®—æ³•</category>
      </categories>
      <tags>
        <tag>ç®—æ³•</tag>
        <tag>RMQ é—®é¢˜</tag>
        <tag>ST ç®—æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[å›¾è®º] å›¾è®ºåŸºç¡€çŸ¥è¯†]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%9B%BE%E8%AE%BA-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢å› ä¸ºè‡ªå·±çš„å›¾è®ºå…¶å®žæŽŒæ¡å¾—ä¸æ€Žä¹ˆæ ·ï¼Œæ‰€ä»¥å¼€ä¸€ç¯‡åšå®¢ï¼Œæ¥åŠ æ·±ä¸€ä¸‹è‡ªå·±å›¾è®ºçš„åŸºç¡€ã€‚æ³¨æ„ï¼Œæœ¬æ–‡åªæ˜¯åŸºç¡€ï¼Œä¸»è¦æ™®åŠå›¾çš„å­˜å‚¨ï¼Œæœ€çŸ­è·¯å’ŒéåŽ†ï¼ˆ$DFS$ å’Œ $BFS$ï¼‰ã€‚ å®šä¹‰åœ¨å›¾è®ºä¸­ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€å¼ å›¾ä¸ºç”±é¡¶ç‚¹é›†ï¼ˆVerticesï¼‰å’Œè¾¹é›†ï¼ˆEdgesï¼‰ç»„æˆçš„äºŒå…ƒç»„ï¼Œå³ $G = (V, E)$ã€‚æ­¤å¤„ $V$ å’Œ $E$ ä¹Ÿå¯å†™ä¸º $V(G)$ å’Œ $E(G)$ã€‚ åŸºæœ¬æœ¯è¯­é˜¶ï¼ˆOrderï¼‰ï¼šå›¾ $G$ ä¸­é¡¶é›† $V$ çš„å¤§å°ç§°ä½œå›¾ $G$ çš„é˜¶ã€‚ å­å›¾ï¼ˆSub-Graphï¼‰ï¼šå›¾ $Gâ€™$ ç§°ä½œå›¾ $G$ çš„å­å›¾å¦‚æžœ $V(Gâ€™)\subseteq V(G)$ ä»¥åŠ $E(Gâ€™)\subseteq E(G)$ã€‚ ç”Ÿæˆå­å›¾ï¼ˆSpanning Sub-Graphï¼‰ï¼šæŒ‡æ»¡è¶³æ¡ä»¶ $V(Gâ€™)=V(G)$ çš„ $G$ çš„å­å›¾ $Gâ€™$ã€‚ åº¦ï¼ˆDegreeï¼‰æ˜¯ä¸€ä¸ªé¡¶ç‚¹çš„åº¦æ˜¯æŒ‡ä¸Žè¯¥é¡¶ç‚¹ç›¸å…³è”çš„æ€»è¾¹æ•°ï¼Œé¡¶ç‚¹ $v$ çš„åº¦è®°ä½œ $d(v)$ã€‚åº¦å’Œè¾¹æœ‰å¦‚ä¸‹å…³ç³»ï¼š$\sum_{v\in V} d(v)=2\left|E\right|$ã€‚ å‡ºåº¦ï¼ˆOut-degreeï¼‰å’Œå…¥åº¦ï¼ˆIn-degreeï¼‰ï¼šå¯¹æœ‰å‘å›¾è€Œè¨€ï¼Œé¡¶ç‚¹çš„åº¦è¿˜å¯åˆ†ä¸ºå‡ºåº¦å’Œå…¥åº¦ã€‚ä¸€ä¸ªé¡¶ç‚¹çš„å‡ºåº¦ä¸º $d_o$ ï¼Œæ˜¯æŒ‡æœ‰ $d_o$ æ¡è¾¹ä»¥è¯¥é¡¶ç‚¹ä¸ºèµ·ç‚¹ï¼Œæˆ–è¯´ä¸Žè¯¥ç‚¹å…³è”çš„å‡ºè¾¹å…±æœ‰ $d_o$ æ¡ã€‚å…¥åº¦çš„æ¦‚å¿µä¹Ÿç±»ä¼¼ã€‚ è‡ªçŽ¯ï¼ˆLoopï¼‰ï¼šè‹¥ä¸€æ¡è¾¹çš„ä¸¤ä¸ªé¡¶ç‚¹ç›¸åŒï¼Œåˆ™æ­¤è¾¹ç§°ä½œè‡ªçŽ¯ã€‚ è·¯å¾„ï¼ˆPathï¼‰ï¼šä»Žé¡¶ç‚¹uåˆ°é¡¶ç‚¹vçš„ä¸€æ¡è·¯å¾„æ˜¯æŒ‡ä¸€ä¸ªåºåˆ— $v_0,e_1,v_1,e_2,v_2,â€¦e_k,v_k$ï¼Œ$e_i$ çš„èµ·ç‚¹ç»ˆç‚¹ä¸º $v_{i-1}$ åŠ $v_i$ï¼› $k$ ç§°ä½œè·¯å¾„çš„é•¿åº¦ï¼› $v_0=u$ï¼Œç§°ä¸ºè·¯å¾„çš„èµ·ç‚¹ï¼›$v_k=v$ï¼Œç§°ä¸ºè·¯å¾„çš„ç»ˆç‚¹ã€‚å¦‚æžœ $u=v$ï¼Œç§°è¯¥è·¯å¾„æ˜¯é—­çš„ï¼Œåä¹‹åˆ™ç§°ä¸ºå¼€çš„ï¼›å¦‚æžœ $v_1,â€¦,v_k$ ä¸¤ä¸¤ä¸ç­‰ï¼Œåˆ™ç§°ä¹‹ä¸ºç®€å•è·¯å¾„ï¼ˆSimple pathï¼Œæ³¨æ„ï¼Œ $u=v$ æ˜¯å…è®¸çš„ï¼‰ã€‚ è¡Œè¿¹ï¼ˆTraceï¼‰ï¼šå¦‚æžœè·¯å¾„ $P(u,v)$ ä¸­è¾¹å„ä¸ç›¸åŒï¼Œåˆ™è¯¥è·¯å¾„ç§°ä¸º $u$ åˆ° $v$ çš„ä¸€æ¡è¡Œè¿¹ã€‚ è½¨é“ï¼ˆTrackï¼‰ï¼šå³ç®€å•è·¯å¾„ã€‚ é—­çš„è¡Œè¿¹ç§°ä½œå›žè·¯ï¼ˆCircuitï¼‰ï¼Œé—­çš„è½¨é“ç§°ä½œåœˆï¼ˆCycleï¼‰ã€‚ï¼ˆçŽ°å­˜æ–‡çŒ®ä¸­çš„å‘½åæ³•å¹¶æ— ç»Ÿä¸€æ ‡å‡†ã€‚æ¯”å¦‚åœ¨å¦ä¸€ç§å®šä¹‰ä¸­ï¼Œwalk å¯¹åº”ä¸Šè¿°çš„ pathï¼Œpath å¯¹åº”ä¸Šè¿°çš„ trackï¼Œtrailå¯¹åº”ä¸Šè¿°çš„ traceã€‚ï¼‰ è·ç¦»ï¼ˆDistanceï¼‰ï¼šä»Žé¡¶ç‚¹ $u$ å‡ºå‘åˆ°é¡¶ç‚¹ $v$ çš„æœ€çŸ­è·¯å¾„è‹¥å­˜åœ¨ï¼Œåˆ™æ­¤è·¯å¾„çš„é•¿åº¦ç§°ä½œä»Ž $u$ åˆ° $v$ çš„è·ç¦»ã€‚è‹¥ä»Ž $u$ åˆ° $v$ æ ¹æœ¬ä¸å­˜åœ¨è·¯å¾„ï¼Œåˆ™è®°è¯¥è·ç¦»ä¸ºæ— ç©·ï¼ˆ$\infty$ï¼‰ã€‚ æ¡¥ï¼ˆBridgeï¼‰ï¼šè‹¥åŽ»æŽ‰ä¸€æ¡è¾¹ï¼Œä¾¿ä¼šä½¿å¾—æ•´ä¸ªå›¾ä¸è¿žé€šï¼Œè¯¥è¾¹ç§°ä¸ºæ¡¥ã€‚ ç¼–ç¨‹å®žçŽ°å›¾çš„å­˜å‚¨é‚»æŽ¥çŸ©é˜µå­˜å›¾12345678910111213#define maxn 100#define INF 0x3fint g[maxn][maxn];void init() &#123; memset(g, INF, sizeof(g)); &#125; // åˆå§‹åŒ–void addEdge(int vertex1, int vertex2, int wieght) &#123; g[vertex1][vertex2] = weight;&#125; // æ·»åŠ ä¸€æ¡å•å‘è¾¹void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // æ·»åŠ ä¸€æ¡åŒå‘è¾¹ / æ— å‘è¾¹ å…¶ä¸­ $g[i][j]$ è¡¨ç¤ºä»Ž $i$ åˆ° $j$ çš„è¾¹çš„æƒã€‚æ³¨æ„é‚»æŽ¥çŸ©é˜µæ–¹ä¾¿ä½¿ç”¨ï¼Œä½†ç©ºé—´å¤æ‚åº¦ä¸º $O(n^2)$ï¼Œåœ¨ç‚¹æ¯”è¾ƒå¤šçš„æ—¶å€™ä¸å¤ªå®žç”¨ï¼Œæžæœ‰å¯èƒ½ä¼šçˆ†ã€‚ é‚»æŽ¥è¡¨å­˜å›¾å…ˆä¸Šä»£ç ï¼š 1234567891011121314151617181920212223242526272829#define maxn 11000#define maxm 21000#define NOE -1int v[maxm], e[maxm], heads[maxn], nxt[maxm]int tot = 0;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;// åˆå§‹åŒ–void addEdge(int vertex1, int vertex2, int weight) &#123; tot++; v[tot] = vertex2; e[tot] = weight; nxt[tot] = heads[vertex1]; heads[vertex1] = tot;&#125; // åŠ è¾¹void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // åŠ åŒå‘è¾¹void travel(int x) &#123; for (int i = heads[x]; i != NOE; i = nxt[i]) &#123; int y = v[i]; int x = e[i]; // æ‰¾åˆ°ä¸€æ¡æœ‰å‘è¾¹ (x, y) è¾¹æƒä¸º z // do something here &#125; // éåŽ†ä»Ž x å‡ºå‘çš„è¾¹&#125; $v[]$ å’Œ $e[]$ è®°å½•äº†æ¯æ¡è¾¹çš„ç»ˆç‚¹å’Œè¾¹æƒï¼Œ$nxt[]$æ¨¡æ‹ŸæŒ‡é’ˆï¼Œè¡¨ç¤ºä»Žæƒ³åŒèŠ‚ç‚¹å‡ºå‘çš„ä¸‹ä¸€æ¡è¾¹åœ¨ $v[]$ å’Œ $e[]$ ä¸­çš„å­˜å‚¨ä½ç½®ï¼Œ$heads[i]$ è¡¨ç¤ºä»Ž $i$ å‡ºå‘çš„ç¬¬ä¸€æ¡è¾¹ã€‚ä¿¡æ¯å¥¥èµ›ä¸­ä½¿ç”¨æ•°ç»„æ¨¡æ‹ŸæŒ‡é’ˆè¶³å¤Ÿäº†ï¼Œå¦‚æžœæƒ³çŸ¥é“å…·ä½“çš„é‚»æŽ¥è¡¨çš„ç›¸å…³çŸ¥è¯†çœ‹è¿™é‡Œï¼šWikipedia é“¾å¼å‰å‘æ˜Ÿä¸ªäººè®¤ä¸ºæœ€å¥½çš„å­˜å›¾æ–¹å¼ï¼Œè™½ç„¶ä¸Žé‚»æŽ¥è¡¨æ²¡æœ‰å¤ªå¤§åŒºåˆ«ï¼Œä½†æ˜¯å¥½å†™å¤šäº†ï¼ˆä¸ŽçœŸæ­£çš„é‚»æŽ¥è¡¨å¯¹æ¯”ï¼Œä¸æ˜¯ OI ä¸­çš„é˜‰å‰²ç‰ˆï¼‰ã€‚ 12345678910111213141516171819202122232425262728293031323334#define maxn 11000#define maxm 21000#define NOE -1struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125;;edgeNode edges[maxm];int heads[maxn];int numEdges = 0;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125; // åŠ è¾¹void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125; // åŠ åŒå‘è¾¹void travel(int x) &#123; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; int z = edges[i].weight; // æ‰¾åˆ°ä¸€æ¡æœ‰å‘è¾¹ (x, y) è¾¹æƒä¸º z // do something here &#125; // éåŽ†ä»Ž x å‡ºå‘çš„è¾¹&#125; å¤šå†™å†™å°±ä¼šç†Ÿæ‚‰äº†ã€‚ å›¾çš„éåŽ†æ·±åº¦ä¼˜å…ˆéåŽ† DFSæ·±åº¦ä¼˜å…ˆæœç´¢æ³•æ˜¯æ ‘çš„å…ˆåºéåŽ†çš„æŽ¨å¹¿ï¼Œå®ƒçš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šä»Žå›¾ $G$ çš„æŸä¸ªé¡¶ç‚¹ $v_0$ å‡ºå‘ï¼Œè®¿é—® $v_0$ï¼Œç„¶åŽé€‰æ‹©ä¸€ä¸ªä¸Ž $v_0$ ç›¸é‚»ä¸”æ²¡è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹ $v_i$ è®¿é—®ï¼Œå†ä»Ž $v_i$ å‡ºå‘é€‰æ‹©ä¸€ä¸ªä¸Ž $v_i$ ç›¸é‚»ä¸”æœªè¢«è®¿é—®çš„é¡¶ç‚¹ $v_j$ è¿›è¡Œè®¿é—®ï¼Œä¾æ¬¡ç»§ç»­ã€‚å¦‚æžœå½“å‰è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹çš„æ‰€æœ‰é‚»æŽ¥é¡¶ç‚¹éƒ½å·²è¢«è®¿é—®ï¼Œåˆ™é€€å›žåˆ°å·²è¢«è®¿é—®çš„é¡¶ç‚¹åºåˆ—ä¸­æœ€åŽä¸€ä¸ªæ‹¥æœ‰æœªè¢«è®¿é—®çš„ç›¸é‚»é¡¶ç‚¹çš„é¡¶ç‚¹ $w$ï¼Œä»Ž $w$ å‡ºå‘æŒ‰åŒæ ·çš„æ–¹æ³•å‘å‰éåŽ†ï¼Œç›´åˆ°å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®ã€‚å…·ä½“å®žçŽ°å¦‚ä¸‹ï¼š 12345678910bool visited[maxn];void initDFS() &#123; memset(visited, false, sizeof(visited)); &#125;void rDFS(int x) &#123; visited[x] = true; visit(); // æ ¹æ®å…·ä½“æƒ…å†µå®šä¹‰ visit() for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) if (!visited[edges[i].vertexTo]) rDFS(edges[i].vertexTo); return; // æœ€å¥½åŠ ä¸Š return&#125; // å› ä¸ºè¿™æ˜¯é€’å½’å®žçŽ°çš„ï¼Œæ•…å‘½åä¸º rDfS $DFS$ å…¨ç§°ä¸º $Depth$ $First$ $Search$ï¼Œå…¶å®žæ˜¯ä¸€ä¸ªæœç´¢ç®—æ³•ï¼Œæœ‰å…³æœç´¢çš„ç®—æ³•ï¼Œæœªæ¥ä¼šå¼€ä¸ªä¸“é¢˜è¯¦ç»†è®²è§£ï¼Œé€šä¿—çš„è¯­è¨€æ¦‚æ‹¬å°±æ˜¯ä¸é¡¾ä¸€åˆ‡å‘å‰å†²ï¼Œæ’žå¢™äº†å†å›žå¤´ã€‚ å¯¹äºŽä¸‹é¢è¿™ä¹ˆä¸€å¼ å›¾ï¼š å®ƒçš„éåŽ†æ–¹å¼å¦‚ä¸‹ï¼š éåŽ†é¡ºåºï¼š$$v_1 \rightarrow v_2 \rightarrow v_4 \rightarrow v_8 \rightarrow v_5 \rightarrow v_3 \rightarrow v_6 \rightarrow v_7$$ $DFS$ è¿˜æ˜¯å¾ˆå¸¸ç”¨çš„ï¼Œå±žäºŽå¿…å¤‡çŸ¥è¯†ã€‚ å¹¿åº¦ä¼˜å…ˆéåŽ† BFSå›¾çš„å¹¿åº¦ä¼˜å…ˆæœç´¢æ˜¯æ ‘çš„æŒ‰å±‚æ¬¡éåŽ†çš„æŽ¨å¹¿ï¼Œå®ƒçš„åŸºæœ¬æ€æƒ³æ˜¯ï¼šé¦–å…ˆè®¿é—®åˆå§‹ç‚¹ $v_i$ï¼Œå¹¶å°†å…¶æ ‡è®°ä¸ºå·²è®¿é—®è¿‡ï¼ŒæŽ¥ç€è®¿é—® $v_i$ çš„æ‰€æœ‰æœªè¢«è®¿é—®è¿‡çš„é‚»æŽ¥ç‚¹ $v_{i1},v_{i2},â€¦,v_{it}$ï¼Œå¹¶å‡æ ‡è®°å·²è®¿é—®è¿‡ï¼Œç„¶åŽå†æŒ‰ç…§ $v_{i1},v_{i2},â€¦,v_{it}$çš„æ¬¡åºï¼Œè®¿é—®æ¯ä¸€ä¸ªé¡¶ç‚¹çš„æ‰€æœ‰æœªè¢«è®¿é—®è¿‡çš„é‚»æŽ¥ç‚¹ï¼Œå¹¶å‡æ ‡è®°ä¸ºå·²è®¿é—®è¿‡ï¼Œä¾æ¬¡ç±»æŽ¨ï¼Œç›´åˆ°å›¾ä¸­æ‰€æœ‰å’Œåˆå§‹ç‚¹ $v_i$ æœ‰è·¯å¾„ç›¸é€šçš„é¡¶ç‚¹éƒ½è¢«è®¿é—®è¿‡ä¸ºæ­¢ã€‚éžé€’å½’å®žçŽ°å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324queue&lt;int&gt; Q;int dep[maxn];void initBFS() &#123; memset(dep, 0, sizeof(dep)); while (!Q.empty()) Q.pop();&#125;void BFS() &#123; Q.push(1); dep[1] = 1; // dep[i] è¡¨ç¤ºèŠ‚ç‚¹ i çš„æ·±åº¦ï¼Œå³ä»Ž 1 åˆ° i éœ€è¦èµ°è¿‡çš„æœ€å°‘ç‚¹æ•° while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int y = edges[i].vertexTo; if (dep[y]) continue; // è¿™é‡Œç›´æŽ¥ä½¿ç”¨ dep[] æ¥æ›¿ä»£ visited[]ï¼Œé¡ºä¾¿æ±‚å‡ºç‚¹çš„æ·±åº¦ dep[y] = dep[x] + 1; Q.push(y); &#125; &#125;&#125; å¯¹äºŽä¸‹é¢è¿™ä¹ˆä¸€å¼ å›¾ï¼š å®ƒçš„éåŽ†æ–¹å¼å¦‚ä¸‹ï¼š éåŽ†é¡ºåºï¼š$$v_1\rightarrow v_2\rightarrow v_3\rightarrow v_4\rightarrow v_5\rightarrow v_6\rightarrow v_7\rightarrow v_8$$ æœ€çŸ­è·¯å¾„ç®—æ³•Floyd æ±‚å¤šæºæœ€çŸ­è·¯Floyd çš„æœ¬è´¨æ˜¯åŠ¨æ€è§„åˆ’ï¼Œæˆ‘ä»¬ä»¤ $D[i,j,k]$ è¡¨ç¤ºç»è¿‡è‹¥å¹²ä¸ªç¼–å·ä¸è¶…è¿‡ $k$ çš„èŠ‚ç‚¹ï¼Œä»Ž $i$ åˆ° $j$ çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚è¯¥é—®é¢˜å¯ä»¥åˆ’åˆ†æˆä¸¤ä¸ªå­é—®é¢˜ï¼Œç»è¿‡ç¼–å·ä¸è¶…è¿‡ $k-1$ çš„èŠ‚ç‚¹ä»Ž $i$ åˆ° $j$ï¼Œæˆ–è€…ä»Ž $i$ å…ˆåˆ° $k$ å†åˆ° $j$ï¼ŒäºŽæ˜¯æˆ‘ä»¬å†™å‡ºåŠ¨æ€è§„åˆ’æ–¹ç¨‹ï¼š $$D[i,j,k]=min\lbrace D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]\rbrace$$ æ³¨æ„ï¼Œ$k$ æ˜¯é˜¶æ®µï¼Œæ‰€ä»¥å¿…é¡»ç½®äºŽå¤–å±‚å¾ªçŽ¯ä¸­ï¼Œ$i$ å’Œ $j$ æ˜¯é™„åŠ çŠ¶æ€ï¼Œæ‰€ä»¥ç½®äºŽå†…å±‚å¾ªçŽ¯ã€‚ ä¸ŽèƒŒåŒ…é—®é¢˜ç±»ä¼¼ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥ $k$ è¿™ä¸€ç»´ï¼ŒäºŽæ˜¯æˆ‘ä»¬æœ‰ï¼š $$D[i,j]=min\lbrace D[i,j],D[i,k]+D[k,j]\rbrace$$ $D[i,j]$ ä¿å­˜äº†ä»Ž $i$ åˆ° $j$ çš„æœ€çŸ­è·¯çš„é•¿åº¦ å®žçŽ°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425#define maxn 310#define INF 0x3fint d[maxn][maxn], n, m;int x, y, x;int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(d, INF, sizeof(d)); for (int i = 1; i &lt;= n; ++i) d[i][i] = 0; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; d[x][y] = min(d[x][y], z); &#125; // åˆå§‹åŒ– &amp; è¾“å…¥ for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); // Floyd æ±‚æœ€çŸ­è·¯ for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cout &lt;&lt; d[i][j] &lt;&lt; " "; // è¾“å‡º&#125; ä¸€èˆ¬æ¥è¯´ï¼Œåœ¨æ•°æ®å°çš„æ—¶å€™å¯ä»¥ä½¿ç”¨ Floyd ç®—æ³•ï¼Œæ•°æ®å¤§çš„æ—¶å€™å°½é‡åŽ»æ€è€ƒåˆ«çš„æ–¹æ³•ã€‚ Dijkstra æ±‚å•æºæœ€çŸ­è·¯Dijkstra ç®—æ³•æµç¨‹å¦‚ä¸‹ï¼š åˆå§‹åŒ– $dist[1] = 0$ï¼Œå…¶ä½™èŠ‚ç‚¹åˆå§‹åŒ–ä¸ºä¸€ä¸ªæžå¤§å€¼ã€‚ æ‰¾å‡ºä¸€ä¸ªæœªè¢«æ ‡è®°çš„ï¼Œ$dist[x]$ æœ€å°çš„èŠ‚ç‚¹ $x$ï¼Œç„¶åŽæ ‡è®°èŠ‚ç‚¹ $x$ã€‚ æ‰«æèŠ‚ç‚¹ $x$ çš„æ‰€æœ‰å‡ºè¾¹ $(u, v, w)$ï¼Œè‹¥ $dist[v] &gt; dist[u] + w$ï¼Œåˆ™ä½¿ç”¨ $dist[u] + w$ æ›´æ–° $dist[v]$ é‡å¤ $2 \thicksim 3$ ä¸¤ä¸ªæ­¥éª¤ï¼Œç›´åˆ°èŠ‚ç‚¹å…¨éƒ¨è¢«æ ‡è®°ã€‚ Dijkstra ç®—æ³•åŸºäºŽè´ªå¿ƒï¼Œåªé€‚ç”¨äºŽè¾¹æƒéžè´Ÿçš„å›¾ã€‚ä¼˜åŒ–ï¼šä½¿ç”¨äºŒå‰å †å¯¹ $dist$ è¿›è¡Œç»´æŠ¤ï¼Œ$O(\log n)$ çš„æ—¶é—´èŽ·å–æœ€å°å€¼å¹¶åˆ é™¤ï¼Œ$O(\log n)$ çš„æ—¶é—´æ‰§è¡Œä¸€æ¡è¾¹çš„æ‰©å±•å’Œæ›´æ–°ï¼Œæœ€ç»ˆåœ¨ $O((m+n) \log n)$ çš„æ—¶é—´å†…å®Œæˆ Dijkstraã€‚ å®žçŽ°ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031// å…³äºŽå›¾çš„å®šä¹‰éƒ¨åˆ†è¿™é‡Œçœç•¥struct heapNode &#123; int u, d; bool operator&lt;(const heapNode&amp; b) const &#123; return d &gt; b.d; &#125;&#125;// æ³¨æ„ï¼Œä¸ºäº†å»ºç«‹å°æ ¹å †ï¼Œæ­¤å¤„é‡è½½çš„è¿ç®—ç¬¦æœ‰ä¸€ç‚¹ä¸åŒã€‚// å¯ä»¥é€šä¿—åœ°ç†è§£ä¸ºï¼šå¦‚æžœåˆ° b çš„è·ç¦»æ¯”åˆ° u çš„è·ç¦»å°ï¼Œé‚£ä¹ˆ b çš„ä¼˜å…ˆçº§æ¯” u é«˜ã€‚priority_queue&lt;heapNode&gt; Q; // ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—å»ºç«‹å°æ ¹å †ã€‚int dist[maxn]; // è®°å½•ä»Ž x åˆ° å„ç‚¹çš„æœ€çŸ­è·ç¦»void Dijkstra(int x) &#123; while (!Q.empty()) Q.pop(); for (int i = 1; i &lt;= n; ++i) dist[i] = INF; dist[x] = 0; // åˆ°è‡ªå·±çš„è·ç¦»ä¸º 0 Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int d = f.d; if (d != dist[u]) continue; for (int i = heads[u]; i != NOE; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[u] + w) &#123; dist[j] = dist[u] + w; Q.push()((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125; Bellman-Ford åŠ SPFA ç®—æ³•ç»™å®šä¸€å¼ æœ‰å‘å›¾ï¼Œè‹¥å¯¹äºŽå›¾ä¸­çš„æŸä¸€æ¡è¾¹ $(x,y,z)$ï¼Œæœ‰ $dist[y] \leqslant dist[x]+z$ æˆç«‹ï¼Œåˆ™ç§°è¯¥è¾¹æ»¡è¶³ä¸‰è§’å½¢ä¸ç­‰å¼ã€‚è‹¥æ‰€æœ‰çš„è¾¹éƒ½æ»¡è¶³ä¸‰è§’å½¢ä¸ç­‰å¼ï¼Œåˆ™ $dist$ æ•°ç»„å°±æ˜¯æ‰€æ±‚çš„æœ€çŸ­è·¯ã€‚ é¦–å…ˆä»‹ç»åŸºäºŽè¿­ä»£æ€æƒ³çš„ Bellman-Ford ç®—æ³•ã€‚å®ƒçš„æµç¨‹å¦‚ä¸‹ï¼š æ‰«ææ‰€æœ‰çš„è¾¹ $(x,y,z)$ï¼Œè‹¥ $dist[y] &gt; dist[x]+z$ï¼Œåˆ™ç”¨åŽè€…æ›´æ–°å®ƒã€‚ é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°æ²¡æœ‰æ“ä½œå‘ç”Ÿã€‚ Bellman-Ford çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(nm)$ã€‚ è€Œ SPFA å®žé™…ä¸Šæ˜¯é˜Ÿåˆ—ä¼˜åŒ–çš„ Bellman-Ford ç®—æ³•ï¼Œè¿™æ˜¯å›½é™…ä¸Šçš„é€šç§°ã€‚SPFA çš„ç®—æ³•æµç¨‹å¤§è‡´å¦‚ä¸‹ï¼š å»ºç«‹ä¸€ä¸ªé˜Ÿåˆ—ï¼Œæœ€åˆé˜Ÿåˆ—ä¸­åªå«æœ‰èµ·ç‚¹ $1$ã€‚ å–å‡ºé˜Ÿå¤´ç»“ç‚¹ $x$ï¼Œæ‰«æå®ƒçš„æ‰€æœ‰å‡ºè¾¹ $(x, y, x)$ï¼Œè‹¥ $dist[y] &gt; dist[x]+z$ï¼Œåˆ™ç”¨åŽè€…æ›´æ–°å‰è€…ï¼ŒåŒæ—¶è‹¥ $y$ ä¸åœ¨é˜Ÿåˆ—ä¸­ï¼Œåˆ™æŠŠ $y$ å…¥é˜Ÿã€‚ é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºã€‚ SPFA ä¸­çš„é˜Ÿåˆ—é¿å…äº† Bellman-Ford ä¸­å¯¹ä¸éœ€è¦æ‰©å±•çš„èŠ‚ç‚¹çš„å†—ä½™æ‰«æï¼Œåœ¨ç¨€ç–å›¾ä¸Šçš„è¿è¡Œæ•ˆçŽ‡è¾ƒé«˜ï¼Œä¸º $O(km)$ çº§åˆ«ï¼Œ$k$ æ˜¯ä¸€ä¸ªè¾ƒå°çš„å¸¸æ•°ï¼Œè€Œåœ¨ç¨ å¯†å›¾æˆ–ç‰¹æ®Šæž„é€ çš„ç½‘æ ¼å›¾ä¸Šï¼Œç®—æ³•ä»å¯èƒ½é€€åŒ–ä¸º $O(nm)$ï¼Œè¿™ä¹Ÿæ˜¯å¾ˆå¤šäººè¯´ SPFA ç®—æ³•çŽ„å­¦çš„åŽŸå› ã€‚ä½†æ˜¯åœ¨é‡åˆ°è´Ÿè¾¹æƒçš„æ—¶å€™ï¼Œåªèƒ½å¤Ÿä½¿ç”¨ SPFAã€‚ SPFA çš„å®žçŽ°ï¼š 12345678910111213141516171819202122232425262728int dist[maxn];bitset&lt;maxn&gt; inq; // è®°å½•æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­queue&lt;int&gt; Q;void SPFA(int x) &#123; memset(dist, INF, sizeof(dist)); dist[x] = 0; Q.push(x); inq[x] = true; int k; while (!Q.empty()) &#123; k = Q.front(); Q.pop(); inq[k] = false; if (dist[k] == INF) continue; for (int i = heads[k]; i != NOE; i = edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[k] + w) &#123; dist[j] = dist[k] + w; if (!inq[j]) &#123; Q.push(j); inq[j] = true; &#125; &#125; &#125; &#125;&#125; å¦‚æžœä¸æ˜¯å¤„ç†è´Ÿè¾¹æƒçš„å›¾çš„è¯ï¼Œ SPFA å°½é‡ä¸è¦ç”¨ï¼ŒåŽŸå› å˜›â€¦â€¦å®ƒå¤ªçŽ„äº†ã€‚]]></content>
      <categories>
        <category>å›¾è®º</category>
      </categories>
      <tags>
        <tag>å›¾è®º</tag>
        <tag>æœ€çŸ­è·¯</tag>
        <tag>Dijkstra</tag>
        <tag>å›¾çš„éåŽ†</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Floyd</tag>
        <tag>Bellman-Ford</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP æ¨¡æ‹Ÿ] 2018-8-8 é¢˜è§£: çˆ†é›¶æ—¥ï¼Œæˆ‘è¯¥ä½•åŽ»ä½•ä»Ž...]]></title>
    <url>%2F2018%2F08%2F08%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-8-%E9%A2%98%E8%A7%A3-%E7%88%86%E9%9B%B6%E6%97%A5%EF%BC%8C%E6%88%91%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢ä»Šå¤©çš„é¢˜ä¼¼ä¹Žæ˜¯ Day1 çš„é¢˜ï¼Œç„¶è€Œå´æ˜¯åŽ‹åŠ›å±±å¤§ï¼Œä»Žç¬¬ä¸€é¢˜å¼€å§‹å°±å´©ï¼Œç¬¬äºŒé¢˜è€ƒåœºä¸Šæ— è„‘ Dijkstra æ±‚æœ€çŸ­è·¯ï¼Œç¬¬ä¸‰é¢˜æ›´æ˜¯æ‡µé€¼ï¼ˆè€ƒåŽå¬è¯´ç”¨ Dancing Link åšçš„æ—¶å€™å½»åº•å´©æºƒï¼‰ï¼Œæ€»ä¹‹ï¼Œä»Šå¤©å››ååˆ†ï¼Œä¸Žçˆ†é›¶ç›¸å·®æ— å‡ ï¼Œæ‰€ä»¥è¿™æ¬¡åœ¨å†™é¢˜è§£çš„åŒæ—¶ï¼Œè¿˜æ˜¯ä¼šå†™ä¸€ç‚¹è€ƒè¯•æŠ€å·§çš„ï¼Œå°¤å…¶æ˜¯ç¬¬ä¸€é¢˜å’Œç¬¬äºŒé¢˜ï¼ˆåŽŸè°…æˆ‘çŸ¥è¯†æ°´å¹³å®žåœ¨ä¸å¤Ÿï¼Œå¯¹ç¬¬ä¸‰é¢˜ä»ç„¶æ‡µé€¼ï¼‰ã€‚ T1 åŠ¨æ€ä»™äººæŽŒ(dinosaur.cpp/c/pas)â€”â€”çŽ©äº†è¿™ä¹ˆå¤šæ¬¡å°æé¾™ï¼Œæ²¡æƒ³åˆ°å®ƒè¿˜ä¼šæŠ¥å¤æˆ‘ [é¢˜ç›®æè¿°] ç”±äºŽ Beny åšçš„çƒ§ç½‘çº¿å®žéªŒï¼ŒFife å®¶æ–­ç½‘äº†ã€‚Fife ç…§å¸¸æ‰“å¼€äº† Google Chromeï¼Œç”±äºŽæ–­ç½‘ï¼Œä»–çœ‹åˆ°äº†ä»¥ä¸‹å†…å®¹ï¼š çœ‹ åˆ° è¿™ ä¸ª ç®€ å• è€Œ åˆ æœ‰ è¶£ çš„ æ¸¸ æˆ ï¼Œ ä»– çŽ© äº† èµ· æ¥ ã€‚ ç„¶ åŽ ï¼š Fife æ°¸è¿œæ²¡æœ‰ gameoverï¼Œä»–è§‰å¾—è¿™ä¸ªæ¸¸æˆå¤ªç®€å•äº†ï¼ŒçŽ°åœ¨ä»–æƒ³è€ƒè€ƒä½ ã€‚å°æé¾™åœ¨æ•°è½´ä¸ŠåŽŸç‚¹å‡ºå‘å‘å³è¿åŠ¨ï¼Œé€Ÿåº¦ä¸º$1$ä¸ªå•ä½æ¯ç§’ã€‚çŽ°åœ¨ä½ çŸ¥é“æ¯ä¸€ä¸ªä»™äººæŽŒçš„ä½ç½®$p[i]$å’Œé«˜åº¦$h[i]$ï¼Œä¸”æ²¡æœ‰æ€ªé¸Ÿçªè¢­ï¼Œè¯·ä½ æŽ§åˆ¶å°æé¾™è·³è·ƒï¼Œä½¿å®ƒèƒ½è·³è¿‡æœ€åŽä¸€ä¸ªä»™äººæŽŒä¸”è·³è·ƒçš„æœ€å¤§é«˜åº¦æœ€å°ã€‚ä¸ºäº†é€æ¸©æš–ç®€åŒ–é—®é¢˜ï¼Œè·³è·ƒæ»¡è¶³ä»¥ä¸‹è§„åˆ™ï¼šå®ƒçš„è·³è·ƒè·¯çº¿ä¸ºä¸¥æ ¼çš„ä¸Žåœ°é¢å¤¹è§’ä¸º$45$åº¦çš„ç›´çº¿ï¼Œå®ƒåœ¨å¹³åœ°ä¸Šèƒ½éšæ—¶èµ·è·³ï¼Œå®ƒèƒ½åœ¨èµ·ç‚¹å’Œè½åœ°æ—¶åˆ»çž¬é—´èµ·è·³ã€‚ä½ èƒ½æŽ§åˆ¶å®ƒèµ·è·³çš„æ—¶åˆ»å’Œä¸‹è½çš„æ—¶åˆ»ï¼Œä¸‹è½æ—¶å®ƒä¼šæ²¿ä¸Žåœ°é¢å¤¹è§’ä¸º$45$åº¦çš„ç›´çº¿ä¸‹é™ã€‚å°æé¾™èƒ½è·³è¿‡ä¸€ä¸ªä»™äººæŽŒå½“ä¸”ä»…å½“å®ƒåœ¨è¿™ä¸ªä»™äººæŽŒçš„ä½ç½®æ—¶çš„é«˜åº¦å¤§äºŽç­‰äºŽä»™äººæŽŒçš„é«˜åº¦ã€‚ [è¾“å…¥] ç¬¬ 1 è¡Œ 1 ä¸ªæ­£æ•´æ•° n æŽ¥ä¸‹æ¥ n è¡Œæ¯è¡Œä¸¤ä¸ªæ­£æ•´æ•° p[i]å’Œ h[i],ä¸ºç¬¬ i ä¸ªä»™äººæŽŒçš„ä½ç½®å’Œé«˜åº¦ï¼Œ ä¸ä¿è¯ p[i]å•è°ƒé€’å¢žï¼Œ å¯èƒ½ä¼šæœ‰ä¸¤ä¸ªä»™äººæŽŒåœ¨åŒä¸€ä½ç½®ã€‚ [è¾“å‡º] ä½ éœ€è¦æŽ§åˆ¶å°æé¾™è·³è·ƒï¼Œä½¿å®ƒèƒ½è·³è¿‡æ‰€æœ‰ä»™äººæŽŒï¼Œä¸”è·³è·ƒçš„æœ€å¤§é«˜åº¦æœ€å°ï¼Œ è¾“å‡ºè¿™ä¸ªé«˜åº¦ï¼Œ ä¿ç•™ 1 ä½å°æ•°ï¼Œå¦‚æžœæ— è§£ï¼Œè¾“å‡º-1 [æ ·ä¾‹è¾“å…¥] 5 5 2 9 3 13 2 19 3 20 1 [æ ·ä¾‹è¾“å‡º] 6.0 [æ•°æ®è§„æ¨¡] å¯¹äºŽ 30%çš„æ•°æ®ï¼šn&lt;=200, p[i] &lt;= 1000, h[i] &lt;= 100 å¯¹äºŽ 60%çš„æ•°æ®ï¼šn&lt;= 50000, p[i] &lt;= 3000000, h[i] &lt;= 500 å¯¹äºŽ 100%çš„æ•°æ®ï¼šn &lt;= 300000, p[i] &lt; 2^31, h[i] &lt;=40000, æ•°æ®ä¿è¯æ— éœ€ä½¿ç”¨ longlong æˆ– int64 [é¢˜è§£] çœ‹åˆ°è¿™æ˜¯ç¬¬ä¸€é“é¢˜ï¼Œå¿ƒæƒ³ï¼Œè¿™ä¸€å®šå¾ˆç®€å•ï¼Œåªè¦è´ªå¿ƒå°±è¡Œäº†ï¼Œä¸€å †åˆ¤æ–­ï¼Œç„¶åŽä¿¡å¿ƒæ»¡æ»¡åœ°æäº¤â€¦â€¦æœ€åŽåªå¯¹äº†ä¸€ä¸ªç‚¹â€¦â€¦æ­¤å¤„é™„ä¸Š WA ä»£ç : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 310000#define max(a, b) (a &gt; b ? a : b)#define INF 0x3f3f3f3fint n, p[maxn], h[maxn];bitset&lt;maxn&gt; goDown;double ans = -INF;void init() &#123; goDown.set(); memset(h, 0, sizeof(h)); p[0] = 0;&#125;void judgeDown(int i) &#123; if (h[i] &gt;= h[i + 1] + p[i + 1] - p[i]) goDown[i] = 1; else if (h[i] + h[i + 1] &lt;= p[i + 1] - p[i]) goDown[i] = 1; else goDown[i] = 0;&#125;bool judgeCan(int i) &#123; if (p[i] - p[i - 1] + h[i - 1] &lt; h[i]) return false; else return true;&#125;// ä»¥ä¸Šä¸¤ä¸ª judge å‡½æ•°æ˜¯ WA ä¹‹ç²¾é«“æ‰€åœ¨ï¼ˆé›¾ï¼‰// åªè€ƒè™‘äº†ç›¸é‚»ä¸¤ä¸ªä»™äººæŽŒçš„å…³ç³»ï¼Œå¦‚æžœåœ¨ä¸‹é™çš„æ—¶å€™æ’žåˆ°å¦å¤–ä¸€ä¸ªä»™äººæŽŒ// é‚£ä¹ˆå°æé¾™å°± GG äº†double calh(int x, int y) &#123; if (h[x] &gt; h[y] + p[y] - p[x] &amp;&amp; x + 1 == y) return (double)h[x]; else return (double)(p[y] - p[x] + h[x] + h[y]) / 2.0;&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("dinosaur.in"); ofstream out("dinosaur.out"); in.tie(NULL); in &gt;&gt; n; init(); for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; p[i] &gt;&gt; h[i]; if (!judgeCan(i)) &#123; out &lt;&lt; -1; return 0; &#125; else continue; &#125; for (int i = 1; i &lt; n; ++i) judgeDown(i); int key = 1; double tmp; for (int i = 1; i &lt;= n &amp;&amp; key &lt;= n; ++i) &#123; if (goDown[i]) &#123; double tmp = calh(key, i); ans = max(ans, tmp); key = i + 1; if (p[i] + h[i] &gt; p[i + 1]) key += 1; &#125; &#125; out &lt;&lt; setprecision(1) &lt;&lt; fixed &lt;&lt; ans; return 0;&#125;// è¿™ä¸ªå®žä¾‹å‘Šè¯‰å¤§å®¶ï¼Œè´ªå¿ƒå‰å…ˆåšå¥½åˆ†æžå‡†å¤‡å·¥ä½œï¼Œå¦åˆ™å°±ä¼šåƒæˆ‘è¿™æ ·...... é‚£ä¹ˆåˆ°åº•è¯¥æ€Žä¹ˆåšå‘¢ï¼Ÿ ç”±äºŽè¿™æ˜¯ä¸€åªç†ï¼ˆbianï¼‰æƒ³ï¼ˆtaiï¼‰åŒ–è¿‡çš„å°æé¾™ï¼Œå®ƒåªä¼šä¸Žåœ°é¢å‘ˆ$45$åº¦è·³è·ƒï¼Œè€Œä¸”å¯ä»¥æ— é™å‡å¤©ï¼Œæ³•åŠ›æ— è¾¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä»Žæ¯ä¸€ä¸ªä»™äººæŽŒçš„è·³è·ƒè¾¹ç•Œæ¥è€ƒè™‘ï¼š è€ƒè™‘ä¸¤ç§ä¸åŒçš„ä»™äººæŽŒæƒ…å†µï¼š é‚£ä¹ˆå°±æœ‰ä¸¤ç§åšæ³•äº†ï¼Œç¬¬ä¸€ç§ï¼Œåˆ åŽ»æ‰€æœ‰åƒç»¿è‰²ä»™äººæŽŒé‚£æ ·çš„ä»™äººæŽŒï¼Œç„¶åŽç›´æŽ¥è®¡ç®—ï¼›ç¬¬äºŒç§ï¼Œä¹Ÿæ˜¯æ ‡ç¨‹çš„æ–¹æ³•ï¼Œé€ä¸ªè¿›è¡Œåˆ¤æ–­ï¼Œç»´æŠ¤ first å’Œ last è¿™ä¸¤ä¸ªå€¼ï¼Œåˆ†åˆ«è¡¨ç¤ºä¸€ç»„è·³è·ƒï¼ˆä¸€æ¬¡ä¸Šå’Œä¸€æ¬¡ä¸‹ï¼‰çš„å·¦å³è¾¹ç•Œï¼Œç„¶åŽè®¡ç®—ã€‚ [å‚è€ƒä»£ç ] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// æ³¨ï¼šæœ¬ä»£ç ä½¿ç”¨çš„æ˜¯ç¬¬äºŒç§æ–¹æ³•// ä½¿ç”¨ç¬¬ä¸€ç§æ–¹æ³•çš„åŒå­¦å¯ä»¥ä½¿ç”¨ç±»é“¾è¡¨çš„æ–¹å¼æ¥å­˜å‚¨æ•°æ®ï¼ŒåŠ å¿«æ•ˆçŽ‡#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 310000struct segment &#123; int l; int r; &#125;;int n, p, h;double ans = 0;segment a[maxn];bool compare(segment a, segment b) &#123; return a.l &lt; b.l || (a.l == b.l &amp;&amp; a.r &lt; b.r);&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("dinosaur.in"); ofstream out("dinosaur.out"); in.tie(NULL); in &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; p &gt;&gt; h; a[i].l = p - h; a[i].r = p + h; &#125; sort(a + 1, a + n + 1, compare); if (a[1].l &lt; 0) &#123; cout &lt;&lt; -1; return 0; &#125; int last = a[1].r; int first = a[1].l; for (int i = 2; i &lt;= n; ++i) &#123; if (a[i].l &lt; last) last = max(last, a[i].r); else &#123; ans = max(ans, (last - first) * 1.0 / 2.0); first = a[i].l; last = a[i].r; &#125; &#125; ans = max(ans, (last - first) * 1.0 / 2.0); out &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; ans; return 0;&#125; [è¯„ä»·] å…¶å®žæ€ç»´éš¾åº¦å¹¶ä¸å¤§ï¼Œä¸»è¦æ˜¯è€ƒéªŒå¯¹ç®—æ³•æ˜¯å¦æŽŒæ¡åˆ°ä½ï¼Œè­¬å¦‚ç”¨è´ªå¿ƒï¼Œè¿™é“é¢˜å¹¶ä¸èƒ½ä»Žå¤´è´ªåˆ°å°¾ï¼Œé‚£æ ·ä¼šå‡ºé—®é¢˜ï¼Œå¿…é¡»è€ƒè™‘æ‰€æœ‰å¯èƒ½æƒ…å†µï¼Œè¿™ä¹Ÿæ˜¯æœ¬é¢˜æ ·ä¾‹çš„å‘äººä¹‹å¤„æ‰€åœ¨ï¼Œä»¥åŽè€ƒè¯•æ—¶ï¼Œå¦‚æžœåªæœ‰ä¸€ä¸ªæ ·ä¾‹ï¼Œé‚£å¿…é¡»å¾—å°å¿ƒå‡ºé¢˜è€å¸ˆå‡ºé˜´æ‹›ï¼Œæœ€å¥½æ˜¯è‡ªå·±è„‘æ»šé”®ç›˜æ¥å‡ºå‡ ä¸ªæ•°æ®æ‰‹ç®—æµ‹è¯•ä¸€ä¸‹ã€‚ T2 ç›¸äº¤(inter.cpp/c/pas)â€”â€”æ—§æ—¶ Dijkstra å ‚å‰ O(mlog n)ï¼Œé£žå…¥å¯»å¸¸ NOIER å®¶ã€‚ [é¢˜ç›®æè¿°] ä¸€æ£µå¤§æ ‘ä¸‹æœ‰$n$ä¸ªå·¢ç©´ï¼Œç”±$n-1$æ¡åŒå‘é“è·¯è¿žæŽ¥ï¼Œä»»æ„ä¸¤ä¸ªåŸŽå¸‚å‡å¯äº’ç›¸åˆ°è¾¾ã€‚å¤§æ ‘é™„è¿‘æœ‰ä¸¤ç¾¤èš‚èšï¼Œæ¯å¤©æ—©ä¸Šï¼Œç¬¬ä¸€ç¾¤èš‚èšä¼šæ´¾ä¸€åªèš‚èšåˆ°è¿™æ£µæ ‘ä¸‹ï¼Œå¹¶åœ¨ç¬¬$a$ä¸ªå·¢ç©´åˆ°ç¬¬$b$ ä¸ªå·¢ç©´é—´çš„æœ€çŸ­è·¯å¾„ä¸Šçš„æ¯ä¸ªå·¢ç©´ç•™ä¸‹æ°”å‘³ã€‚æ¯å¤©å‚æ™šï¼Œç¬¬äºŒç¾¤èš‚èšä¼šæ´¾ä¸€åªèš‚èšåˆ°è¿™æ£µæ ‘ä¸‹ï¼Œå¹¶ä¾¦æŸ¥ç¬¬$c$ä¸ªå·¢ç©´åˆ°ç¬¬$d$ä¸ªå·¢ç©´é—´çš„æœ€çŸ­è·¯å¾„ä¸Šæ˜¯å¦æœ‰èš‚èšç•™ä¸‹çš„æ°”å‘³ã€‚æ¯å¤©èš‚èšç•™ä¸‹çš„æ°”å‘³ä¼šåœ¨å½“å¤©æ·±å¤œæ¶ˆå¤±ã€‚ [è¾“å…¥] ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•° nï¼Œå«ä¹‰å¦‚é¢˜æ‰€ç¤ºã€‚ æŽ¥ä¸‹æ¥ n-1 è¡Œï¼Œæ¯è¡Œä¸¤ä¸ªæ­£æ•´æ•° u,vï¼Œè¡¨ç¤ºç¬¬ u ä¸ªå·¢ç©´å’Œç¬¬ v ä¸ªå·¢ç©´é—´æœ‰ä¸€æ¡åŒå‘é“è·¯ã€‚ æŽ¥ä¸‹æ¥ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•° qï¼Œè¡¨ç¤ºå¤©æ•°ã€‚ æŽ¥ä¸‹æ¥ q è¡Œï¼Œæ¯è¡Œå››ä¸ªæ­£æ•´æ•° a,b,c,dï¼Œå«ä¹‰å¦‚é¢˜æ‰€ç¤ºã€‚ [è¾“å‡º] q è¡Œï¼Œæ¯è¡Œä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ è‹¥ç¬¬äºŒç¾¤æ´¾å‡ºçš„èš‚èšä¾¦æŸ¥åˆ°èš‚èšç•™ä¸‹çš„æ°”å‘³ï¼Œåˆ™è¾“å‡ºâ€YESâ€,å¦åˆ™è¾“å‡ºâ€NOâ€ [æ ·ä¾‹è¾“å…¥] æ ·ä¾‹è¾“å…¥ 1 8 1 2 1 3 2 4 2 5 5 6 5 7 3 8 4 2 5 4 3 5 3 8 8 5 4 6 7 4 8 6 7 æ ·ä¾‹è¾“å…¥ 2 15 2 1 3 1 4 2 5 3 6 2 7 2 8 5 9 3 10 6 11 5 12 7 13 11 14 1 15 1 5 1 2 3 4 4 7 1 9 2 3 7 9 2 6 7 8 2 1 6 8 [æ ·ä¾‹è¾“å‡º] æ ·ä¾‹è¾“å‡º 1 YES NO YES NO æ ·ä¾‹è¾“å‡º 2 YES NO YES YES YES [æ•°æ®è§„æ¨¡] å¯¹äºŽ 30%çš„æ•°æ® 1&lt;=n,q&lt;=3000 å¯¹äºŽå¦å¤– 20%çš„æ•°æ® ç¬¬ i æ¡è¾¹è¿žæŽ¥ç¬¬ i ä¸ªå·¢ç©´å’Œç¬¬ i+ä¸ªå·¢ç©´ å¯¹äºŽ 100%çš„æ•°æ® 1&lt;=n,q&lt;=100000 [é¢˜è§£] é¦–å…ˆè®²ä¸€ä¸‹æˆ‘è€ƒè¯•çš„æ—¶å€™æ˜¯æ€Žä¹ˆæƒ³çš„ï¼Œæˆ‘æƒ³æ—¢ç„¶æ˜¯æœ€çŸ­è·¯å¾„ï¼Œè¿˜æ˜¯ä¸ªå›¾ï¼ˆå½“æ—¶æ²¡çœ‹å‡ºæ˜¯æ ‘ï¼‰ï¼Œé‚£ä¹ˆ Dijkstra æ— ç–‘äº†ï¼Œæ½‡æ½‡æ´’æ´’ä¸€ç™¾è¡Œæ‰“å®Œï¼Œç”¨äº†ä¸¤ä¸ª bitset å†ç”¨äº†ä¸€ä¸ªç¥žå¥‡çš„æ–¹æ³•è®°å½•è·¯å¾„ã€‚å¥½ï¼å°±æ˜¯è¿™æ ·ï¼Œä¸€å®š AC äº†ï¼ç»“æžœï¼šTLEâ€¦â€¦é™„ä¸Š Dijkstra æš´åŠ›ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define maxq 110000#define NOE -1#define INF 0x3f3f3f3fstruct edgeNode &#123; int vertexFrom; int vertexTo; int edgeNext; bool weight;&#125;;struct heapNode &#123; int u, d; bool operator&lt;(const heapNode&amp; b) const &#123; return d &gt; b.d; &#125;&#125;;edgeNode edges[maxn];int heads[maxn];int numEdges = 0;int n, q, u, v, a, b, c, d;bool judge = true;bitset&lt;maxn&gt; smell1;bitset&lt;maxn&gt; smell2;int path[maxn];int dist[maxn];priority_queue&lt;heapNode&gt; Q;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexFrom = vertex1; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = true; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1);&#125;void Dijkstra(int x) &#123; while (!Q.empty()) Q.pop(); for (int i = 1; i &lt;= n; ++i) dist[i] = INF; for (int i = 1; i &lt;= n; ++i) path[i] = i; dist[x] = 0; Q.push((heapNode)&#123; x, 0 &#125;); while (!Q.empty()) &#123; heapNode f = Q.top(); Q.pop(); int u = f.u; int dis = f.d; if (dis != dist[u]) continue; for (int i = heads[u]; i != NOE; i= edges[i].edgeNext) &#123; int j = edges[i].vertexTo; int w = edges[i].weight; if (dist[j] &gt; dist[u] + w) &#123; dist[j] = dist[u] + w; path[j] = u; // è®°å½•è·¯å¾„ Q.push((heapNode)&#123; j, dist[j] &#125;); &#125; &#125; &#125;&#125;void updateSmell1(int a, int b) &#123; int tmp = b; while (tmp != a) &#123; smell1[tmp] = 1; tmp = path[tmp]; &#125;&#125;void updateSmell2(int c, int d) &#123; int tmp = d; while (tmp != c) &#123; smell2[tmp] = 1; tmp = path[tmp]; &#125;&#125;int main() &#123; freopen("inter.in", "r", stdin); freopen("inter.out", "w", stdout); // fstream ä¸çŸ¥æ€Žä¹ˆå°±ä¸èƒ½å–æ¶ˆ sync_with_stdioï¼Œä¸ºäº†åŠ å¿«é€Ÿåº¦åªèƒ½ä½¿ç”¨ freopen init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n - 1; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addDuplexEdge(u, v); &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; smell1.reset(); smell2.reset(); scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); if ((a == c &amp;&amp; b == d) || (a == d &amp;&amp; b == c)) &#123; printf("YES\n"); continue; &#125; smell1[a] = 1; smell2[c] = 1; // TLE TLE TLE TLE TLE TLE TLE TLE TLE TLE TTTTTTLLLLLLEEEE Dijkstra(a); updateSmell1(a, b); Dijkstra(c); updateSmell2(c, d); // TLE TLE TLE TLE TLE TLE TLE TLE TLE TLE TTTTTTLLLLLLEEEE judge = (smell1 &amp; smell2).any(); if (judge) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; å…¶å®žå¦‚æžœçœ‹å‡ºäº†è¿™æ˜¯æ£µæ ‘çš„è¯ï¼Œæ˜¯å¯ä»¥ç”¨å¹¿æœçš„â€¦â€¦å¯ä»¥å¿«ä¸å°‘ã€‚ å¥½äº†ï¼Œè¯´æ­£è§£ï¼šå°±åƒä¸Šé¢æ‰€è¯´çš„ï¼Œè¿™æ˜¯ä¸€æ£µæ ‘ï¼ˆå•¥ï¼Ÿä½ é—®æˆ‘æ€Žä¹ˆçœ‹å‡ºçš„ï¼Ÿä»”ç»†è¯»é¢˜ï¼ï¼ï¼‰ï¼Œæ‰€ä»¥èŽ·å–æœ€çŸ­è·ç¦»ä¸€å®šæ˜¯æ±‚ä¸¤ä¸ªç‚¹çš„ $LCA$ äº†ã€‚é‚£å¦‚ä½•æ ‡è®°å‘¢ï¼Ÿï¼Ÿè¿™æ˜¯ä¸ªå¥½é—®é¢˜ï¼Œä¸€èˆ¬æˆ‘ä»¬éƒ½ä¼šåŽ»æƒ³æ ‡è®°ç»è¿‡çš„ç‚¹ï¼Œç„¶è€Œï¼Œå¦‚æžœç”¨å€å¢ž $LCA$ æ±‚ï¼Œä¸€å®šä¼šè·³è¿‡ç»è¿‡çš„ç‚¹ï¼Œå¦‚æžœç”¨æœ´ç´ ç®—æ³•æ±‚çš„è¯â€¦â€¦é‚£è¿˜ä¸å¦‚ $BFS$ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¿…é¡»ä½¿ç”¨å¦å¤–çš„æ–¹æ³•äº†ã€‚ é¦–å…ˆæˆ‘ä»¬ç”»ä¸€æ£µæ ‘ï¼š é€šè¿‡è§‚å¯Ÿå’Œä¸¾ä¾‹ï¼Œæˆ‘ä»¬å‘çŽ°ï¼Œåªæœ‰å½“ $a$ å’Œ $LCA(c, d)$ åœ¨åŒä¸€æ¡é“¾ä¸Šï¼Œä¸” $LCA(a, b)$ ä¹Ÿåœ¨è¿™æ¡é“¾ä¸Šï¼› $b$ å’Œ $LCA(c, d)$ åœ¨åŒä¸€æ¡é“¾ä¸Šï¼Œä¸” $LCA(a, b)$ ä¹Ÿåœ¨è¿™æ¡é“¾ä¸Šï¼› $c$ å’Œ $LCA(a, b)$ åœ¨åŒä¸€æ¡é“¾ä¸Šï¼Œä¸” $LCA(c, d)$ ä¹Ÿåœ¨è¿™æ¡é“¾ä¸Šï¼› $d$ å’Œ $LCA(a, b)$ åœ¨åŒä¸€æ¡é“¾ä¸Šï¼Œä¸” $LCA(c, d)$ ä¹Ÿåœ¨è¿™æ¡é“¾ä¸Šï¼› ä»¥ä¸Šå››è€…æ»¡è¶³å…¶ä¸€æ—¶æ‰èƒ½å¤Ÿæ˜¯ YESï¼Œå¦åˆ™å°±æ˜¯ NOã€‚ ä¸ºä»€ä¹ˆæ˜¯è¿™æ ·ï¼Ÿå¦‚ä½•å®žçŽ°å‘¢ï¼Ÿé¦–å…ˆæ€è€ƒï¼šåˆ°è¾¾$a$ï¼Œ$b$ä¸¤ç‚¹å¿…å®šç»è¿‡å®ƒä»¬çš„ $LCA$ï¼Œé‚£ä¹ˆï¼Œåªè¦å®ƒä»¬ä¸¤ç‚¹ä¸Žå¦å¤–ä¸¤ç‚¹çš„ $LCA $åœ¨ä¸€æ¡é“¾ä¸Šï¼ˆè¿™ä¸ªä¸æ˜¯å¾ˆä¸¥è°¨ï¼Œè¿™é‡Œçš„é“¾æŒ‡çš„æ˜¯å°†æ ‘çœ‹æˆ $DAG$ æ—¶ï¼Œå³è‹¥ $LCA(u, v) = v$ æ—¶ï¼Œ$u$ï¼Œ$v$åœ¨ä¸€æ¡é“¾ä¸Šï¼‰ï¼Œä¸”å®ƒä»¬ä¸¤ä¸ªç‚¹çš„ $LCA$ æ·±åº¦æ¯”å¦å¤–ä¸¤ç‚¹çš„æ·±åº¦å°æ—¶ï¼Œä¸¤æ¡è·¯å¾„å¿…æœ‰é‡å çš„éƒ¨åˆ†ï¼ˆå¦‚å›¾ï¼Œ$d$ä¸Ž $LCA(a, b)$ åœ¨ä¸€æ¡é“¾ä¸Šï¼Œä¸” $LCA(a, b)$ çš„æ·±åº¦æ¯” $LCA(c, d)$ çš„æ·±åº¦å¤§ï¼Œæ‰€ä»¥ä¸¤è€…è·¯å¾„å¿…æœ‰äº¤é›†ï¼‰ å¦‚æ­¤åˆ†æžï¼Œä»£ç ä¹Ÿå°±å‘¼ä¹‹æ¬²å‡ºäº†ã€‚ [å‚è€ƒä»£ç ] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define NOE -1struct edgeNode &#123; int vertexTo; int edgeNext;&#125;;edgeNode edges[maxn &lt;&lt; 1];// æ³¨æ„ç”±äºŽæ˜¯æ— å‘è¾¹ï¼Œè€Œå‰å‘æ˜Ÿåªèƒ½æŒ‰ç…§åŒå‘è¾¹å¤„ç†ï¼Œæ‰€ä»¥è¦ä¹˜äºŒint heads[maxn];int numEdges = 0;int f[maxn][20], dep[maxn];int n, q, u, v, a, b, c, d;void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;void addEdge(int vertex1, int vertex2) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;void addDuplexEdge(int vertex1, int vertex2) &#123; addEdge(vertex1, vertex2); addEdge(vertex2, vertex1);&#125;void rDFS(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; for (int i = 1; i &lt;= 18; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) if (edges[i]. vertexTo != fa) rDFS(edges[i].vertexTo, x);&#125;int LCA(int u, int v) &#123; for (int i = 18; i &gt;= 0; --i) if (dep[f[u][i]] &gt;= dep[v]) u = f[u][i]; for (int i = 18; i &gt;= 0; --i) if (dep[f[v][i]] &gt;= dep[u]) v = f[v][i]; if (u == v) return u; for (int i = 18; i &gt;= 0; --i) if (f[u][i] != f[v][i]) &#123; u = f[u][i]; v = f[v][i]; &#125; return f[u][0];&#125;// æ‰¾ LCAbool inOneChain(int u, int v, int w) &#123; return (LCA(u, w) == w) &amp;&amp; (dep[w] &gt;= dep[v]); // åˆ¤æ–­é“¾å’Œæ·±åº¦å…³ç³»&#125;bool judge(int a0, int b0, int c0, int d0) &#123; int lca1 = LCA(a0, b0); int lca2 = LCA(c0, d0); return (inOneChain(a0, lca1, lca2) || inOneChain(b0, lca1, lca2) || inOneChain(c0, lca2, lca1) || inOneChain(d0, lca2, lca1)); // å››è€…åªè¦æ»¡è¶³å…¶ä¸€å°±ä¼šæœ‰äº¤é›†ï¼Œæ‰€ä»¥å–æˆ–å°±è¡Œ&#125;int main() &#123; freopen("inter.in", "r", stdin); freopen("inter.out", "w", stdout); // æˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼Œfstream ä¸€å…³æŽ‰åŒæ­¥å°±ä¼šå´©ï¼Œæ— å¥ˆåªèƒ½ç”¨ freopen scanf("%d", &amp;n); init(); // å¾ªçŽ¯æ—¶ i åªèƒ½åˆ° n - 1ï¼Œè¿˜æ˜¯æé†’ä»”ç»†è¯»é¢˜ for (int i = 1; i &lt; n; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); addDuplexEdge(u, v); &#125; memset(f, 0, sizeof(f)); // åˆ«å¿˜è®°åˆå§‹åŒ– rDFS(1, 0); scanf("%d", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); if (judge(a, b, c, d)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; [è¯„ä»·] æ€ç»´éš¾åº¦è¾ƒå¤§ï¼Œæƒ³åˆ°æ±‚äº¤é›†çš„æ–¹æ³•åŽä»ç„¶è¦ç”»å¾ˆå¤šå›¾æ¥æ€»ç»“è§„å¾‹ï¼Œå¦åˆ™è§„å¾‹å¾ˆæœ‰å¯èƒ½æ˜¯é”™è¯¯çš„æˆ–è€…æ˜¯ç‰‡é¢çš„ã€‚å†æ¬¡æé†’ä»”ç»†è¯»é¢˜ï¼Œå› ä¸ºé¢˜ç›®ä¸­åŒ…å«äº†å¾ˆå¤šéšè—æ¡ä»¶ï¼Œè¿™äº›éšè—æ¡ä»¶ä¹Ÿå°¤ä¸ºé‡è¦ï¼Œä¸ç®¡æ˜¯å¯¹æ­£è§£è¿˜æ˜¯å¯¹æš´åŠ›æœ´ç´ ç®—æ³•æ¥è¯´ï¼Œéƒ½å¯ä»¥æé«˜æ•ˆçŽ‡ã€‚è¿™æ˜¯ä¸€é“éš¾é¢˜ï¼Œè¿˜æ˜¯ä¸€é“å‘é¢˜ã€‚ T3 èªæ˜Žæ ¼(kenken.cpp/c/pas)[é¢˜ç›®æè¿°]èªæ˜Žæ ¼æ˜¯ä¸€ç§æ•°å­—æ¸¸æˆï¼Œåˆå ªç§°å‡çº§ç‰ˆçš„æ•°ç‹¬ï¼Œè¯žç”Ÿæ—¥æœ¬ã€‚å®ƒåœ¨æ•°å­¦ä¸Šçš„è¦æ±‚æ¯”æ•°ç‹¬è¦é«˜å¾—å¤šï¼Œå®ƒæŠŠæ•°ç‹¬è§„åˆ™ä¸ŽåŠ å‡ä¹˜é™¤å››åˆ™è¿ç®—ç›¸ç»“åˆï¼Œä½¿å¤§è„‘åœ¨å„ç§è°œé¢˜ä¸­æ¥å›žç©¿æ¢­ã€‚ å®ƒçš„è§„åˆ™æ˜¯è¿™æ ·çš„ï¼šæœ‰ä¸€ä¸ª $n\times n$ çš„æ£‹ç›˜ï¼Œæ¯ä¸ªæ ¼å­é‡Œå¡«ä¸€ä¸ªåœ¨ 1~n èŒƒå›´å†…çš„æ•°ï¼Œä½¿å¾—æ¯è¡Œæ¯åˆ—æ²¡æœ‰é‡å¤çš„æ•°å­—ï¼Œ(å³ 1~n æ¯ä¸ªæ•°åœ¨æ¯è¡Œå’Œæ¯åˆ—å„å‡ºçŽ°ä¸€æ¬¡)ï¼Œä¸”æ»¡è¶³ä¸‹åˆ—æ¡ä»¶: çŽ°åœ¨ç»™ä½ ä¸€ä¸ª $n\times n$ çš„æ£‹ç›˜ï¼Œè®©ä½ å®Œæˆå®ƒï¼Œå¹¶è¾“å‡ºè§£çš„ä¸ªæ•°å’Œå­—å…¸åºæœ€å°çš„æ–¹æ¡ˆã€‚æ•°æ®ä¿è¯ä¸€å®šæœ‰è§£ã€‚ [è¾“å…¥] ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•° nï¼Œè¡¨ç¤ºæ£‹ç›˜çš„è¡Œæ•°å’Œåˆ—æ•°ã€‚ æŽ¥ä¸‹æ¥ n è¡Œï¼Œæ¯è¡Œ n ä¸ªæ­£æ•´æ•°ã€‚è¡¨ç¤ºï¼šç›¸åŒæ•°å­—æž„æˆäº†è®¸å¤šä¸ªè¿žé€šå—ï¼Œ å‡è®¾è¿™ä¸ªå››è¿žé€šå—å†…æ¯ä¸ªæ•°å­—éƒ½ä¸º a,é‚£ä¹ˆä½ åœ¨è¿™äº›æ ¼å­ä¸Šå¡«çš„æ•°çš„ä¹˜ç§¯ åº”è¯¥ç­‰äºŽ aã€‚ï¼ˆå…·ä½“æè¿°è§æ ·ä¾‹ï¼‰ [è¾“å‡º] è¾“å‡ºå…± n+1 è¡Œï¼Œç¬¬ä¸€è¡Œè¾“å‡ºè§£çš„ä¸ªæ•° æŽ¥ä¸‹æ¥ n è¡Œï¼Œæ¯è¡Œ n ä¸ªæ­£æ•´æ•°ã€‚è¡¨ç¤º n*n çš„çŸ©é˜µé‡Œæ¯ä¸ªæ•°å­—çš„å€¼ ï¼ˆå­—å…¸åºæœ€å°çš„æ–¹æ¡ˆï¼‰ã€‚ [è¾“å…¥æ ·ä¾‹ 1] 4 6 6 1 144 6 2 144 144 4 2 144 4 12 12 4 4 æ³¨ï¼šæ­¤æ ·ä¾‹æ‰€å¯¹åº” 4*4 çš„æ£‹ç›˜å³ä¸ºä¸Šå›¾ã€‚ [è¾“å‡ºæ ·ä¾‹ 1] 1 2 3 1 4 1 2 4 3 4 1 3 2 3 4 2 1 [è¾“å…¥æ ·ä¾‹ 2] 3 12 12 18 12 12 18 18 18 18 [è¾“å‡ºæ ·ä¾‹ 2] 4 1 2 3 2 3 1 3 1 2 [è¾“å…¥æ ·ä¾‹ 3] 9 32353542 4254 54 544 322735576 10108108 1084 927576576 1040 40 1008 1008 9270576576 814 14 1008 1008 142702705768105 3283 14426882727 105 32810 302688268880 6105 63 6310 30 2688 12680 8024 3 639 66126126 126 24 24 40 40 [è¾“å‡ºæ ·ä¾‹ 3] 1 8 1 5 6 7 9 2 3 4 4 3 7 8 5 6 9 2 1 1 9 4 3 2 8 5 6 7 9 5 3 1 8 2 7 4 6 7 6 9 2 1 5 4 8 3 2 4 6 9 3 7 8 1 5 5 7 8 4 6 3 1 9 2 6 8 2 5 4 1 3 7 9 3 2 1 7 9 4 6 5 8 [æ•°æ®è§„æ¨¡] æµ‹è¯•ç‚¹ n= è¾“å…¥çŸ©é˜µä¸­ä¸åŒç§ç±»æ•°å­—ä¸ªæ•° 1-2 3 &gt;=3 3-4 5 &gt;=10 5-7 9 &gt;=30 8-10 9 &gt;=20 100% çš„æ•°æ®æ»¡è¶³ï¼ŒçŸ©é˜µä¸­æ¯ä¸ªæ•°å­—&lt;=100,000ï¼Œåˆæ³•æ£‹ç›˜ä¸ªæ•°ï¼ˆè§£çš„ä¸ªæ•°ï¼‰&lt;=300 [é¢˜è§£] è¿™é‡Œå…ˆä¸å¤šè¯´äº†ï¼Œå…³äºŽèˆžè¹ˆé“¾æˆ‘åœ¨åŽé¢çš„åšå®¢ä¸­ä¼šè¯¦ç»†è®²è§£ï¼Œæ­¤å¤„ç›´æŽ¥è´´æ ‡ç¨‹ã€‚ [å‚è€ƒä»£ç ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std; const int N=11,M=510;const int dx[4]=&#123;1,0,-1,0&#125;;const int dy[4]=&#123;0,1,0,-1&#125;;struct node2&#123; int c[N][N]; &#125; ans[M];bool operator&lt; (node2 x,node2 y)&#123; for(int i = 1; i &lt; N; i++) for(int j = 1; j&lt;N; j++) if(x.c[i][j] != y.c[i][j]) return x.c[i][j] &lt; y.c[i][j]; return 0;&#125;struct node&#123; int x, y; &#125;;vector&lt;node&gt; b[N * N];vector&lt;int&gt; p[N * N]; int a[N][N], c[N][N], h[N][N], h1[N][N], h2[N][N];int n, cnt = 0, tot = 0;int read() &#123; int x = 0, f = 1; char c = 0; for (; !isdigit(c); c=getchar()) if(c == '-') f = -1; for (; isdigit(c); c=getchar()) x = x * 10 + c - 48; return x * f;&#125;int factor(int x) &#123; int t = 0; for (int i = 1; i * i &lt;= x; i++) t += (int)(x % i == 0); return t;&#125;bool cmp(vector&lt;node&gt; x, vector&lt;node&gt; y) &#123; if (x.size() == y.size()) return factor(x[0].x) &lt;= factor(y[0].x); return x.size() &lt; y.size();&#125;void divide(int t, int x)&#123; for (int i = 1; i &lt;= n; i++) if (x % i == 0) p[t].push_back(i);&#125;void dfs(int x, int y) &#123; h[x][y] = 1; b[cnt].push_back((node)&#123; x, y &#125;); for (int i = 0; i &lt; 4; i++) &#123; int tx = x + dx[i]; int ty = y + dy[i]; if (tx &gt; 0 &amp;&amp; tx &lt;= n &amp;&amp; ty &gt; 0 &amp;&amp; ty &lt;= n &amp;&amp; !h[tx][ty] &amp;&amp; a[tx][ty] == a[x][y]) dfs(tx, ty); &#125;&#125;void work(int dep);void fillp(int t, int dep, int s, int tot) &#123; if (dep &gt; tot) work(t + 1); else &#123; int x=b[t][dep].x, y = b[t][dep].y; for (int i = 0; i &lt; p[t].size(); i++) &#123; int u=p[t][i]; if ((s == u || dep &lt; tot) &amp;&amp; s % u == 0 &amp;&amp; !h1[x][u] &amp;&amp; !h2[y][u])&#123; h1[x][u] = 1ï¼› h2[y][u] = 1; c[x][y] = u; fillp(t, dep + 1, s / u, tot); c[x][y] = 0; h1[x][u] = 0ï¼› h2[y][u]=0; &#125; &#125; &#125;&#125;void work(int dep) &#123; if (dep &gt; cnt) &#123; tot++; for (int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) ans[tot].c[i][j] = c[i][j]; &#125; else &#123; int num=b[dep][0].xï¼› int tot=b[dep].size() - 1; fillp(dep, 1, num, tot); &#125;&#125;int main() &#123; freopen("kenken.in", "r", stdin); freopen("kenken.out", "w", stdout); n = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) a[i][j] = read(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (!h[i][j]) &#123; cnt++; b[cnt].push_back((node)&#123; a[i][j], 0 &#125;); dfs(i, j); &#125; sort(b + 1, b + cnt + 1, cmp); for (int i = 1; i &lt;= cnt; i++) divide(i, b[i][0].x); work(1); cout &lt;&lt; tot &lt;&lt; "\n"; node2 t = ans[1]; for (int i = 2; i &lt;= tot; i++) t = min(t, ans[i]); for (int i = 1;i &lt;= n; i++)&#123; for (int j = 1; j &lt; n; j++) cout &lt;&lt; t.c[i][j] &lt;&lt; " "; cout &lt;&lt; t.c[i][n] &lt;&lt; "\n"; &#125; return 0;&#125; æœ¬æ¬¡è€ƒè¯•æ€»ç»“Too young, too simple, sometimes naiveâ€¦â€¦è¿˜æ˜¯è¦æé«˜çŸ¥è¯†æ°´å¹³å’Œç¼–ç¨‹ç´ å…»ï¼Œé˜²æ­¢è€ƒè¯•æ—¶ GGã€‚]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP æ¨¡æ‹Ÿ</tag>
        <tag>é¢˜è§£</tag>
        <tag>ç¥žé¢˜</tag>
        <tag>çˆ†é›¶æ—¥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[æ•°è®º] æ•°è®ºåŸºç¡€çŸ¥è¯†----èŽ«æ¯”ä¹Œæ–¯å‡½æ•°]]></title>
    <url>%2F2018%2F08%2F08%2F%E6%95%B0%E8%AE%BA-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢æœ€è¿‘è‡ªå·±åœ¨è‡ªå­¦æ•°è®ºï¼Œä¸ºäº†ä¿è¯é‡åˆ°æ•°è®ºçš„é¢˜çš„æ—¶å€™èƒ½ä»Žå®¹ä¸è¿«åœ°åº”å¯¹ï¼Œæœ¬ç¯‡æ–‡ç« ä¸»è¦æ˜¯å¯¹èŽ«æ¯”ä¹Œæ–¯å‡½æ•°( $\mu{(n)}$ )çš„åˆæ­¥äº†è§£ èŽ«æ¯”ä¹Œæ–¯å‡½æ•°å®šä¹‰èŽ«æ¯”ä¹Œæ–¯å‡½æ•° $\mu{(n)}$ çš„å®šä¹‰å¦‚ä¸‹ï¼š $$ \mu(1) = 1; $$ å¦‚æžœ $n&gt;1$ï¼Œå†™ $n=p_1^{a_1}p_2^{a_2}p_3^{a_3}â€¦p_k^{a_k}$ï¼Œåˆ™ï¼š $$\mu(n)=\begin{cases}(-1)^k &amp; \text{when $a_1=a_2=a_3=â€¦=a_k=1$,}\\0 &amp; \text{otherwise.}\end{cases}$$ æ³¨ $\mu(n)=1$å½“ä¸”ä»…å½“$n$æœ‰ä¸€ä¸ªå¤§äºŽ$1$çš„å¹³æ–¹å› å­ã€‚ å®šç†èŽ«æ¯”ä¹Œæ–¯å‡½æ•°åœ¨æ•°è®ºä¸­ç»å¸¸å‡ºçŽ°ï¼ˆä¸Šæ¬¡å°±è¢«å®ƒç‹ ç‹ åœ°å‘äº†ä¸€æ¬¡ï¼‰ï¼Œå®ƒçš„åŸºæœ¬æ€§è´¨ä¹‹ä¸€æ˜¯å¯¹çº¦æŸæ±‚å’Œ $\sum_{d|n}\mu{(d)}$ çš„ä¸€ä¸ªé‡è¦çš„ç®€æ˜Žå…¬å¼ï¼Œå®ƒåœ¨$n$çš„æ­£çº¦æ•°ä¸Šå±•å¼€ï¼Œå¼å­ä¸­çš„ $\left[x\right]$ è¡¨ç¤ºä¸å¤§äºŽ$x$çš„æœ€å¤§æ•´æ•°ã€‚å®šç†å¦‚ä¸‹ï¼š [å®šç†æè¿°]å¦‚æžœ${n}\geqslant{1}$ï¼Œæˆ‘ä»¬æœ‰$$\sum_{d|n}\mu{(d)}=\left[\frac{1}{n}\right]=\begin{cases}1 &amp;\text{when $n=1$,}\\0 &amp;\text{when $n&gt;1$.}\end{cases}$$ [å®šç†è¯æ˜Ž]ï¼ˆè¿ç”¨äº†äºŒé¡¹å¼å®šç†ï¼‰å¯¹äºŽ $n=1$ï¼Œç­‰å¼æ˜¾ç„¶æˆç«‹ã€‚è®¾ $n&gt;1$ å¹¶å†™ $n=p_1^{a_1}â€¦p_k^{a_k}$ ï¼Œåœ¨ $\sum_{d|n}\mu{(d)}$ ä¸­éžé›¶çš„é¡¹ä»…æ¥è‡ªäºŽ $d=1$ ä¸Ž $n$ çš„çº¦æ•°æ˜¯ä¸åŒç´ æ•°çš„ä¹˜ç§¯ï¼Œå³$$\begin{aligned}\sum_{d|n}\mu{(d)}={}&amp; \mu(1)+\mu(p_1)+â€¦+\mu(p_k)+\mu(p_1p_k)+â€¦+{} \\&amp;\mu(p_{k-1}p_k)+â€¦+\mu(p_1p_2â€¦p_k){}\\={}&amp;1+\binom{k}{1}(-1)+\binom{k}{2}(-1)^2+â€¦+\binom{k}{k}(-1)^k{}\\={}&amp;0\end{aligned}$$ æ€»ç»“èŽ«æ¯”ä¹Œæ–¯å‡½æ•°æœ¬èº«å…¶å®žå¹¶ä¸éš¾ï¼Œä½†æ˜¯è¦æ·±åˆ»åœ°ç†è§£å®ƒè¿˜æ˜¯æœ‰ä¸€ç‚¹ç‚¹å›°éš¾çš„ï¼Œä»¥åŽä¼šå’Œåˆ«çš„æœ‰å…³å‡½æ•°ç»“åˆèµ·æ¥è¿›è¡Œè®²è§£ï¼ŒåŠ æ·±è®°å¿†ã€‚]]></content>
      <categories>
        <category>æ•°è®º</category>
      </categories>
      <tags>
        <tag>æ•°è®º</tag>
        <tag>æ¬§æ‹‰å‡½æ•°</tag>
        <tag>èŽ«æ¯”ä¹Œæ–¯å‡½æ•°</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP æ¨¡æ‹Ÿ] 2018-8-7 é¢˜è§£: æˆ‘å†™äº†ä¸ªè‡ªå·±éƒ½çœ‹ä¸æ‡‚çš„ç¨‹åº]]></title>
    <url>%2F2018%2F08%2F07%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-7-%E9%A2%98%E8%A7%A3-%E6%88%91%E5%86%99%E4%BA%86%E4%B8%AA%E8%87%AA%E5%B7%B1%E9%83%BD%E7%9C%8B%E4%B8%8D%E6%87%82%E7%9A%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[å†™åœ¨å‰é¢ä»Šå¤©åˆ›åŽ†å²æ–°é«˜$290$åˆ†ï¼Œç¬¬ä¸‰é“é¢˜è€ƒå®Œè‡ªå·±éƒ½æ²¡çœ‹å‡ºè‡ªå·±ç”¨äº†å•¥æ–¹æ³•ï¼ˆOrzï¼‰ï¼Œæ„Ÿè§‰è‡ªå·²è¦åŽ»è¡¥æ•°æ®ç»“æž„â€¦â€¦å¦å¤–ç¬¬ä¸€é“é¢˜å®žåœ¨æ˜¯å‘â€¦â€¦ååˆ†å•Šï¼ï¼ T1 é€‰ä¸¾[é¢˜ç›®æè¿°] $C$å›½çš„æ€»ç»Ÿé€‰ä¸¾å§”å‘˜ä¼šæœ€è¿‘é‡åˆ°äº†ä¸€äº›éº»çƒ¦ã€‚ ä»–ä»¬åœ¨ç»Ÿè®¡å„çœå¯¹Hå…ˆç”Ÿçš„æ”¯æŒçŽ‡ï¼ˆç™¾åˆ†æ¯”ï¼‰æ—¶ï¼ŒæŠŠæ”¯æŒçŽ‡å››èˆäº”å…¥åˆ°äº†æ•´æ•°ã€‚ç­‰ä»–ä»¬å…¬å¸ƒç»“æžœåŽï¼Œè¯¥å›½åª’ä½“å‘çŽ°è¿™äº›çœä»½çš„æ”¯æŒçŽ‡ä¹‹å’Œä¸ç­‰äºŽ$100$ï¼ˆç™¾åˆ†æ¯”ï¼‰ï¼åœ¨åª’ä½“é»‘å¹•å£°çš„è´¨ç–‘ä¸‹ï¼Œä»–ä»¬ä¸å¾—ä¸æ‰¾ä½ å¯»æ±‚å¸®åŠ©ã€‚ ä½ å°†å¾—åˆ°å„çœå››èˆäº”å…¥åŽçš„æ”¯æŒçŽ‡ï¼Œè¯·è®¡ç®—è¿™äº›çœä»½çš„æ”¯æŒçŽ‡åœ¨å››èˆäº”å…¥å‰çš„å’Œæ˜¯å¦å¯èƒ½ç­‰äºŽ100ï¼Ÿæ”¯æŒçŽ‡æ˜¯ä»¥ç™¾åˆ†æ¯”çš„å½¢å¼ç»Ÿè®¡çš„ã€‚è¯·æ³¨æ„ï¼Œå„çœçš„æ”¯æŒçŽ‡å¯ä»¥æ˜¯ä¸€ä¸ªåŒ…å«ä»»æ„å¤šä½çš„æœ‰é™å°æ•°ã€‚ä¸€ä¸ªå°æ•°åœ¨å››èˆäº”å…¥åˆ°æ•´æ•°æ—¶ï¼Œè‹¥å°æ•°ç‚¹åŽç¬¬ä¸€ä½å°äºŽ5åˆ™èˆï¼Œå¤§äºŽç­‰äºŽ5åˆ™å…¥ã€‚ ä¾‹å¦‚ï¼š$26,17,58$æ˜¯ä¸€ç§å¯èƒ½çš„æ”¯æŒçŽ‡ï¼Œå› ä¸ºå®ƒä»¬å¯èƒ½æ˜¯$25.8,16.5,57.7$å››èˆäº”å…¥åŽå¾—åˆ°çš„ï¼Œè€Œ$25.8+16.5+57.7=100$ã€‚$49,49$æ˜¯ä¸€ç§ä¸å¯èƒ½çš„æ”¯æŒçŽ‡ï¼Œå› ä¸ºå½“$9$çš„ä¸ªæ•°æœ‰é™æ—¶ï¼Œæ— è®ºæœ‰å¤šå°‘ä¸ª$9$ï¼Œå‡æœ‰$49.499+â€¦+99+49.499+â€¦+99&lt;100$ã€‚ [è¾“å…¥æ ¼å¼] è¾“å…¥åŒ…å«å¤šç»„æ•°æ®ï¼Œç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°Tï¼Œè¡¨ç¤ºæ•°æ®ç»„æ•°ã€‚ æŽ¥ä¸‹æ¥æ˜¯Tç»„æ•°æ®ï¼Œæ¯ç»„æ•°æ®çš„ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ•´æ•°Nï¼Œè¡¨ç¤ºå‚ä¸Žé€‰ä¸¾çš„çœä»½ä¸ªæ•°ã€‚ ç¬¬äºŒè¡Œæ˜¯Nä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå„çœå››èˆäº”å…¥åŽçš„æ”¯æŒçŽ‡ã€‚ [è¾“å‡ºæ ¼å¼] å¯¹äºŽæ¯ç»„æ•°æ®ï¼Œè‹¥æ˜¯ä¸€ç§å¯èƒ½çš„æ”¯æŒçŽ‡ï¼Œè¾“å‡ºYesï¼Œå¦åˆ™è¾“å‡ºNoã€‚ [æ ·ä¾‹è¾“å…¥] 2 2 49 49 3 26 17 58 [æ ·ä¾‹è¾“å‡º] No Yes [æ•°æ®èŒƒå›´ä¸Žçº¦å®š] å¯¹äºŽ30%çš„æ•°æ®ï¼Œ1&lt;=n&lt;=3ï¼› å¯¹äºŽ50%çš„æ•°æ®ï¼Œ1&lt;=n&lt;=5ï¼› å¯¹äºŽ80%çš„æ•°æ®ï¼Œ1&lt;=å››èˆäº”å…¥åŽå„çœçš„æ”¯æŒçŽ‡&lt;=99ï¼› å¯¹äºŽ100%çš„æ•°æ®ï¼Œ1&lt;=n&lt;=10000ï¼Œè¾“å…¥æ•°æ®ä¸­çš„æ‰€æœ‰æ•´æ•°å‡åœ¨æœ‰ç¬¦å·16ä½æ•´æ•°èŒƒå›´å†…ã€‚ [é¢˜è§£] ç®€å•æ•°å€¼è®¡ç®—é¢˜ï¼Œç›´æŽ¥è®¨è®ºæƒ…å†µå¹¶è®¡ç®—å³å¯ã€‚å…·ä½“æ¥è®²ï¼Œå¯ä»¥æ±‚å‡ºä½¿ç”¨ç»™å‡ºçš„$N$ä¸ªæ”¯æŒçŽ‡ï¼Œæœ€ç»ˆå¯èƒ½çš„æ”¯æŒçŽ‡çš„å–å€¼èŒƒå›´ï¼Œæ£€æŸ¥è¯¥èŒƒå›´æ˜¯å¦åŒ…å«$100$ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸€ä¸ªæ•°Xåœ¨å–èˆå‰å¯èƒ½å–$[X-0,5,X+0.5)$ä¹‹é—´çš„ä»»æ„æ•°å€¼ã€‚éœ€è¦æ³¨æ„$0$å’Œ$100$ç­‰è¾¹ç•Œé—®é¢˜ï¼Œå› ä¸ºæ”¯æŒçŽ‡ï¼ˆç™¾åˆ†æ¯”ï¼‰ä¸€å®šæ˜¯ä¸€ä¸ª$[0,100]$ä¹‹é—´çš„æ•°ã€‚æ±‚å‡ºçš„å–å€¼èŒƒå›´æœ€å¥½ä½¿ç”¨æ•´æ•°å¹¶åŠ ä»¥å¼€é—­åŒºé—´åˆ¤æ–­ï¼Œé¿å…å®žæ•°ç²¾åº¦è¯¯å·®ã€‚ [å‚è€ƒä»£ç ] 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define int64 long longint T, n, x;int64 sum, l, r;int main() &#123; ios::sync_with_stdio(false); ifstream in("election.in"); ofstream out("election.out"); in.tie(NULL); in &gt;&gt; T; while (T--) &#123; in &gt;&gt; n; int cnt0 = 0, cnt100 = 0, flag = 0; sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; x; sum += x; if (x == 0) ++cnt0; if (x == 100) ++cnt100; if (x &gt; 100) flag = 1; &#125; if (flag) &#123; out &lt;&lt; "No" &lt;&lt; endl; continue; &#125; l = sum - (n - cnt0) / 2; r = sum + (n + cnt100) / 2; bool cond0 = (l &lt;= 100); bool cond1; if ((n - cnt100) &amp; 1 || (n - cnt100) == 0) cond1 = (r &gt;= 100); else cond1 = r &gt; 100; if (cond0 &amp;&amp; cond1) out &lt;&lt; "Yes" &lt;&lt; endl; else out &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125;// æ³¨ï¼šè¿™ä¸ªå…¶å®žæ˜¯æ ‡ç¨‹ï¼Œè¿ž double éƒ½æ²¡æœ‰ç”¨ ï¼ˆOrzï¼‰ [è¯„ä»·] è€ƒå¯Ÿäº†åŸºç¡€çš„æ•°å­¦çŸ¥è¯†ï¼Œåªè¦æžæ¸…æ¥šå¼€åŒºé—´å’Œé—­åŒºé—´å°±å¥½äº†ã€‚ T2 å¼‚è±¡çŸ³[é¢˜ç›®æè¿°] Adera æ˜¯ Microsoft åº”ç”¨å•†åº—ä¸­çš„ä¸€æ¬¾è§£è°œæ¸¸æˆã€‚å¼‚è±¡çŸ³æ˜¯è¿›å…¥ Adera ä¸­å¼‚æ—¶ç©ºçš„å¼•å¯¼ç‰©ï¼Œåœ¨ Adera çš„å¼‚æ—¶ç©ºä¸­æœ‰ä¸€å¼ åœ°å›¾ã€‚è¿™å¼ åœ°å›¾ä¸Šæœ‰$N$ä¸ªç‚¹ï¼Œæœ‰$N-1$æ¡åŒå‘è¾¹æŠŠå®ƒä»¬è¿žé€šèµ·æ¥ã€‚èµ·åˆåœ°å›¾ä¸Šæ²¡æœ‰ä»»ä½•å¼‚è±¡çŸ³ï¼Œåœ¨æŽ¥ä¸‹æ¥çš„$M$ä¸ªæ—¶åˆ»ä¸­ï¼Œæ¯ä¸ªæ—¶åˆ»ä¼šå‘ç”Ÿä»¥ä¸‹ä¸‰ç§ç±»åž‹çš„äº‹ä»¶ä¹‹ä¸€ï¼š åœ°å›¾çš„æŸä¸ªç‚¹ä¸Šå‡ºçŽ°äº†å¼‚è±¡çŸ³ï¼ˆå·²ç»å‡ºçŽ°çš„ä¸ä¼šå†æ¬¡å‡ºçŽ°ï¼‰ï¼› åœ°å›¾æŸä¸ªç‚¹ä¸Šçš„å¼‚è±¡çŸ³è¢«æ‘§æ¯ï¼ˆä¸ä¼šæ‘§æ¯æ²¡æœ‰å¼‚è±¡çŸ³çš„ç‚¹ï¼‰ï¼› å‘çŽ©å®¶è¯¢é—®ä½¿æ‰€æœ‰å¼‚è±¡çŸ³æ‰€åœ¨çš„ç‚¹è¿žé€šçš„è¾¹é›†çš„æ€»é•¿åº¦æœ€å°æ˜¯å¤šå°‘ã€‚ è¯·ä½ ä½œä¸ºçŽ©å®¶å›žç­”è¿™äº›é—®é¢˜ã€‚ [è¾“å…¥æ ¼å¼] ç¬¬ä¸€è¡Œæœ‰ä¸€ä¸ªæ•´æ•°Nï¼Œè¡¨ç¤ºç‚¹çš„ä¸ªæ•°ã€‚ æŽ¥ä¸‹æ¥N-1è¡Œæ¯è¡Œä¸‰ä¸ªæ•´æ•°x,y,zï¼Œè¡¨ç¤ºç‚¹xå’Œyä¹‹é—´æœ‰ä¸€æ¡é•¿åº¦ä¸ºzçš„åŒå‘è¾¹ã€‚ ç¬¬N+1è¡Œæœ‰ä¸€ä¸ªæ­£æ•´æ•°Mã€‚ æŽ¥ä¸‹æ¥Mè¡Œæ¯è¡Œæ˜¯ä¸€ä¸ªäº‹ä»¶ï¼Œäº‹ä»¶æ˜¯ä»¥ä¸‹ä¸‰ç§æ ¼å¼ä¹‹ä¸€ï¼š + x è¡¨ç¤ºç‚¹xä¸Šå‡ºçŽ°äº†å¼‚è±¡çŸ³ - x è¡¨ç¤ºç‚¹xä¸Šçš„å¼‚è±¡çŸ³è¢«æ‘§æ¯ ?è¡¨ç¤ºè¯¢é—®ä½¿å½“å‰æ‰€æœ‰å¼‚è±¡çŸ³æ‰€åœ¨çš„ç‚¹è¿žé€šæ‰€éœ€çš„è¾¹é›†çš„æ€»é•¿åº¦æœ€å°æ˜¯å¤šå°‘ã€‚ [è¾“å‡ºæ ¼å¼] å¯¹äºŽæ¯ä¸ª ?äº‹ä»¶ï¼Œè¾“å‡ºä¸€ä¸ªæ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚ [æ ·ä¾‹è¾“å…¥] 6 1 2 1 1 3 5 4 1 7 4 5 3 6 4 2 10 + 3 + 1 ? + 6 ? + 5 ? - 6 - 3 ? [æ ·ä¾‹è¾“å‡º] 5 14 17 10 [æ•°æ®èŒƒå›´ä¸Žçº¦å®š] å¯¹äºŽ30%çš„æ•°æ®ï¼Œ1 â‰¤ n, m â‰¤ 1000ã€‚ å¯¹äºŽå¦20%çš„æ•°æ®ï¼Œåœ°å›¾æ˜¯ä¸€æ¡é“¾ï¼Œæˆ–è€…ä¸€æœµèŠèŠ±ã€‚ å¯¹äºŽ100%çš„æ•°æ®ï¼Œ1 â‰¤ n, m â‰¤ 10^5, 1 â‰¤ x, y â‰¤ n, x â‰  y, 1 â‰¤ z â‰¤ 10^9ã€‚ [é¢˜è§£] å¦‚æžœåœ¨$a_1,a_2â€¦a_k$è¿™äº›ç‚¹ä¸Šæœ‰å¼‚è±¡çŸ³ï¼Œåˆ™æ‰€éœ€ä»£ä»·å°±æ˜¯æŒ‰ç…§DFSåºä¾æ¬¡éåŽ†è¿™$k$ä¸ªç‚¹å†å›žåˆ°æ ¹çš„æ€»è·ç¦»ã€‚è¿™ä¸ªè·ç¦»æ•°è¿˜ç­‰äºŽ$a_1,a_2â€¦a_k$æŽ’æˆä¸€ä¸ªçŽ¯å½¢åºåˆ—ï¼Œç›¸é‚»ä¸¤ä¸ªç‚¹çš„è·ç¦»ä¹‹å’Œã€‚å› æ­¤ç”¨setç»´æŠ¤æœ‰å¼‚è±¡çŸ³çš„ç‚¹æž„æˆçš„DFSåºï¼Œç”¨ä¸€ä¸ªå…¨å±€å˜é‡è®°å½•ç­”æ¡ˆï¼Œæ’å…¥ã€åˆ é™¤æ—¶æ›´æ–°setçš„åŒæ—¶åˆ©ç”¨LCAç®—æ³•æ›´æ–°ç­”æ¡ˆã€‚ [å‚è€ƒä»£ç ] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define NOE -1#define int64 long longint n, m, x, y, z, v;char op;set&lt;int&gt; s;int64 ans, dis[maxn], g[maxn];int cnt = 0;int f[maxn][20], dep[maxn], dfn[maxn], seq[maxn];struct edgeNode &#123; int vertexTo; int edgeNext; int weight;&#125;;edgeNode edges[maxn &lt;&lt; 1];int heads[maxn &lt;&lt; 1];int numEdges = 0;inline void init() &#123; memset(heads, NOE, sizeof(heads)); &#125;inline void addEdge(int vertex1, int vertex2, int weight) &#123; numEdges++; edges[numEdges].vertexTo = vertex2; edges[numEdges].weight = weight; edges[numEdges].edgeNext = heads[vertex1]; heads[vertex1] = numEdges;&#125;inline void addDuplexEdge(int vertex1, int vertex2, int weight) &#123; addEdge(vertex1, vertex2, weight); addEdge(vertex2, vertex1, weight);&#125;inline void rDFS(int x, int fa) &#123; f[x][0] = fa; dep[x] = dep[fa] + 1; dfn[x] = ++cnt; seq[cnt] = x; for (int i = heads[x]; i != NOE; i = edges[i].edgeNext) &#123; int vt = edges[i].vertexTo; if (vt != fa) &#123; dis[vt] = dis[x] + edges[i].weight; rDFS(vt, x); &#125; &#125;&#125;inline void initFa() &#123; for (int i = 1; i &lt;= 19; ++i) for (int j = 1; j &lt;= n; ++j) f[j][i] = f[f[j][i - 1]][i - 1];&#125;inline int LCA(int x, int y) &#123; if (dep[x] &lt; dep[y]) swap(x, y); int t = dep[x] - dep[y]; for (int i = 0; i &lt;= 16; ++i) if (t &amp; (1 &lt;&lt; i)) x = f[x][i]; if (x == y) return x; for (int i = 16; i &gt;= 0; --i) &#123; if (f[x][i] != f[y][i]) &#123; x = f[x][i]; y = f[y][i]; &#125; &#125; return f[x][0];&#125;inline int64 getDist(int x, int y) &#123; return dis[x] + dis[y] - dis[LCA(x, y)] * 2;&#125;inline void find(int x, int &amp;l, int &amp;r) &#123; set&lt;int&gt;::iterator it = s.lower_bound(x); if (it != s.end()) r = *it; else r = *s.begin(); if (it == s.begin()) it = s.end(); l = *(--it); l = seq[l]; r = seq[r];&#125;inline void insert(int x) &#123; if (!s.empty()) &#123; int l, r; find(dfn[x], l, r); ans -= g[r]; g[x] = getDist(l, x); g[r] = getDist(x, r); ans += g[x] + g[r]; &#125; else g[x] = 0; s.insert(dfn[x]);&#125;inline void erase(int x) &#123; int l, r; s.erase(dfn[x]); if (!s.empty()) &#123; find(dfn[x], l, r); ans -= g[x] + g[r]; g[r] = getDist(l, r); &#125; ans += g[r];&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("stone.in"); ofstream out("stone.out"); in.tie(NULL); init(); in &gt;&gt; n; for (int i = 1; i &lt; n; ++i) &#123; in &gt;&gt; x &gt;&gt; y &gt;&gt; z; addDuplexEdge(x, y, z); &#125; rDFS(1, 0); initFa(); in &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; in &gt;&gt; op; switch (op) &#123; case '+' : &#123; in &gt;&gt; v; insert(v); break; &#125; case '-' : &#123; in &gt;&gt; v; erase(v); break; &#125; case '?' : &#123; out &lt;&lt; ans / 2 &lt;&lt; endl; break; &#125; &#125; &#125; return 0;&#125;// è¿™é“é¢˜å¿…é¡»ä¸€æ¬¡æ“ä½œæ›´æ–°ä¸€æ¬¡ç­”æ¡ˆï¼Œå¦åˆ™ä¼š TLE æ­¤å¤„é™„ä¸Š std::set çš„ç”¨æ³• [è¯„ä»·] å¯¹äºŽæ²¡æœ‰åšè¿‡çš„åŒå­¦æ¥è¯´ï¼Œæ€ç»´éš¾åº¦è¿˜æ˜¯æ¯”è¾ƒå¤§çš„ï¼Œè¿™ç§æ–¹æ³•å°±ç›´æŽ¥è®°ä½å°±è¡Œäº†ï¼Œè¦ç”¨çš„æ—¶å€™ç›´æŽ¥æ‹¿å‡ºæ¥ç”¨ã€‚ T3 åºåˆ—å˜æ¢ï¼ˆæœ¬æ¬¡é‡ç‚¹ï¼ï¼ï¼ï¼‰[é¢˜ç›®æè¿°] ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º$N$çš„æ•°åˆ—$A_i$ã€‚ä½ å¯ä»¥å¯¹æ•°åˆ—è¿›è¡Œè‹¥å¹²æ¬¡æ“ä½œï¼Œæ¯æ¬¡æ“ä½œå¯ä»¥ä»Žæ•°åˆ—ä¸­ä»»é€‰ä¸€ä¸ªæ•°ï¼ŒæŠŠå®ƒç§»åŠ¨åˆ°æ•°åˆ—çš„å¼€å¤´æˆ–è€…ç»“å°¾ã€‚æ±‚æœ€å°‘ç»è¿‡å¤šå°‘æ¬¡æ“ä½œï¼Œå¯ä»¥æŠŠæ•°åˆ—å˜æˆå•è°ƒä¸å‡çš„ã€‚â€œå•è°ƒä¸å‡â€æ„å‘³ç€æ•°åˆ—ä¸­çš„ä»»æ„ä¸€ä¸ªæ•°éƒ½ä¸å¤§äºŽæŽ’åœ¨å®ƒåŽè¾¹çš„æ•°ã€‚ [è¾“å…¥æ ¼å¼] ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ­£æ•´æ•°Nã€‚ ç¬¬äºŒè¡Œæ˜¯Nä¸ªæ­£æ•´æ•°Aiã€‚ [è¾“å‡ºæ ¼å¼] è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€å°‘éœ€è¦çš„æ“ä½œæ¬¡æ•°ã€‚ [æ ·ä¾‹è¾“å…¥] 5 6 3 7 8 6 [æ ·ä¾‹è¾“å‡º] 2 [æ•°æ®èŒƒå›´ä¸Žçº¦å®š] å¯¹äºŽ30%çš„æ•°æ®ï¼Œæ»¡è¶³1â‰¤nâ‰¤10ã€‚ å¯¹äºŽ60% çš„æ•°æ®ï¼Œæ»¡è¶³1â‰¤nâ‰¤1000ã€‚ å¯¹äºŽ100% çš„æ•°æ®ï¼Œæ»¡è¶³1â‰¤nâ‰¤1000000ï¼Œ1â‰¤Aiâ‰¤1000000ã€‚ [é¢˜è§£] ç»è¿‡åˆ†æžå¯ä»¥å‘çŽ°ï¼Œæœ€ä¼˜è§£æƒ…å†µä¸‹ï¼Œéœ€è¦ä¿æŒä¸€ä¸ªå­åºåˆ—ä¸åŠ¨ï¼Œè¿™ä¸ªå­åºåˆ—æ»¡è¶³ï¼š å­åºåˆ—å•è°ƒé€’å¢žï¼› è‹¥å­åºåˆ—ä¸­æœ€å°æ•°æ˜¯$L$ï¼Œæœ€å¤§æ•°æ˜¯$R$ï¼Œåˆ™å­åºåˆ—å¿…é¡»åŒ…å«$[L+1,R-1]$ä¸­çš„æ•°åˆ—ä¸­çš„æ‰€æœ‰æ•°ã€‚ ç”¨å•è°ƒé˜Ÿåˆ—æ±‚å‡ºæ»¡è¶³è¿™ä¸¤ä¸ªæ¡ä»¶çš„å­åºåˆ—çš„æœ€å¤§é•¿åº¦ï¼Œç”¨$n$å‡åŽ»å°±æ˜¯ç­”æ¡ˆã€‚å³è¿™ä¸ªå­åºåˆ—ä¿æŒä¸åŠ¨ï¼Œå…¶ä½™æ•°å‘å‰æˆ–åŽç§»åŠ¨ä¸€æ¬¡ã€‚ [å‚è€ƒä»£ç ] 1234567891011121314151617181920212223242526272829303132333435363738394041424344// ä»¥ä¸‹ä¸º std ä»£ç ï¼Œä¸æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥è·³è¿‡#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;set&gt;using namespace std;const int SIZE = 1000010;int a[SIZE], q[SIZE];int n, m, ans;vector&lt;int&gt; b[SIZE];int main() &#123; freopen("change.in","r",stdin); freopen("change.out","w",stdout); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); b[a[i]].push_back(i); m = max(m, a[i]); &#125; int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) &#123; reverse(b[i].begin(), b[i].end()); for (int j = 0; j &lt; b[i].size(); j++) &#123; int k = b[i][j]; while (l &lt;= r &amp;&amp; q[r] &gt; k) &#123; while (l &lt; r &amp;&amp; a[q[l]] &lt; a[q[r]]) l++; r--; &#125; ans = max(ans, r - l + 2 + j); &#125; for (int j = b[i].size() - 1; j &gt;= 0; j--) &#123; q[++r] = b[i][j]; &#125; //cout &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; n - ans &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// ä»¥ä¸‹æ˜¯è€ƒè¯•æ—¶çžŽæ‰“çš„ä»£ç ï¼š#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 1100000#define INF 0x3f3f3f3fint n, A[maxn], B[maxn];int ans = -INF;int len = 0;inline bool compare(int x, int y) &#123; if (A[x] == A[y]) return x &lt; y; return A[x] &lt; A[y];&#125;int main() &#123; ios::sync_with_stdio(false); ifstream in("change.in"); ofstream out("change.out"); in.tie(NULL); in &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; in &gt;&gt; A[i]; B[i] = i; &#125; sort(B + 1, B + n + 1, compare); // B æ•°ç»„è®°å½• A ä¸­å…ƒç´ çš„ ä½ç½®ï¼Œä¸”ä»¥ A ä¸­ç›¸åº”çš„å…ƒç´ å¤§å°ä¸ºä¼˜å…ˆæŽ’åº int j; for (int i = 1; i &lt;= n; i = j + 1) &#123; for (j = i; i &lt; n &amp;&amp; B[j] &lt; B[j + 1]; j++); len = j - i + 1; // ä»¥ä¸Šè¿™æ®µå…ˆæ‰¾å‡ºä»Ž i å¼€å§‹åºå·é€’å¢žçš„å­åºåˆ—çš„æœ€å¤§é•¿åº¦ for (int k = i - 1; k != 0 &amp;&amp; A[B[k]] == A[B[i - 1]]; --k) if (B[k] &lt; B[i]) len++; for (int k = j + 1; k &lt;= n &amp;&amp; A[B[j + 1]] == A[B[k]]; ++k) if (B[j] &lt; B[k]) len++; // å› ä¸ºå‰é¢ i ç›´æŽ¥å˜ä¸º j + 1ï¼Œæ‰€ä»¥å¯èƒ½å‡ºçŽ°é‡å¤çš„æ•°å­—å¿½ç•¥çš„æƒ…å†µ // æ•…åœ¨ä¸Šé¢ä¸¤ä¸ªå¾ªçŽ¯ä¸­ï¼š // ä¸€ä¸ªå‘å·¦æ‰«ï¼Œä¸€ä¸ªå‘å³æ‰«ï¼ŒåŒæ—¶åˆ¤æ–­åœ¨åŽŸæ•°ç»„ä¸­çš„ä½ç½®æ˜¯å¦é€’å¢ž // è¿™ç§æ–¹æ³•é€Ÿåº¦ä¼šæ›´å¿«ä¸€ç‚¹ã€‚ ans = max(ans, len); // èŽ·å–æœ€å¤§é•¿åº¦ &#125; out &lt;&lt; n - ans; // ç›¸å‡ return 0;&#125;// è€ƒå®Œè¯•åŽè‡ªå·±éƒ½æ— æ³•è®°èµ·è¿™æ˜¯ä»€ä¹ˆç¥žå¥‡çš„ç®—æ³•ï¼Œä¸è¿‡ä»”ç»†æƒ³æƒ³è¿˜æ˜¯èƒ½æƒ³èµ·æ¥çš„ã€‚ [è¯„ä»·] è¿™é“é¢˜æ—¢è€ƒéªŒæ€ç»´åˆè€ƒéªŒä»£ç èƒ½åŠ›ï¼Œå¥½é¢˜ã€‚ æ€»ç»“é¦–å…ˆï¼Œä»ç„¶è¦è®°ä½ä»”ç»†è¯»é¢˜ï¼Œè¿™æ¬¡ç¬¬ä¸€é¢˜å°±æ˜¯å› ä¸ºè¯»é¢˜ä¸ä»”ç»†ï¼Œæ€è€ƒä¸å……åˆ†æ‰å‡ºé—®é¢˜çš„ã€‚å…¶æ¬¡ï¼Œæœ‰äº›ä»£ç è¿˜æ˜¯å¥½å¥½æ‰“æ‰“è‰ç¨¿ï¼Œå†™å†™æµç¨‹å›¾æ¯”è¾ƒå¥½ï¼Œé˜²æ­¢åƒç¬¬ä¸‰é¢˜ä¸€æ ·æƒ³ä¸èµ·æ¥ï¼ˆ#æ»‘ç¨½ï¼‰ã€‚]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP æ¨¡æ‹Ÿ</tag>
        <tag>é¢˜è§£</tag>
        <tag>ç¥žé¢˜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP æ¨¡æ‹Ÿ] 2018-8-6 é¢˜è§£: ä¸€æ¬¡æˆå‰§æ€§çš„æ¨¡æ‹Ÿæµ‹è¯•]]></title>
    <url>%2F2018%2F08%2F06%2FNOIP-%E6%A8%A1%E6%8B%9F-2018-8-6-%E9%A2%98%E8%A7%A3-%E4%B8%80%E6%AC%A1%E6%88%8F%E5%89%A7%E6%80%A7%E7%9A%84%E6%A8%A1%E6%8B%9F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æ¨¡æ‹Ÿæµ‹è¯•ä¸€å…±æœ‰ä¸‰é“é¢˜ï¼Œè¿™é‡Œå…ˆå‘ä¸€ä¸‹æœ‰å…³è¿™ä¸‰é“é¢˜çš„é¢˜è§£ï¼Œæœ‰å…³è¿™å‡ ç±»é¢˜ç›®çš„è¯¦è§£ä¼šåœ¨ä»¥åŽæ›´æ–°ã€‚ T1 å¥‡æ•°ç é—®é¢˜[é¢˜ç›®æè¿°] ä½ ä¸€å®šçŽ©è¿‡å…«æ•°ç æ¸¸æˆï¼Œå®ƒå®žé™…ä¸Šæ˜¯åœ¨ä¸€ä¸ª$3\times 3$çš„ç½‘æ ¼ä¸­è¿›è¡Œçš„ï¼Œ$1$ä¸ªç©ºæ ¼å’Œ$1 \sim 8$è¿™$8$ä¸ªæ•°å­—æ°å¥½ä¸é‡ä¸æ¼åœ°åˆ†å¸ƒåœ¨è¿™$3 \times 3$çš„ç½‘æ ¼ä¸­ã€‚ ä¾‹å¦‚ï¼š 5 2 8 1 3 _ 4 6 7 åœ¨æ¸¸æˆè¿‡ç¨‹ä¸­ï¼Œå¯ä»¥æŠŠç©ºæ ¼ä¸Žå…¶ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘ä¹‹ä¸€çš„æ•°å­—äº¤æ¢ï¼ˆå¦‚æžœå­˜åœ¨ï¼‰ã€‚ä¾‹å¦‚åœ¨ä¸Šä¾‹ä¸­ï¼Œç©ºæ ¼å¯ä¸Žå·¦ã€ä¸Šã€ä¸‹é¢çš„æ•°å­—äº¤æ¢ï¼Œåˆ†åˆ«å˜æˆï¼š 5 2 8 5 2 _ 5 2 8 1 _ 3 1 3 8 1 3 7 4 6 7 4 6 7 4 6 _ å¥‡æ•°ç æ¸¸æˆæ˜¯å®ƒçš„ä¸€ä¸ªæ‰©å±•ï¼Œåœ¨ä¸€ä¸ª$n \times n$çš„ç½‘æ ¼ä¸­è¿›è¡Œï¼Œå…¶ä¸­nä¸ºå¥‡æ•°ï¼Œ1ä¸ªç©ºæ ¼å’Œ$1 \sim n\times n-1$è¿™$n\times n-1$ä¸ªæ•°æ°å¥½ä¸é‡ä¸æ¼åœ°åˆ†å¸ƒåœ¨$n\times n$çš„ç½‘æ ¼ä¸­ã€‚ ç©ºæ ¼ç§»åŠ¨çš„è§„åˆ™ä¸Žå…«æ•°ç æ¸¸æˆç›¸åŒï¼Œå®žé™…ä¸Šï¼Œå…«æ•°ç å°±æ˜¯ä¸€ä¸ª$n=3$çš„å¥‡æ•°ç æ¸¸æˆã€‚ çŽ°åœ¨ç»™å®šä¸¤ä¸ªå¥‡æ•°ç æ¸¸æˆçš„å±€é¢ï¼Œè¯·åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸€ç§ç§»åŠ¨ç©ºæ ¼çš„æ–¹å¼ï¼Œä½¿å¾—å…¶ä¸­ä¸€ä¸ªå±€é¢å¯ä»¥å˜åŒ–åˆ°å¦ä¸€ä¸ªå±€é¢ã€‚ [è¾“å…¥æ ¼å¼] å¤šç»„æ•°æ®ï¼Œå¯¹äºŽæ¯ç»„æ•°æ®ï¼š ç¬¬1è¡Œä¸€ä¸ªå¥‡æ•´æ•°nã€‚ æŽ¥ä¸‹æ¥nè¡Œæ¯è¡Œnä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç¬¬ä¸€ä¸ªå±€é¢ã€‚ æŽ¥ä¸‹æ¥nè¡Œæ¯è¡Œnä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºç¬¬äºŒä¸ªå±€é¢ã€‚ å±€é¢ä¸­æ¯ä¸ªæ•´æ•°éƒ½æ˜¯0~n*n-1ä¹‹ä¸€ï¼Œå…¶ä¸­ç”¨0ä»£è¡¨ç©ºæ ¼ï¼Œå…¶ä½™æ•°å€¼ä¸Žå¥‡æ•°ç æ¸¸æˆä¸­çš„æ„ ä¹‰ç›¸åŒï¼Œä¿è¯è¿™äº›æ•´æ•°çš„åˆ†å¸ƒä¸é‡ä¸æ¼ã€‚ [è¾“å‡ºæ ¼å¼] å¯¹äºŽæ¯ç»„æ•°æ®ï¼Œè‹¥ä¸¤ä¸ªå±€é¢å¯è¾¾ï¼Œè¾“å‡ºTAKï¼Œå¦åˆ™è¾“å‡ºNIEã€‚ [æ ·ä¾‹è¾“å…¥] 3 1 2 3 0 4 6 7 5 8 1 2 3 4 5 6 7 8 0 1 0 0 [æ ·ä¾‹è¾“å‡º] TAK TAK [æ•°æ®èŒƒå›´ä¸Žçº¦å®š] å¯¹äºŽ30%çš„æ•°æ®ï¼Œ1&lt;=n&lt;=3ï¼› å¯¹äºŽ60%çš„æ•°æ®ï¼Œ1&lt;=n&lt;=50ï¼› å¯¹äºŽ100%çš„æ•°æ®ï¼Œ1&lt;=n&lt;=500ï¼Œnä¸ºå¥‡æ•°ï¼Œæ¯ä¸ªæµ‹è¯•ç‚¹ä¸è¶…è¿‡10ç»„ã€‚ [é¢˜è§£] é€šè¿‡é¢˜ç›®å¯çŸ¥ï¼Œè¿™æ˜¯ä¸€é“ç»å…¸çš„å…«æ•°ç é—®é¢˜ï¼Œå¯ä»¥è¯´æ˜¯æ¨¡æ¿é¢˜ã€‚å¯¹äºŽè¿™ç§é—®é¢˜ï¼Œå¯ä»¥æŠŠæ–¹é˜µè½¬ä¸ºé“¾ï¼ˆå¿½ç•¥è¾“å…¥çš„$0$ï¼‰ï¼Œç„¶åŽç»Ÿè®¡åˆå§‹çŠ¶æ€å’Œç›®æ ‡çŠ¶æ€çš„é€†åºå¯¹çš„æ•°é‡ã€‚è‹¥é€†åºå¯¹æ•°çš„å¥‡å¶æ€§ç›¸åŒï¼Œåˆ™å¯ä»¥åˆ°è¾¾ï¼Œå¦åˆ™ä¸è¡Œã€‚ [å‚è€ƒä»£ç ] 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int n, a, t[300010];inline void modify(int x) &#123; for (int i = x; i &lt;= n; i += i &amp; -i) ++t[i];&#125;inline int query(int x) &#123; int res = 0; for (int i = x; i; i -= i &amp; -i) res += t[i]; return res;&#125;inline int work() &#123; memset(t, 0, sizeof(t)); int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", &amp;a); if (!a) continue; cnt += query(n) - query(a); modify(a); &#125; return cnt &amp; 1;&#125;int main() &#123; freopen("digital.in", "r", stdin); freopen("digital.out", "w", stdout); for (; scanf("%d", &amp;n) == 1; ) &#123; n *= n; if (work() == work()) printf("TAK\n"); else printf("NIE\n"); &#125; return 0;&#125;// æ­¤å¤„ä½¿ç”¨äº†æ ‘çŠ¶æ•°ç»„åš// æœ¬é¢˜è¿˜å¯ä»¥ä½¿ç”¨å½’å¹¶æŽ’åºåšï¼Œæœ‰å…´è¶£çš„åŒå­¦å¯ä»¥è¯•è¯•çœ‹ç”¨å½’å¹¶æŽ’åºåšã€‚ [è¯„ä»·] ç¬¬ä¸€é¢˜å˜›â€¦â€¦æ°´é¢˜ï¼Œæ¨¡æ¿é¢˜ï¼Œé€åˆ†é¢˜â€¦â€¦ T2 æ ‘æ´ž[é¢˜ç›®æè¿°] åœ¨ä¸€ç‰‡æ –æ¯åœ°ä¸Šæœ‰$N$æ£µæ ‘ï¼Œæ¯æ£µæ ‘ä¸‹ä½ç€ä¸€åªå…”å­ï¼Œæœ‰$M$æ¡è·¯å¾„è¿žæŽ¥è¿™äº›æ ‘ã€‚æ›´ç‰¹æ®Šåœ°æ˜¯ï¼Œåªæœ‰ä¸€æ£µæ ‘æœ‰$3$æ¡æˆ–æ›´å¤šçš„è·¯å¾„ä¸Žå®ƒç›¸è¿žï¼Œå…¶å®ƒçš„æ ‘åªæœ‰$1$æ¡æˆ–$2$æ¡è·¯å¾„ä¸Žå…¶ç›¸è¿žã€‚æ¢å¥è¯è®²ï¼Œè¿™äº›æ ‘å’Œæ ‘ä¹‹é—´çš„è·¯å¾„æž„æˆä¸€å¼ $N$ä¸ªç‚¹ã€$M$æ¡è¾¹çš„æ— å‘è¿žé€šå›¾ï¼Œè€Œåº¦æ•°å¤§äºŽ$2$çš„ç‚¹è‡³å¤šæœ‰$1$ä¸ªã€‚ è¿‘å¹´ä»¥æ¥ï¼Œæ –æ¯åœ°é¢‘ç¹æ”¶åˆ°äººç±»çš„ä¾µæ‰°ã€‚å…”å­ä»¬è”åˆèµ·æ¥å¬å¼€äº†ä¸€åœºä¼šè®®ï¼Œå†³å®šåœ¨å…¶ä¸­$K$æ£µæ ‘ä¸Šå»ºé€ æ ‘æ´žã€‚å½“å±é™©æ¥ä¸´æ—¶ï¼Œæ¯åªå…”å­å‡ä¼šåŒæ—¶å‰å¾€è·ç¦»å®ƒæœ€è¿‘çš„æ ‘æ´žèº²é¿ï¼Œè·¯ç¨‹ä¸­èŠ±è´¹çš„æ—¶é—´åœ¨æ•°å€¼ä¸Šç­‰äºŽè·ç¦»ã€‚ä¸ºäº†åœ¨æœ€çŸ­çš„æ—¶é—´å†…è®©æ‰€æœ‰å…”å­è„±ç¦»å±é™©ï¼Œè¯·ä½ å®‰æŽ’ä¸€ç§å»ºé€ æ ‘æ´žçš„æ–¹å¼ï¼Œä½¿æœ€åŽä¸€åªåˆ°è¾¾æ ‘æ´žçš„å…”å­æ‰€èŠ±è´¹çš„æ—¶é—´å°½é‡å°‘ã€‚ [è¾“å…¥æ ¼å¼] ç¬¬ä¸€è¡Œæœ‰3ä¸ªæ•´æ•°Nï¼ŒMï¼ŒKï¼Œåˆ†åˆ«è¡¨ç¤ºæ ‘ï¼ˆå…”å­ï¼‰çš„ä¸ªæ•°ã€è·¯å¾„æ•°ã€è®¡åˆ’å»ºé€ çš„æ ‘æ´žæ•°ã€‚ æŽ¥ä¸‹æ¥Mè¡Œæ¯è¡Œä¸‰ä¸ªæ•´æ•°x,yï¼Œè¡¨ç¤ºç¬¬xæ£µæ ‘å’Œç¬¬yæ£µæ ‘ä¹‹é—´æœ‰ä¸€æ¡è·¯å¾„ç›¸è¿žã€‚ 1&lt;=x,y&lt;=Nï¼Œxâ‰ yï¼Œä»»æ„ä¸¤æ£µæ ‘ä¹‹é—´è‡³å¤šåªæœ‰1æ¡è·¯å¾„ã€‚ [è¾“å‡ºæ ¼å¼] ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºåœ¨æœ€ä¼˜æ–¹æ¡ˆä¸‹ï¼Œæœ€åŽä¸€åªåˆ°è¾¾æ ‘æ´žçš„å…”å­æ‰€èŠ±è´¹çš„æ—¶é—´ã€‚ [æ ·ä¾‹è¾“å…¥] 5 5 2 1 2 2 3 3 1 1 4 4 5 [æ ·ä¾‹è¾“å‡º] 1 [æ•°æ®èŒƒå›´ä¸Žçº¦å®š] å¯¹äºŽ20%çš„æ•°æ®ï¼Œ1 â‰¤ n â‰¤ 10ã€‚ å¯¹äºŽå¦å¤–30%çš„æ•°æ®ï¼Œæ¯æ£µæ ‘è‡³å¤šä¸Ž2æ¡è·¯å¾„ç›¸è¿žã€‚ å¯¹äºŽå¦å¤–30%çš„æ•°æ®ï¼Œä¿è¯å­˜åœ¨ä¸€ç§æœ€ä¼˜è§£ï¼Œä½¿ä¸Ž3æ¡æˆ–æ›´å¤šè·¯å¾„ç›¸è¿žçš„æ ‘ä¸Šä¸€å®šå»ºé€ äº†æ ‘æ´žã€‚ å¯¹äºŽ100%çš„æ•°æ®ï¼Œ1 â‰¤ n â‰¤ 2000ï¼Œn-1&lt;=m&lt;=n*(n-1)/2ã€‚ [é¢˜è§£] æ±‚æœ€å¤§å€¼æœ€å°ï¼Œè€Œä¸”ç­”æ¡ˆæ»¡è¶³å•è°ƒï¼Œå¾ˆæ˜¾ç„¶å¯ä»¥ç”¨äºŒåˆ†å¦‚ä½•éªŒè¯ï¼Ÿé¦–å…ˆè€ƒè™‘ä¸€æ¡é“¾çš„æƒ…å†µï¼Œç­”æ¡ˆå¿…ç„¶æ˜¯$\frac{n - k}{k}$ï¼› è€Œå¦å¤–å­˜åœ¨ä¸€ä¸ªç‰¹æ®Šç‚¹æœ‰ä¸‰æ¡åŠä»¥ä¸Šçš„è¾¹çš„æƒ…å†µæˆ‘ä»¬å…ˆæžšä¸¾ä¸€ä¸ªç‚¹ï¼Œå¯ä»¥å°†ç‰¹æ®Šç‚¹è¦†ç›–ï¼Œè¦†ç›–åŽï¼ŒåŽŸæ¥çš„å›¾å°†æ–­æˆè‹¥å¹²æ¡é“¾ï¼Œç„¶åŽé‡å¤ä¹‹å‰é“¾çš„åšæ³•ç»Ÿè®¡ç­”æ¡ˆæ˜¯å¦è¶…è¿‡kï¼Œæ¥åˆ¤æ–­äºŒåˆ†çš„ç­”æ¡ˆæ˜¯å¦æ­£ç¡® [å‚è€ƒä»£ç ] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;int n, m, k, rt, deep, mi;int deg[2005], dis[2005];bool vis[2005], first[2005];int head[2005], num;struct edge &#123; int nxt, to;&#125; e[4000005];void add(int x, int y) &#123; e[++num].nxt = head[x]; e[num].to = y; head[x] = num;&#125;void dfs(int x, int len) &#123; deep += 1; vis[x] = 1; if (!len) return; for (int i = head[x]; i; i = e[i].nxt) &#123; int v = e[i].to; if (!vis[v]) &#123; dis[v] = dis[x] + 1; dfs(v, len - 1); &#125; &#125;&#125;bool check(int x) &#123; memset(vis, 0, sizeof(vis)); dfs(rt, x); memcpy(first, vis, sizeof(vis)); for (int i = 1; i &lt;= n; i++) &#123; if (first[i]) &#123; int res = 0; memset(vis, 0, sizeof(vis)); dfs(i, x); for (int j = 1; j &lt;= n &amp;&amp; res &lt; k; j++) if (!vis[j]) &#123; deep = 0; dfs(j, n); res += (deep + 2 * x) / (2 * x + 1); &#125; if (res &lt; k) return 1; &#125; &#125; return 0;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); deg[x]++; deg[y]++; add(x, y); add(y, x); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (deg[i] &gt; 2) &#123; rt=i; break; &#125; &#125; if (!rt) &#123; printf("%d", (n + k - 1) / k / 2); return 0; &#125; int l = 1, r = n - 1, ans = n; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; printf("%d", ans);&#125; [è¯„ä»·] ä¹‹æ‰€ä»¥æ ‡é¢˜ç§°è¿™æ¬¡æ¨¡æ‹Ÿä¸ºâ€œæˆå‰§æ€§çš„æ¨¡æ‹Ÿæµ‹è¯•â€ï¼Œæ˜¯å› ä¸ºè¿™é“é¢˜ä¸€å¼€å§‹ä¸ä¼šï¼Œç”¨äº†ä¸ªéšæœºæ•°éª—äº†ä¸ª 10 åˆ†ï¼ˆé€ƒï¼‰ã€‚ è™½ç„¶è¿™ç§éª—åˆ†æ–¹æ³•ä¸å€¼å¾—æå€¡ï¼Œä½†ä¹Ÿæ˜¯æ²¡æœ‰åŠžæ³•çš„åŠžæ³•ï¼Œæ¯•ç«Ÿä¿¡å¥¥æœ‰æ—¶å°±æ˜¯è¿™ä¹ˆçŽ„ã€‚ å¯¹äºŽè¿™ç§äºŒåˆ†ç­”æ¡ˆçš„é¢˜è¦è®°ä½é¢˜ç›®æ‰€æ»¡è¶³çš„æ¡ä»¶ï¼šå•è°ƒæ€§ï¼Œä¸€èˆ¬é‡åˆ°æœ€å¤§å€¼æ±‚æœ€å°ï¼Œæœ€å°å€¼æ±‚æœ€å¤§çš„è¿™ç§å‘é¢˜å¯ä»¥è€ƒè™‘äºŒåˆ†ç­”æ¡ˆçš„æ–¹æ³•äº†ã€‚ T3 ã¾ã‚“ãµã¯å‡½æ•°[åæ§½] ä¸ºä»€ä¹ˆè¿™é“é¢˜ä¸€ä¸Šæ¥å°±åæ§½å‘¢ï¼Ÿé¦–å…ˆï¼Œè¿™é“é¢˜çš„æ€ç»´éš¾åº¦æ¯”è¾ƒå¤§ï¼Œå…¶æ¬¡ï¼Œè¿™é“é¢˜çš„æ€ç»´éš¾åº¦æ¯”è¾ƒå°ï¼ˆWTF!!??ï¼‰ã€‚ é¦–å…ˆæ¥çœ‹ä¸€ä¸‹é¢˜ç›®ä¸­æ—¥è¯­çš„å‘éŸ³ï¼š é‡æ–°æŽ’åˆ—ä¹‹åŽï¼š ç»è¿‡ Google çš„æé†’ï¼š è¿™ä¸å°±æ˜¯ Huffman çš„æ„æ€å—â€¦â€¦æ˜Žæ‘†ç€è®©æˆ‘ä»¬ç”¨éœå¤«æ›¼æ ‘â€¦â€¦ ï¼ˆå½“ç„¶ï¼Œä»Žé¢˜ä¸­æ‰€ç»™çš„å…¬å¼ä¹Ÿå¯ä»¥çœ‹å‡ºæ¥ï¼Œæ¯”å¦‚è€ƒè¯•çš„æ—¶å€™æˆ‘å°±çœ‹å‡ºæ¥äº†ï¼ˆé€ƒï¼‰ã€‚ï¼‰ [é¢˜ç›®æè¿°] æœ‰nä¸ªæ­£æ•´æ•° $A[1], A[2]â€¦A[n]$ï¼Œæ»¡è¶³ ${A[i]}\geqslant{A[i+1]}$ã€‚å®ƒä»¬å¯ä»¥äº§ç”Ÿ$n$ä¸ªæ­£æ•´æ•° $B[1], B[2]â€¦B[n]$ï¼Œå…¶ä¸­ $B[i]=\sum_{j=i}^n A[j]$ ã¾ã‚“ãµã¯å‡½æ•°ï¼ˆãƒžãƒ³ãƒ•ãƒå‡½æ•°ï¼‰$f:(Z,Z) \rightarrow Z$å®šä¹‰ä¸ºï¼š $$f(i,j)=\begin{cases}0, &amp; \text{($i$,$j$) = (1,1)}\\\min\lbrace f(i-1,j+1), f(i,\lceil\frac{j}{2}\rceil)+B[i]\rbrace, &amp; i,j \in [1,n], \text{ } i,j \neq{(1,1)}\\10^{11037}, &amp; \text{otherwise}\end{cases}$$ è¯•æ±‚$f(n,1)$ã€‚ [è¾“å…¥æ ¼å¼] è¾“å…¥åŒ…å«å¤šç»„æ•°æ®ï¼Œä¸è¶…è¿‡10ç»„ã€‚ æ¯ç»„æ•°æ®çš„ç¬¬ä¸€è¡Œæ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œç¬¬äºŒè¡Œnä¸ªæ­£æ•´æ•°A[i]ã€‚ [è¾“å‡ºæ ¼å¼] å¯¹äºŽæ¯ç»„æ•°æ®ï¼Œè¾“å‡ºä¸€ä¸ªæ•´æ•°è¡¨ç¤ºf(n,1)ã€‚ [æ ·ä¾‹è¾“å…¥] 3 1 1 1 5 28 26 25 24 1 10 996 901 413 331 259 241 226 209 139 49 [æ ·ä¾‹è¾“å‡º] 5 233 11037 [æ ·ä¾‹è§£é‡Š] å¯¹äºŽç¬¬ä¸€ç»„æ•°æ®ï¼š f(1, 1) = 0 f(1, 2) = f(1, 1) + 3 = 3 f(1, 3) = f(1, 2) + 3 = 6 f(2, 1) = min(f(2, 1) + 2, f(1, 2)) = 3 f(2, 2) = min(f(2, 1) + 2, f(1, 3)) = 5 f(2, 3) = f(2, 2) + 2 = 7 f(3, 1) = min(f(3, 1) + 1, f(2, 2)) = 5 [æ•°æ®èŒƒå›´ä¸Žçº¦å®š] å¯¹äºŽ30%çš„æ•°æ®ï¼Œæ»¡è¶³1 â‰¤ n â‰¤ 20ã€‚ å¯¹äºŽ60% çš„æ•°æ®ï¼Œæ»¡è¶³1 â‰¤ n â‰¤ 1000ã€‚ å¯¹äºŽ 100% çš„æ•°æ®ï¼Œæ»¡è¶³1 â‰¤ n â‰¤ 100000ï¼Œ1 â‰¤ A[i] â‰¤ 10000ã€‚ [é¢˜è§£] å¯¹äºŽä¼šæ—¥è¯­çš„åŒå­¦ï¼Œç›´æŽ¥çœ‹åæ§½å°±è¡Œäº†ï¼Œå¦‚æžœä¸ä¼šæ—¥è¯­å‘¢ï¼Ÿå…ˆä»”ç»†è¯»é¢˜ï¼Œç ”ç©¶é¢˜ä¸­æ‰€ç»™çš„è¡¨è¾¾å¼ï¼Œæœ‰ä¸¤ä¸ªè¾¹ç•Œæ¡ä»¶ï¼Œè¿™æ˜¯ä¸æ˜¯å¾ˆåƒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Ÿé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ä»ŽåŠ¨æ€è§„åˆ’çš„è§’åº¦æ¥è§£å†³é¢˜ç›®çš„æ„æ€ã€‚$B$ æ•°ç»„å…¶å®žæ˜¯ $A$ çš„ä¸€ä¸ªåŽç¼€å’Œï¼Œè€Œ $min$ ä¸­çš„ä¸¤ä¸ª $f(i,j)$, ä¸€ä¸ªå‡ä¸€ï¼Œä¸€ä¸ªé™¤ä»¥äºŒï¼Œè‡ªç„¶è€Œç„¶åœ°è”æƒ³åˆ°è¿™æ˜¯æ ‘çš„åˆå¹¶ï¼Œè®° $f(i,j)$ ä¸ºåˆå¹¶äº† $i$ ä¸ªç‚¹ï¼Œäº§ç”Ÿ $j$ æ£µæ ‘çš„çŠ¶æ€ï¼Œé‚£ä¹ˆæˆ‘ä»¬è¦ä¹ˆåˆå¹¶åˆ°æ ‘ä¸­ï¼Œè¦ä¹ˆåˆå¹¶ä¸¤æ£µå­æ ‘ï¼Œä¸ºäº†ä½¿åˆå¹¶çš„æ€»é‡æœ€å°ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç”¨éœå¤«æ›¼æ ‘æ¥è§£äº†ï¼Œé¢˜ç›®çš„æ€è·¯å°±å¼€æœ—äº†ã€‚ [å‚è€ƒä»£ç ] 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define maxn 110000#define int64 long longint64 node[maxn], u[maxn];int64 tot, n, len, ans;int64 x, y;int64 top() &#123; if (x &lt;= n &amp;&amp; (y &gt; len || node[x] &lt; u[y])) return node[x++]; else return u[y++];&#125;int main() &#123; while (~scanf("%d",&amp;n)) &#123; ans = 0; len = 0; x = 1; y = 1; tot = 0; memset(node, 0, sizeof(node)); memset(u, 0, sizeof(u)); tot = n; for (int i = 1; i &lt;= n; ++i) &#123; int tmp; scanf("%d",&amp;tmp); node[tot--] = tmp; &#125; for (int i = 1; i &lt; n; ++i) &#123; u[len + 1] = top() + top(); ans += u[++len]; &#125; printf("%lld\n",ans); &#125; return 0;&#125;// æé†’æ³¨æ„å¤šç»„æ•°æ®è¯»å…¥é—®é¢˜// ++i å’Œ i++ çš„åŒºåˆ«è¦æ¸…æ¥š [è¯„ä»·] å¥½é¢˜ï¼Œç”±ç±»çŠ¶æ€è½¬ç§»æ–¹ç¨‹æŽ¨å‡ºé¢˜ç›®çš„åŽŸæ„ï¼Œå†è¿›è¡Œè§£ç­”ï¼Œæ€ç»´éš¾åº¦æ¯”è¾ƒå¤§ï¼Œå¥½é¢˜ã€‚ æ€»ç»“ä»Šå¤©ä¸‰é“é¢˜ï¼Œé™¤äº†ç¬¬ä¸‰é“é¢˜ï¼Œå¦å¤–ä¸¤é“é¢˜éƒ½ä¸æ˜¯å¾ˆè€ƒéªŒæ€ç»´ï¼Œåªè¦è¿˜æ˜¯æŠ€å·§ã€‚çœ‹æ¥æˆ‘è¿˜æ˜¯éœ€è¦æå‡è‡ªå·±çš„çŸ¥è¯†æ°´å¹³ï¼Œé˜²æ­¢å†å‡ºçŽ°ç¬¬äºŒé¢˜åšä¸å‡ºï¼Œåªèƒ½éšæœºæ•°çš„æƒ…å†µã€‚]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>NOIP æ¨¡æ‹Ÿ</tag>
        <tag>é¢˜è§£</tag>
        <tag>ç¥žé¢˜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world!]]></title>
    <url>%2F2018%2F08%2F05%2FHello-world%2F</url>
    <content type="text"><![CDATA[é‡æ–°å¼„äº†ä¸€ä¸ª Github è´¦å·ï¼Œå› ä¸ºé«˜ä¸­å†³å®šæžä¿¡æ¯ç«žèµ›äº†ï¼Œæ‰€ä»¥ä»¥åŽä¼šåœ¨è¿™ä¸ªæ–°çš„åšå®¢é‡Œä¸å®šæœŸåœ°æ›´æ–°ä¸€äº›æœ‰å…³ä¿¡æ¯ç«žèµ›çš„å†…å®¹ï¼Œå½“ç„¶ä¹Ÿå¯èƒ½ä¼šæ›´æ–°å…¶ä»–çš„å†…å®¹ã€‚ ç›®å½•TO BE CONTINUEDâ€¦â€¦]]></content>
      <categories>
        <category>æ‚è°ˆ</category>
      </categories>
      <tags>
        <tag>æ‚è°ˆ</tag>
      </tags>
  </entry>
</search>
